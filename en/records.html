<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
  "http://www.w3.org/TR/html4/loose.dtd"><!-- DO NOT EDIT THIS FILE-->
<!-- Edit the .tex version instead-->

<html>
<head>
<title>Records</title>
<link href="tspl.css" rel="stylesheet" type="text/css">
</head>
<body>
<a name="g138"></a>
<a name="./records:h0"></a>

<div style="font-size: 12px; width: 500px; height: 500px; border: solid thin">
<img style="padding: 20px 10px 20px 20px" src="canned/ch9.png"><img src="canned/jph.png">
</div>
<h1>Chapter 9. Records<a name="CHPTRECORDS"></a></h1>





<p>
<a name="./records:s0"></a><a name="./records:s1"></a><a name="./records:s2"></a>This chapter describes the means by which the programmer may define
new data types, or <i>records types</i>, each distinct from all other
types.
A record type determines the number and names of the fields each instance
of the type has.
Records are defined via the <tt>define-record-type</tt> form or
the <tt>make-record-type-descriptor</tt> procedure.

<p>

<h3><a name="g139"></a><a name="./records:h1"></a>Section 9.1. Defining Records<a name="SECTRECORDDEFINITION"></a></h3>



<p>
A <tt>define-record-type</tt> form defines a record type and, along with it,
a constructor procedure for
records of the type, a type predicate that returns true only for
records of the type, an access procedure for each field, and an
assignment procedure for each mutable field.  For example, the
definition

<p>

<p><tt>(define-record-type&nbsp;point&nbsp;(fields&nbsp;x&nbsp;y))</tt>
<p>creates a <tt>point</tt> record type with two fields, <tt>x</tt>
and <tt>y</tt>, and defines the following procedures:

<p>
<TABLE><TR><TD nowrap align="left">
<tt>(make-point&nbsp;<i>x</i>&nbsp;<i>y</i>)</tt> </TD><TD nowrap align="left"> constructor</TD></TR><TR><TD nowrap align="left">
<tt>(point?&nbsp;<i>obj</i>)</tt> </TD><TD nowrap align="left"> predicate</TD></TR><TR><TD nowrap align="left">
<tt>(point-x&nbsp;<i>p</i>)</tt> </TD><TD nowrap align="left"> accessor for field <tt>x</tt></TD></TR><TR><TD nowrap align="left">
<tt>(point-y&nbsp;<i>p</i>)</tt> </TD><TD nowrap align="left"> accessor for field <tt>y</tt>
</TD></TR></TABLE>

<p>
With this definition in place, we can use these procedures to create
and manipulate records of the <tt>point</tt> type, as illustrated below.

<p>

<p><tt>(define&nbsp;p&nbsp;(make-point&nbsp;36&nbsp;-17))<br>

(point?&nbsp;p)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(point?&nbsp;'(cons&nbsp;36&nbsp;-17))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(point-x&nbsp;p)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;36<br>

(point-y&nbsp;p)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;-17</tt>
<p>Fields are immutable by default, but may be declared mutable.
In the alternate definition of <tt>point</tt> below, the <tt>x</tt>
field is mutable while <tt>y</tt> remains immutable.

<p>

<p><tt>(define-record-type&nbsp;point&nbsp;(fields&nbsp;(mutable&nbsp;x)&nbsp;y))</tt>
<p>In this case, <tt>define-record-type</tt> defines a mutator for
the <tt>x</tt> field in addition to the other products shown
above.

<p>
<TABLE><TR><TD nowrap align="left">
<tt>(point-x-set!&nbsp;<i>p</i>&nbsp;<i>x</i>)</tt> </TD><TD nowrap align="left"> mutator for field <tt>x</tt>
</TD></TR></TABLE>

<p>
The mutator can be used to change the contents of the <tt>x</tt> field.

<p>

<p><tt>(define&nbsp;p&nbsp;(make-point&nbsp;36&nbsp;-17))<br>

(point-x-set!&nbsp;p&nbsp;(-&nbsp;(point-x&nbsp;p)&nbsp;12))<br>

(point-x&nbsp;p)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;24</tt>
<p>A field may be declared immutable explicitly for clarity; the definition of
<tt>point</tt> below is equivalent to the second definition 
above.

<p>

<p><tt>(define-record-type&nbsp;point&nbsp;(fields&nbsp;(mutable&nbsp;x)&nbsp;(immutable&nbsp;y)))</tt>
<p>The names of the procedures defined by <tt>define-record-type</tt> follow
the regular naming convention illustrated by the examples above, by
default, but the programmer can override the defaults if desired.
With the following definition of <tt>point</tt>, the constructor is
<tt>mkpoint</tt>, the predicate is <tt>ispoint?</tt>, and the accessors
for <tt>x</tt> and <tt>y</tt> are <tt>x-val</tt> and <tt>y-val</tt>.
The mutator for <tt>x</tt> is <tt>set-x-val!</tt>.

<p>

<p><tt>(define-record-type&nbsp;(point&nbsp;mkpoint&nbsp;ispoint?)<br>

&nbsp;&nbsp;(fields&nbsp;(mutable&nbsp;x&nbsp;x-val&nbsp;set-x-val!)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(immutable&nbsp;y&nbsp;y-val)))</tt>
<p>By default, a record definition creates a new type each time it is
evaluated, as illustrated by the example below.

<p>

<p><tt>(define&nbsp;(f&nbsp;p)<br>

&nbsp;&nbsp;(define-record-type&nbsp;point&nbsp;(fields&nbsp;x&nbsp;y))<br>

&nbsp;&nbsp;(if&nbsp;(eq?&nbsp;p&nbsp;'make)&nbsp;(make-point&nbsp;3&nbsp;4)&nbsp;(point?&nbsp;p)))<br>

(f&nbsp;(f&nbsp;'make))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f</tt>
<p>The first (inner) call to <tt>f</tt> returns a point <tt><i>p</i></tt>, which is
passed to <tt>f</tt> in the second (outer) call, which applies
<tt>point?</tt> to <tt><i>p</i></tt>.
This <tt>point?</tt> is looking for points of the type created
by the second call, while <tt><i>p</i></tt> is a point of the type created by
the first call.
So <tt>point?</tt> returns <tt>#f</tt>.

<p>
<a name="./records:s3"></a><a name="./records:s4"></a><a name="./records:s5"></a>This default <i>generative</i> behavior may be overridden by including a
<tt>nongenerative</tt> clause in the record definition.

<p>

<p><tt>(define&nbsp;(f&nbsp;p)<br>

&nbsp;&nbsp;(define-record-type&nbsp;point&nbsp;(fields&nbsp;x&nbsp;y)&nbsp;(nongenerative))<br>

&nbsp;&nbsp;(if&nbsp;(eq?&nbsp;p&nbsp;'make)&nbsp;(make-point&nbsp;3&nbsp;4)&nbsp;(point?&nbsp;p)))<br>

(define&nbsp;p&nbsp;(f&nbsp;'make))<br>

(f&nbsp;p)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t</tt>
<p>Record types created in this manner are still distinct from record
types created by a definition appearing in a different part of the
program, even if the definitions are syntactically identical:

<p>

<p><tt>(define&nbsp;(f)<br>

&nbsp;&nbsp;(define-record-type&nbsp;point&nbsp;(fields&nbsp;x&nbsp;y)&nbsp;(nongenerative))<br>

&nbsp;&nbsp;(make-point&nbsp;3&nbsp;4))<br>

(define&nbsp;(g&nbsp;p)<br>

&nbsp;&nbsp;(define-record-type&nbsp;point&nbsp;(fields&nbsp;x&nbsp;y)&nbsp;(nongenerative))<br>

&nbsp;&nbsp;(point?&nbsp;p))<br>

(g&nbsp;(f))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f</tt>
<p><a name="./records:s6"></a><a name="page:record-uid"></a>Even this can be overridden by including a uid (unique id) in
the <tt>nongenerative</tt> clause:

<p>

<p><tt>(define&nbsp;(f)<br>

&nbsp;&nbsp;(define-record-type&nbsp;point&nbsp;(fields&nbsp;x&nbsp;y)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(nongenerative&nbsp;really-the-same-point))<br>

&nbsp;&nbsp;(make-point&nbsp;3&nbsp;4))<br>

(define&nbsp;(g&nbsp;p)<br>

&nbsp;&nbsp;(define-record-type&nbsp;point&nbsp;(fields&nbsp;x&nbsp;y)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(nongenerative&nbsp;really-the-same-point))<br>

&nbsp;&nbsp;(point?&nbsp;p))<br>

(g&nbsp;(f))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t</tt>
<p>The uid may be any identifier, but programmers are encouraged to select
uids from the RFC&nbsp;4122 UUID namespace&nbsp;[<a class=citation href="./bibliography.html#g238">20</a>], possibly with the
record-type name as a prefix.

<p>
<a name="./records:s7"></a><a name="./records:s8"></a><a name="./records:s9"></a><a name="./records:s10"></a><a name="page:parent-type"></a>A record type may be defined as a subtype of an existing "parent" type
with a <tt>parent</tt> clause that declares the name of the existing
record type.
If a parent is specified, the new "child" record type inherits the
parent record's fields, and each instance of the child type is considered
to be an instance of the parent type, so that accessors and mutators for
the parent type may be used on instances of the child type.

<p>

<p><tt>(define-record-type&nbsp;point&nbsp;(fields&nbsp;x&nbsp;y))<br>

(define-record-type&nbsp;cpoint&nbsp;(parent&nbsp;point)&nbsp;(fields&nbsp;color))</tt>
<p>The child type has all of the fields of the parent type, plus the additional
fields declared in the child's definition.
This is reflected in the constructor for <tt>cpoint</tt>, which now
takes three arguments, with the parent arguments followed by the
child argument.

<p>

<p><tt>(define&nbsp;cp&nbsp;(make-cpoint&nbsp;3&nbsp;4&nbsp;'red))</tt>
<p>A record of the child type is considered a record of the parent type, but
a record of the parent type is not a record of the new type.

<p>

<p><tt>(point?&nbsp;(make-cpoint&nbsp;3&nbsp;4&nbsp;'red))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(cpoint?&nbsp;(make-point&nbsp;3&nbsp;4))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f</tt>
<p>Only one new accessor is created for <tt>cpoint</tt>, the one for the
new field <tt>color</tt>.
The existing accessors and mutators for the parent type may be used to
access and modify the parent fields of the child type.

<p>

<p><tt>(define&nbsp;cp&nbsp;(make-cpoint&nbsp;3&nbsp;4&nbsp;'red))<br>

(point-x&nbsp;cp)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;3<br>

(point-y&nbsp;cp)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;4<br>

(cpoint-color&nbsp;cp)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;red</tt>
<p><a name="./records:s11"></a><a name="page:protocols"></a>As the examples given so far illustrate,
the default constructor defined by <tt>define-record-type</tt>
accepts as many arguments as the record has fields, including parent
fields, and parent's parent fields, and so on.
The programmer may override the default and specify the arguments to the
constructor for the new type and how it determines the initial values of
the constructed record's fields, via the <tt>protocol</tt> clause.
The following definition creates a <tt>point</tt> record with three
fields: <tt>x</tt>, <tt>y</tt>, and <tt>d</tt>, where <tt>d</tt>
represents the displacement from the origin.
The constructor still takes only two arguments, the <tt>x</tt> and
<tt>y</tt> values, and initializes <tt>d</tt> to the square root
of the sum of the squares of <tt>x</tt> and <tt>y</tt>.

<p>

<p><tt>(define-record-type&nbsp;point<br>

&nbsp;&nbsp;(fields&nbsp;x&nbsp;y&nbsp;d)<br>

&nbsp;&nbsp;(protocol<br>

&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(new)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(x&nbsp;y)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(new&nbsp;x&nbsp;y&nbsp;(sqrt&nbsp;(+&nbsp;(*&nbsp;x&nbsp;x)&nbsp;(*&nbsp;y&nbsp;y))))))))
<br>
<br>
(define&nbsp;p&nbsp;(make-point&nbsp;3&nbsp;4))<br>

(point-x&nbsp;p)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;3<br>

(point-y&nbsp;p)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;4<br>

(point-d&nbsp;p)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;5</tt>
<p>The procedure value of the expression within the <tt>protocol</tt> clause
receives as an argument a primitive
constructor <tt><i>new</i></tt> and returns a final constructor <tt><i>c</i></tt>.
There are essentially no limits on what <tt><i>c</i></tt> is allowed to do, but if
it returns, it should return the result of calling <tt><i>new</i></tt>.
Before it does so, it may modify the new record instance (if the record type
has mutable fields), register it with some external handler,
print messages, etc.
In this case, <tt><i>c</i></tt> accepts two arguments, <tt><i>x</i></tt> and <tt><i>y</i></tt>, and
applies <tt><i>new</i></tt> to <tt><i>x</i></tt>, <tt><i>y</i></tt>, and the result of computing the
origin displacement based on <tt><i>x</i></tt> and <tt><i>y</i></tt>.

<p>
If a parent record is specified, the construction protocol becomes
more involved.
The following definition of <tt>cpoint</tt> assumes that <tt>point</tt>
has been defined as shown just above.

<p>

<p><tt>(define-record-type&nbsp;cpoint<br>

&nbsp;&nbsp;(parent&nbsp;point)<br>

&nbsp;&nbsp;(fields&nbsp;color)<br>

&nbsp;&nbsp;(protocol<br>

&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(pargs-&gt;new)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(c&nbsp;x&nbsp;y)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((pargs-&gt;new&nbsp;x&nbsp;y)&nbsp;c)))))
<br>
<br>
(define&nbsp;cp&nbsp;(make-cpoint&nbsp;'red&nbsp;3&nbsp;4))<br>

(point-x&nbsp;cp)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;3<br>

(point-y&nbsp;cp)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;4<br>

(point-d&nbsp;cp)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;5<br>

(cpoint-color&nbsp;cp)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;red</tt>
<p>Because a parent clause is present, the procedure value of the expression
within the <tt>protocol</tt> clause receives a procedure <tt><i>pargs</i>-&gt;<i>new</i></tt>
that, when applied to parent arguments, returns a <tt><i>new</i></tt> procedure.
The <tt><i>new</i></tt> procedure, when passed the values of the child fields,
returns the result of applying the parent protocol to an appropriate
<tt><i>new</i></tt> procedure of its own.
In this case, <tt><i>pargs</i>-&gt;<i>new</i></tt> is passed the values of the child
constructor's second and third arguments (the <tt><i>x</i></tt> and <tt><i>y</i></tt> values)
and the resulting <tt><i>new</i></tt> procedure is passed the value of the child
constructor's first argument (the color).
Thus, the protocol supplied in this example effectively reverses the
normal order of arguments in which the parent arguments come before the
child arguments, while arranging to pass along the arguments needed by the
parent protocol.

<p>
<a name="./records:s12"></a>The default protocol is equivalent to

<p>

<p><tt>(lambda&nbsp;(new)&nbsp;new)</tt>
<p>for record types with no parents, while for record types with parents,
the default protocol is equivalent to the following

<p>

<p><tt>(lambda&nbsp;(pargs-&gt;new)<br>

&nbsp;&nbsp;(lambda&nbsp;(<i>x<sub>1</sub></i>&nbsp;...&nbsp;<i>x<sub>n</sub></i>&nbsp;<i>y<sub>1</sub></i>&nbsp;...&nbsp;<i>y<sub>m</sub></i>)<br>

&nbsp;&nbsp;&nbsp;&nbsp;((pargs-&gt;new&nbsp;<i>x<sub>1</sub></i>&nbsp;...&nbsp;<i>x<sub>n</sub></i>)&nbsp;<i>y<sub>1</sub></i>&nbsp;...&nbsp;<i>y<sub>m</sub></i>)))</tt>
<p>where <tt><i>n</i></tt> is the number of parent (including grandparent, etc.) fields
and <tt><i>m</i></tt> is the number of child fields.

<p>
Use of the <tt>protocol</tt> clause insulates the child record definition
from some changes to the parent record type.
The parent definition may be modified to add or remove fields, or even
add, remove, or change a parent, yet the child protocol and constructor
need not change as long as the parent protocol does not change.

<p>
Additional details and options for <tt>define-record-type</tt> are given in
its formal description below.


<p>
<a name="./records:s13"></a><span class=formdef><b>syntax</b>: <tt>(define-record-type&nbsp;<i>record-name</i>&nbsp;<i>clause</i>&nbsp;...)</tt></span>
<br>
<span class=formdef><b>syntax</b>: <tt>(define-record-type&nbsp;(<i>record-name</i>&nbsp;<i>constructor</i>&nbsp;<i>pred</i>)&nbsp;<i>clause</i>&nbsp;...)</tt></span>
<br>
<b>libraries: </b><tt>(rnrs&nbsp;records&nbsp;syntactic)</tt>, <tt>(rnrs)</tt>

<p>A <tt>define-record-type</tt> form, or <i>record definition</i>, is a definition
and may appear anywhere other definitions may appear.
It defines a record
type identified by <tt><i>record-name</i></tt>, plus a predicate, constructor, accessors,
and mutators for the record type.
If the record definition takes the first form above, the names of the constructor
and predicate are derived from <tt><i>record-name</i></tt>: <tt>make-<i>record-name</i></tt>
for the constructor and <tt><i>record-name</i>?</tt> for the predicate.
If the record definition takes the second form above, the name of the constructor
is <tt><i>constructor</i></tt> and the name of the predicate is <tt><i>pred</i></tt>.
All names defined by a record definition are scoped where the record definition
appears.

<p>
The clauses <tt><i>clause</i>&nbsp;...</tt> of the record definition determine
the fields of the record type and the names of their accessors
and mutators; its parent type, if any; its construction protocol; whether
it is nongenerative and, if so, whether its uid is specified; whether
it is sealed; and whether it is opaque.
The syntax and impact of each clause is described below.

<p>
None of the clauses is required; thus, the simplest record definition is

<p>

<p><tt>(define-record-type&nbsp;<i>record-name</i>)</tt>
<p>which defines a new, generative, non-sealed, non-opaque record type with no parent
and no fields, plus a constructor of no arguments and a predicate.

<p>
At most one of each kind of clause may be present in the set of clauses, and
if a <tt>parent</tt> clause is present, a <tt>parent-rtd</tt> clause must not
be present.
The clauses that appear may appear in any order.


<p>
<p><b>Fields clause.</b>&nbsp;&nbsp;A <tt>(fields&nbsp;<i>field-spec</i>&nbsp;...)</tt> clause
declares the fields of the record type.
Each <tt><i>field-spec</i></tt> must take one of the following forms:

<p>

<p><tt><i>field-name</i><br>

(immmutable&nbsp;<i>field-name</i>)<br>

(mutable&nbsp;<i>field-name</i>)<br>

(immmutable&nbsp;<i>field-name</i>&nbsp;<i>accessor-name</i>)<br>

(mutable&nbsp;<i>field-name</i>&nbsp;<i>accessor-name</i>&nbsp;<i>mutator-name</i>)</tt>
<p>where <tt><i>field-name</i></tt>, <tt><i>accessor-name</i></tt>, and <tt><i>mutator-name</i></tt> are identifiers.
The first form, <tt><i>field-name</i></tt>, is equivalent to <tt>(immutable&nbsp;<i>field-name</i>)</tt>.
The value of a field declared immutable may not be changed, and no mutator is
created for it.
With the first three forms, the name of the accessor is
<tt><i>rname</i>-<i>fname</i></tt>, where <tt><i>rname</i></tt> is the record
name and <tt><i>fname</i></tt> is the field name.
With the third form, the name of the accessor is
<tt><i>rname</i>-<i>fname</i>-set!</tt>.
The fourth and fifth forms explicitly declare the accessor and mutator names.

<p>
If no <tt>fields</tt> clause is present or the list <tt><i>field-spec</i>&nbsp;...</tt>
is empty, the record type has no fields (other than parent fields, if any).


<p>
<p><b>Parent clause.</b>&nbsp;&nbsp;A <tt>(parent&nbsp;<i>parent-name</i>)</tt> clause declares the parent record type;
<tt><i>parent-name</i></tt> must be the name of a non-sealed record type previously
defined via <tt>define-record-type</tt>.
Instances of a record type are also considered instances of its parent record
type and have all the fields of its parent record type in addition to those
declared via the <tt>fields</tt> clause.

<p>
<p><b>Nongenerative clause.</b>&nbsp;&nbsp;A <tt>nongenerative</tt> clause may take one of two forms:

<p>

<p><tt>(nongenerative)<br>

(nongenerative&nbsp;<i>uid</i>)</tt>
<p>where <tt><i>uid</i></tt> is a symbol.
The first form is equivalent to the second, with a uid generated by the
implementation at macro-expansion time.
When a <tt>define-record-type</tt> form with a nongenerative clause is
evaluated, a new type is created if and only if the uid is not the uid
of an existing record type.

<p>
If it is the uid of an existing record type, the parent, field-names,
sealed property, and opaque property must match as follows.

<p>
<ul>
<li>If a parent is specified, the existing record type must have the same
parent rtd (by <tt>eqv?</tt>).
If a parent is not specified, the existing record type must not have
a parent.

<p>
<li>The same number of fields must be provided, with the same names and in
the same order, and the mutability of each field must be the same.

<p>
<li>If a <tt>(sealed&nbsp;#t)</tt> clause is present, the existing record type
must be sealed.
Otherwise, the existing record type must not be sealed.

<p>
<li>If an <tt>(opaque&nbsp;#t)</tt> clause is present, the existing record type
must be opaque.
Otherwise, the existing record type must be opaque if and only if
an opaque parent type is specified.
</ul>
<p>

<p>
If these constraints are met, no new record type is created, and the
other products of the record-type definition (constructor, predicate,
accessors, and mutators) operate on records of the existing type.
If these constraints are not met, the implementation may treat it as a
syntax violation, or it may raise a run-time exception with condition type
<tt>&amp;assertion</tt>.

<p>
With the first form of <tt>nongenerative</tt> clause, the generated
uid can be the uid of an existing record type only if the
same definition is executed multiple times, e.g., if it appears in
the body of a procedure that is invoked multiple times.

<p>
If <tt><i>uid</i></tt> is not the uid of an existing record type, or if no
<tt>nongenerative</tt> clause is present, a new record type is created.

<p>
<p><b>Protocol clause.</b>&nbsp;&nbsp;A <tt>(protocol&nbsp;<i>expression</i>)</tt> determines the protocol that
the generated constructor uses to construct instances of the record
type.
It must evaluate to a procedure, and this procedure should be an
appropriate protocol for the record type, as described on
page&nbsp;<a href="./records.html#page:protocols">326</a>.

<p>
<p><b>Sealed clause.</b>&nbsp;&nbsp;<a name="./records:s14"></a><a name="page:sealed"></a>A <tt>sealed</tt> clause of the form <tt>(sealed&nbsp;#t)</tt> declares that the
record type is <i>sealed</i>.
This means that it cannot be extended, i.e., cannot be used as the
parent for another record definition or <tt>make-record-type-descriptor</tt>
call.
If no <tt>sealed</tt> clause is present or if one of the form
<tt>(sealed&nbsp;#f)</tt> is present, the record type is not sealed.

<p>
<p><b>Opaque clause.</b>&nbsp;&nbsp;<a name="./records:s15"></a><a name="page:opaque"></a>An <tt>opaque</tt> clause of the form <tt>(opaque&nbsp;#t)</tt> declares that the
record type is <i>opaque</i>.
Instances of an opaque record type are not considered records by the
<tt>record?</tt> predicate or, more importantly, the rtd-extraction
procedure <tt>record-rtd</tt>, which are both described in
Section&nbsp;<a href="./records.html#g141">9.3</a>.
Thus, it is not possible for code that does not have access to the
<tt>record-name</tt>, accessors, or mutators to access or modify any
of the fields of an opaque record type.
A record type is also opaque if its parent is opaque.
If no <tt>opaque</tt> clause is present or if one of the form
<tt>(opaque&nbsp;#f)</tt> is present, and the parent, if any, is not
opaque, the record type is not opaque.

<p>
<p><b>Parent-rtd clause.</b>&nbsp;&nbsp;A <tt>(parent-rtd&nbsp;<i>parent-rtd</i>&nbsp;<i>parent-rcd</i>)</tt> clause is an alternative
to the <tt>parent</tt> clause for specifying the parent record type, along
with a parent record constructor descriptor.
It is primarily useful when the parent rtd and rcd were obtained via calls to
<tt>make-record-type-descriptor</tt> and <tt>make-record-constructor-descriptor</tt>.

<p>
<tt><i>parent-rtd</i></tt> must evaluate to an rtd or <tt>#f</tt>.
If <tt><i>parent-rtd</i></tt> evaluates to <tt>#f</tt>, <tt><i>parent-rcd</i></tt> must
also evaluate to <tt>#f</tt>.
Otherwise, <tt><i>parent-rcd</i></tt> must evaluate to an rcd or <tt>#f</tt>.
If <tt><i>parent-rcd</i></tt> evaluates to an rcd, it must encapsulate an rtd
equivalent (by <tt>eqv?</tt>) to the value of <tt><i>parent-rtd</i></tt>.
If the value of <tt><i>parent-rcd</i></tt> is <tt>#f</tt>, it is treated as an rcd
for the value of <tt><i>parent-rtd</i></tt> with a default protocol.

<p>
The <tt>define-record-type</tt> form is designed in such a way that it is
normally possible for a compiler to determine the shapes of the record
types it defines, including the offsets for all fields.
This guarantee does not hold, however, when the <tt>parent-rtd</tt> clause
is used, since the parent rtd might not be determinable until run time.
Thus, the <tt>parent</tt> clause is preferred over the <tt>parent-rtd</tt>
clause whenever the <tt>parent</tt> clause suffices.


<p>
<a name="./records:s16"></a><span class=formdef><b>syntax</b>: <tt>fields</tt></span>
<br>
<span class=formdef><b>syntax</b>: <tt>mutable</tt></span>
<br>
<span class=formdef><b>syntax</b>: <tt>immutable</tt></span>
<br>
<span class=formdef><b>syntax</b>: <tt>parent</tt></span>
<br>
<span class=formdef><b>syntax</b>: <tt>protocol</tt></span>
<br>
<span class=formdef><b>syntax</b>: <tt>sealed</tt></span>
<br>
<span class=formdef><b>syntax</b>: <tt>opaque</tt></span>
<br>
<span class=formdef><b>syntax</b>: <tt>nongenerative</tt></span>
<br>
<span class=formdef><b>syntax</b>: <tt>parent-rtd</tt></span>
<br>
<b>libraries: </b><tt>(rnrs&nbsp;records&nbsp;syntactic)</tt>, <tt>(rnrs)</tt>

<p>These identifiers are auxiliary keywords for <tt>define-record-type</tt>.
It is a syntax violation to reference these identifiers except in
contexts where they are recognized as auxiliary keywords.


<p>

<h3><a name="g140"></a><a name="./records:h2"></a>Section 9.2. Procedural Interface<a name="SECTRECORDPROCEDURAL"></a></h3>



<p>
<a name="./records:s17"></a><a name="./records:s18"></a><a name="./records:s19"></a>The procedural (<tt>make-record-type-descriptor</tt>) interface may also be
used to create new record types.
The procedural interface is more flexible than the syntactic interface,
but this flexibility can lead to less readable and efficient programs, so
programmers should use the syntactic interface whenever it suffices.


<p>
<a name="./records:s20"></a><span class=formdef><b>procedure</b>: <tt>(make-record-type-descriptor&nbsp;<i>name</i>&nbsp;<i>parent</i>&nbsp;<i>uid</i>&nbsp;<i>s?</i>&nbsp;<i>o?</i>&nbsp;<i>fields</i>)</tt></span>
<br>
<b>returns: </b>a record-type descriptor (rtd) for a new or existing record type
<br>
<b>libraries: </b><tt>(rnrs&nbsp;records&nbsp;procedural)</tt>, <tt>(rnrs)</tt>

<p><a name="./records:s21"></a><a name="./records:s22"></a><tt><i>name</i></tt> must be a symbol, <tt><i>parent</i></tt> must be <tt>#f</tt> or the
rtd of a non-sealed record type, <tt><i>uid</i></tt> must be <tt>#f</tt> or
a symbol, and <tt><i>fields</i></tt> must be a vector, each element of which
is a two-element list of the form <tt>(mutable&nbsp;<i>field-name</i>)</tt>
or <tt>(immutable&nbsp;<i>field-name</i>)</tt>.
The field names <tt><i>field-name</i>&nbsp;...</tt> must be symbols and need
not be distinct from each other.

<p>
If <tt><i>uid</i></tt> is <tt>#f</tt> or is not the uid of an existing record
type, this procedure creates a new record type and returns a record-type
descriptor (rtd) for the new type. 
The type has the parent type (page&nbsp;<a href="./records.html#page:parent-type">325</a>) described by
<tt><i>parent</i></tt>, if nonfalse; the uid specified by <tt><i>uid</i></tt>, if nonfalse;
and the fields specified by <tt><i>fields</i></tt>.
It is sealed (page&nbsp;<a href="./records.html#page:sealed">330</a>) if <tt><i>s?</i></tt> is nonfalse.
It is opaque (page&nbsp;<a href="./records.html#page:opaque">330</a>) if <tt><i>opaque</i></tt> is nonfalse or
the parent (if specified) is opaque.
The name of the new record type is <tt><i>name</i></tt> and the names of the fields are
<tt><i>field-name</i>&nbsp;...</tt>.

<p>
If <tt><i>uid</i></tt> is nonfalse and is the uid (page&nbsp;<a href="./records.html#page:record-uid">325</a>)
of an existing record type, the <tt><i>parent</i></tt>, <tt><i>fields</i></tt>, <tt><i>s?</i></tt>,
and <tt><i>o?</i></tt> arguments must match the corresponding characteristics
of the existing record type.
That is, <tt><i>parent</i></tt> must be the same (by <tt>eqv?</tt>); the number
of fields must be the same; the fields must
have the same names, be in the same order, and have the same mutability;
<tt><i>s?</i></tt> must be false if and only
if the existing record type is sealed; and, if a parent is not specified
or is not opaque, <tt><i>o?</i></tt> must be false if and only if the existing
record type is opaque.
If this is the case, <tt>make-record-type-descriptor</tt>
returns the rtd for the existing record type.
Otherwise, an exception with condition type <tt>&amp;assertion</tt> is raised.

<p>
Using the rtd returned by <tt>make-record-type-descriptor</tt>, programs
can generate constructors,
type predicates, field accessors, and field mutators dynamically.
The following code demonstrates how the procedural interface might
be used to create a <tt>point</tt> record type and associated
definitions similar to those of the second <tt>point</tt> record
definition in Section&nbsp;<a href="./records.html#g139">9.1</a>, with a mutable
<tt>x</tt> field and an immutable <tt>y</tt> field.

<p>

<p><tt>(define&nbsp;point-rtd&nbsp;(make-record-type-descriptor&nbsp;'point&nbsp;#f&nbsp;#f&nbsp;#f&nbsp;#f<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'#((mutable&nbsp;x)&nbsp;(immutable&nbsp;y))))<br>

(define&nbsp;point-rcd&nbsp;(make-record-constructor-descriptor&nbsp;point-rtd<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#f&nbsp;#f))<br>

(define&nbsp;make-point&nbsp;(record-constructor&nbsp;point-rcd))<br>

(define&nbsp;point?&nbsp;(record-predicate&nbsp;point-rtd))<br>

(define&nbsp;point-x&nbsp;(record-accessor&nbsp;point-rtd&nbsp;0))<br>

(define&nbsp;point-y&nbsp;(record-accessor&nbsp;point-rtd&nbsp;1))<br>

(define&nbsp;point-x-set!&nbsp;(record-mutator&nbsp;point-rtd&nbsp;0))</tt>
<p>See the additional examples given at the end of this section.


<p>
<a name="./records:s23"></a><span class=formdef><b>procedure</b>: <tt>(record-type-descriptor?&nbsp;<i>obj</i>)</tt></span>
<br>
<b>returns: </b><tt>#f</tt> if <tt><i>obj</i></tt> is a record-type descriptor, otherwise <tt>#f</tt>
<br>
<b>libraries: </b><tt>(rnrs&nbsp;records&nbsp;procedural)</tt>, <tt>(rnrs)</tt>

<p>See the examples given at the end of this section.


<p>
<a name="./records:s24"></a><span class=formdef><b>procedure</b>: <tt>(make-record-constructor-descriptor&nbsp;<i>rtd</i>&nbsp;<i>parent-rcd</i>&nbsp;<i>protocol</i>)</tt></span>
<br>
<b>returns: </b>a record-constructor descriptor (rcd)
<br>
<b>libraries: </b><tt>(rnrs&nbsp;records&nbsp;procedural)</tt>, <tt>(rnrs)</tt>

<p><a name="./records:s25"></a><a name="./records:s26"></a><a name="./records:s27"></a>An rtd alone is sufficient to create predicates, accessors, and mutators.
To create a constructor, however, it is first necessary to create a record-constructor
descriptor (rcd) for the record type.
An rcd encapsulates three pieces of information: the rtd of the record type
for which the rcd has been created, the parent rcd (if any), and the
protocol.

<p>
The <tt><i>parent-rcd</i></tt> argument must be an rcd or <tt>#f</tt>.
If it is an rcd, <tt><i>rtd</i></tt> must have a parent rtd, and the parent rtd must be
the same as the rtd encapsulated within <tt><i>parent-rcd</i></tt>.
If <tt><i>parent-rcd</i></tt> is false, either <tt><i>rtd</i></tt> has no parent or an rcd with a default
protocol is assumed for the parent.

<p>
The <tt><i>protocol</i></tt> argument must be a procedure or <tt>#f</tt>.
If it is <tt>#f</tt>, a default protocol is assumed.
Protocols are discussed on page&nbsp;<a href="./records.html#page:protocols">326</a>.

<p>
See the examples given at the end of this section.


<p>
<a name="./records:s28"></a><span class=formdef><b>syntax</b>: <tt>(record-type-descriptor&nbsp;<i>record-name</i>)</tt></span>
<br>
<b>returns: </b>the rtd for the record type identified by <tt>record-name</tt>
<br>
<span class=formdef><b>syntax</b>: <tt>(record-constructor-descriptor&nbsp;<i>record-name</i>)</tt></span>
<br>
<b>returns: </b>the rcd for the record type identified by <tt>record-name</tt>
<br>
<b>libraries: </b><tt>(rnrs&nbsp;records&nbsp;syntactic)</tt>, <tt>(rnrs)</tt>

<p>Each record definition creates, behind the scenes, an rtd and rcd for the
defined record type.
These procedures allow the rtd and rcd to be obtained and used like any
other rtd or rcd.
<tt><i>record-name</i></tt> must be the name of a record previously defined via
<tt>define-record-type</tt>.


<p>
<a name="./records:s29"></a><span class=formdef><b>procedure</b>: <tt>(record-constructor&nbsp;<i>rcd</i>)</tt></span>
<br>
<b>returns: </b>a record constructor for the record type encapsulated within <tt><i>rcd</i></tt>
<br>
<b>libraries: </b><tt>(rnrs&nbsp;records&nbsp;procedural)</tt>, <tt>(rnrs)</tt>

<p>The behavior of the record constructor is determined by the protocol
and parent rcd (if any) also encapsulated within <tt><i>rcd</i></tt>.

<p>
See the examples given at the end of this section.


<p>
<a name="./records:s30"></a><span class=formdef><b>procedure</b>: <tt>(record-predicate&nbsp;<i>rtd</i>)</tt></span>
<br>
<b>returns: </b>a predicate for <tt><i>rtd</i></tt>
<br>
<b>libraries: </b><tt>(rnrs&nbsp;records&nbsp;procedural)</tt>, <tt>(rnrs)</tt>

<p>This procedure returns a predicate that accepts one argument and returns
<tt>#t</tt> if the argument is an instance of the record-type described by
<tt><i>rtd</i></tt>, <tt>#f</tt> otherwise.

<p>
See the examples given at the end of this section.


<p>
<a name="./records:s31"></a><span class=formdef><b>procedure</b>: <tt>(record-accessor&nbsp;<i>rtd</i>&nbsp;<i>idx</i>)</tt></span>
<br>
<b>returns: </b>an accessor for the field of <tt><i>rtd</i></tt> specified by <tt><i>idx</i></tt>
<br>
<b>libraries: </b><tt>(rnrs&nbsp;records&nbsp;procedural)</tt>, <tt>(rnrs)</tt>

<p><tt><i>idx</i></tt> must be a nonnegative integer less than the number of fields of
<tt><i>rtd</i></tt>, not counting parent fields.
An <tt><i>idx</i></tt> value of 0 specifies the first field given in the
<tt>define-record-type</tt> form or <tt>make-record-type-descriptor</tt>
call that created the record type, 1 specifies the second, and so on.

<p>
A child rtd cannot be used directly to create accessors for parent fields.
To create an accessor for a parent field, the record-type descriptor of
the parent must be used instead.

<p>
See the examples given at the end of this section.


<p>
<a name="./records:s32"></a><span class=formdef><b>procedure</b>: <tt>(record-mutator&nbsp;<i>rtd</i>&nbsp;<i>idx</i>)</tt></span>
<br>
<b>returns: </b>a mutator for the field of <tt><i>rtd</i></tt> specified by <tt><i>idx</i></tt>
<br>
<b>libraries: </b><tt>(rnrs&nbsp;records&nbsp;procedural)</tt>, <tt>(rnrs)</tt>

<p><tt><i>idx</i></tt> must be a nonnegative integer less than the number of fields of
<tt><i>rtd</i></tt>, not counting parent fields.
An <tt><i>idx</i></tt> value of 0 specifies the first field given in the
<tt>define-record-type</tt> form or <tt>make-record-type-descriptor</tt>
call that created the record type, 1 specifies the second, and so on.
The indicated field must be mutable; otherwise, an exception with condition
type <tt>&amp;assertion</tt> is raised.

<p>
A child rtd cannot be used directly to create mutators for parent fields.
To create a mutator for a parent field, the record-type descriptor of
the parent must be used instead.


<p>
<p>The following example illustrates the creation of parent and child record
types, predicates, accessors, mutators, and constructors using the procedures
described in this section.

<p>

<p><tt>(define&nbsp;rtd/parent<br>

&nbsp;&nbsp;(make-record-type-descriptor&nbsp;'parent&nbsp;#f&nbsp;#f&nbsp;#f&nbsp;#f<br>

&nbsp;&nbsp;&nbsp;&nbsp;'#((mutable&nbsp;x))))
<br>
<br>
(record-type-descriptor?&nbsp;rtd/parent)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(define&nbsp;parent?&nbsp;(record-predicate&nbsp;rtd/parent))<br>

(define&nbsp;parent-x&nbsp;(record-accessor&nbsp;rtd/parent&nbsp;0))<br>

(define&nbsp;set-parent-x!&nbsp;(record-mutator&nbsp;rtd/parent&nbsp;0))
<br>
<br>
(define&nbsp;rtd/child<br>

&nbsp;&nbsp;(make-record-type-descriptor&nbsp;'child&nbsp;rtd/parent&nbsp;#f&nbsp;#f&nbsp;#f<br>

&nbsp;&nbsp;&nbsp;&nbsp;'#((mutable&nbsp;x)&nbsp;(immutable&nbsp;y))))
<br>
<br>
(define&nbsp;child?&nbsp;(record-predicate&nbsp;rtd/child))<br>

(define&nbsp;child-x&nbsp;(record-accessor&nbsp;rtd/child&nbsp;0))<br>

(define&nbsp;set-child-x!&nbsp;(record-mutator&nbsp;rtd/child&nbsp;0))<br>

(define&nbsp;child-y&nbsp;(record-accessor&nbsp;rtd/child&nbsp;1))
<br>
<br>
(record-mutator&nbsp;rtd/child&nbsp;1)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;<i>exception:&nbsp;immutable&nbsp;field</i>
<br>
<br>
(define&nbsp;rcd/parent<br>

&nbsp;&nbsp;(make-record-constructor-descriptor&nbsp;rtd/parent&nbsp;#f<br>

&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(new)&nbsp;(lambda&nbsp;(x)&nbsp;(new&nbsp;(*&nbsp;x&nbsp;x))))))
<br>
<br>
(record-type-descriptor?&nbsp;rcd/parent)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f
<br>
<br>
(define&nbsp;make-parent&nbsp;(record-constructor&nbsp;rcd/parent))
<br>
<br>
(define&nbsp;p&nbsp;(make-parent&nbsp;10))<br>

(parent?&nbsp;p)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(parent-x&nbsp;p)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;100<br>

(set-parent-x!&nbsp;p&nbsp;150)<br>

(parent-x&nbsp;p)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;150
<br>
<br>
(define&nbsp;rcd/child<br>

&nbsp;&nbsp;(make-record-constructor-descriptor&nbsp;rtd/child&nbsp;rcd/parent<br>

&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(pargs-&gt;new)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(x&nbsp;y)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((pargs-&gt;new&nbsp;x)&nbsp;(+&nbsp;x&nbsp;5)&nbsp;y)))))
<br>
<br>
(define&nbsp;make-child&nbsp;(record-constructor&nbsp;rcd/child))<br>

(define&nbsp;c&nbsp;(make-child&nbsp;10&nbsp;'cc))<br>

(parent?&nbsp;c)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(child?&nbsp;c)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(child?&nbsp;p)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f
<br>
<br>
(parent-x&nbsp;c)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;100<br>

(child-x&nbsp;c)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;15<br>

(child-y&nbsp;c)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;cc
<br>
<br>
(child-x&nbsp;p)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;<i>exception:&nbsp;invalid&nbsp;argument&nbsp;type</i></tt>
<p>
<h3><a name="g141"></a><a name="./records:h3"></a>Section 9.3. Inspection<a name="SECTRECORDINSPECTION"></a></h3>



<p>
This section describes various procedures for asking questions about
or extracting information from record-type descriptors (rtds).
It also describes the <tt>record-rtd</tt> procedure, with which the
rtd of a non-opaque record instance may be extracted, allowing the record
type of the instance to be inspected and, via record accessors and
mutators generated from the rtd, the record itself to be inspected
or modified.
This is a powerful feature that permits the coding of portable record
printers and inspectors.

<p>
<a name="./records:s33"></a>The record-type descriptor cannot be extracted from an instance of an
opaque record type; this is the feature that distinguishes opaque
from non-opaque record types.


<p>
<a name="./records:s34"></a><span class=formdef><b>procedure</b>: <tt>(record-type-name&nbsp;<i>rtd</i>)</tt></span>
<br>
<b>returns: </b>the name associated with <tt><i>rtd</i></tt>
<br>
<b>libraries: </b><tt>(rnrs&nbsp;records&nbsp;inspection)</tt>, <tt>(rnrs)</tt>

<p>
<p><tt>
(define&nbsp;record-&gt;name<br>

&nbsp;&nbsp;(lambda&nbsp;(x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(and&nbsp;(record?&nbsp;x)&nbsp;(record-type-name&nbsp;(record-rtd&nbsp;x)))))
<br>
<br>
(define-record-type&nbsp;dim&nbsp;(fields&nbsp;w&nbsp;l&nbsp;h))<br>

(record-&gt;name&nbsp;(make-dim&nbsp;10&nbsp;15&nbsp;6))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;dim
<br>
<br>
(define-record-type&nbsp;dim&nbsp;(fields&nbsp;w&nbsp;l&nbsp;h)&nbsp;(opaque&nbsp;#t))<br>

(record-&gt;name&nbsp;(make-dim&nbsp;10&nbsp;15&nbsp;6))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f</tt>
<p><a name="./records:s35"></a><span class=formdef><b>procedure</b>: <tt>(record-type-parent&nbsp;<i>rtd</i>)</tt></span>
<br>
<b>returns: </b>the parent of <tt><i>rtd</i></tt>, or <tt>#f</tt> if it has no parent
<br>
<b>libraries: </b><tt>(rnrs&nbsp;records&nbsp;inspection)</tt>, <tt>(rnrs)</tt>

<p>
<p><tt>
(define-record-type&nbsp;point&nbsp;(fields&nbsp;x&nbsp;y))<br>

(define-record-type&nbsp;cpoint&nbsp;(parent&nbsp;point)&nbsp;(fields&nbsp;color))<br>

(record-type-parent&nbsp;(record-type-descriptor&nbsp;point))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(record-type-parent&nbsp;(record-type-descriptor&nbsp;cpoint))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#&lt;rtd&gt;</tt>
<p><a name="./records:s36"></a><span class=formdef><b>procedure</b>: <tt>(record-type-uid&nbsp;<i>rtd</i>)</tt></span>
<br>
<b>returns: </b>the uid of <tt><i>rtd</i></tt>, or <tt>#f</tt> if it has no uid
<br>
<b>libraries: </b><tt>(rnrs&nbsp;records&nbsp;inspection)</tt>, <tt>(rnrs)</tt>

<p>Whether a record type created without a programmer-supplied uid
actually has one anyway is left up to the implementation, so this
procedure is never guaranteed to return <tt>#f</tt>.

<p>

<p><tt>(define-record-type&nbsp;point&nbsp;(fields&nbsp;x&nbsp;y))<br>

(define-record-type&nbsp;cpoint<br>

&nbsp;&nbsp;(parent&nbsp;point)<br>

&nbsp;&nbsp;(fields&nbsp;color)<br>

&nbsp;&nbsp;(nongenerative&nbsp;e40cc926-8cf4-4559-a47c-cac636630314))<br>

(record-type-uid&nbsp;(record-type-descriptor&nbsp;point))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;<i>unspecified</i><br>

(record-type-uid&nbsp;(record-type-descriptor&nbsp;cpoint))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>"><br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;e40cc926-8cf4-4559-a47c-cac636630314</tt>
<p><a name="./records:s37"></a><span class=formdef><b>procedure</b>: <tt>(record-type-generative?&nbsp;<i>rtd</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if the record type described by <tt><i>rtd</i></tt> is generative, <tt>#f</tt> otherwise
<br>
<span class=formdef><b>procedure</b>: <tt>(record-type-sealed?&nbsp;<i>rtd</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if the record type described by <tt><i>rtd</i></tt> is sealed, <tt>#f</tt> otherwise
<br>
<span class=formdef><b>procedure</b>: <tt>(record-type-opaque?&nbsp;<i>rtd</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if the record type described by <tt><i>rtd</i></tt> is opaque, <tt>#f</tt> otherwise
<br>
<b>libraries: </b><tt>(rnrs&nbsp;records&nbsp;inspection)</tt>, <tt>(rnrs)</tt>

<p>
<p><tt>
(define-record-type&nbsp;table<br>

&nbsp;&nbsp;(fields&nbsp;keys&nbsp;vals)<br>

&nbsp;&nbsp;(opaque&nbsp;#t))<br>

(define&nbsp;rtd&nbsp;(record-type-descriptor&nbsp;table))<br>

(record-type-generative?&nbsp;rtd)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(record-type-sealed?&nbsp;rtd)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(record-type-opaque?&nbsp;rtd)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t
<br>
<br>
(define-record-type&nbsp;cache-table<br>

&nbsp;&nbsp;(parent&nbsp;table)<br>

&nbsp;&nbsp;(fields&nbsp;key&nbsp;val)<br>

&nbsp;&nbsp;(nongenerative))<br>

(define&nbsp;rtd&nbsp;(record-type-descriptor&nbsp;cache-table))<br>

(record-type-generative?&nbsp;rtd)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(record-type-sealed?&nbsp;rtd)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(record-type-opaque?&nbsp;rtd)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t</tt>
<p><a name="./records:s38"></a><span class=formdef><b>procedure</b>: <tt>(record-type-field-names&nbsp;<i>rtd</i>)</tt></span>
<br>
<b>returns: </b>a vector containing the names of the fields of the type described by <tt><i>rtd</i></tt>
<br>
<b>libraries: </b><tt>(rnrs&nbsp;records&nbsp;inspection)</tt>, <tt>(rnrs)</tt>

<p>The vector returned by this procedure is immutable: the effect on <tt><i>rtd</i></tt>
of modifying it is unspecified.
The vector does not include parent field names.
The order of the names in the vector is the same as the order in which the
fields were specified in the <tt>define-record-type</tt> form or
<tt>make-record-type-descriptor</tt> call that created the record type.

<p>

<p><tt>(define-record-type&nbsp;point&nbsp;(fields&nbsp;x&nbsp;y))<br>

(define-record-type&nbsp;cpoint&nbsp;(parent&nbsp;point)&nbsp;(fields&nbsp;color))<br>

(record-type-field-names<br>

&nbsp;&nbsp;(record-type-descriptor&nbsp;point))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#(x&nbsp;y)<br>

(record-type-field-names<br>

&nbsp;&nbsp;(record-type-descriptor&nbsp;cpoint))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#(color)</tt>
<p><a name="./records:s39"></a><span class=formdef><b>procedure</b>: <tt>(record-field-mutable?&nbsp;<i>rtd</i>&nbsp;<i>idx</i>)</tt></span>
<br>
<b>returns: </b><tt>#t&nbsp;if&nbsp;the&nbsp;specified&nbsp;field&nbsp;of&nbsp;<i>rtd</i></tt> is mutable, <tt>#f</tt> otherwise
<br>
<b>libraries: </b><tt>(rnrs&nbsp;records&nbsp;inspection)</tt>, <tt>(rnrs)</tt>

<p><tt><i>idx</i></tt> must be a nonnegative integer less than the number of fields of
<tt><i>rtd</i></tt>, not counting parent fields.
An <tt><i>idx</i></tt> value of 0 specifies the first field given in the
<tt>define-record-type</tt> form or <tt>make-record-type-descriptor</tt>
call that created the record type, 1 specifies the second, and so on.

<p>

<p><tt>(define-record-type&nbsp;point&nbsp;(fields&nbsp;(mutable&nbsp;x)&nbsp;(mutable&nbsp;y)))<br>

(define-record-type&nbsp;cpoint&nbsp;(parent&nbsp;point)&nbsp;(fields&nbsp;color))
<br>
<br>
(record-field-mutable?&nbsp;(record-type-descriptor&nbsp;point)&nbsp;0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(record-field-mutable?&nbsp;(record-type-descriptor&nbsp;cpoint)&nbsp;0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f</tt>
<p><a name="./records:s40"></a><span class=formdef><b>procedure</b>: <tt>(record?&nbsp;<i>obj</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if <tt><i>obj</i></tt> is a non-opaque record instance, <tt>#f</tt> otherwise
<br>
<b>libraries: </b><tt>(rnrs&nbsp;records&nbsp;inspection)</tt>, <tt>(rnrs)</tt>

<p>When passed an instance of an opaque record type, <tt>record?</tt> returns
<tt>#f</tt>.
While an instance of an opaque record type is, in essence, a record,
the point of opacity is to hide all representation information from the
parts of a program that should not have access to the information,
and this includes whether an object is a record.
Furthermore, the primary purpose of this predicate is to allow programs to
check whether it is possible to obtain from the argument an rtd via the
<tt>record-rtd</tt> procedure described below.

<p>

<p><tt>(define-record-type&nbsp;statement&nbsp;(fields&nbsp;str))<br>

(define&nbsp;q&nbsp;(make-statement&nbsp;"He's&nbsp;dead,&nbsp;Jim"))<br>

(statement?&nbsp;q)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(record?&nbsp;q)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t
<br>
<br>
(define-record-type&nbsp;opaque-statement&nbsp;(fields&nbsp;str)&nbsp;(opaque&nbsp;#t))<br>

(define&nbsp;q&nbsp;(make-opaque-statement&nbsp;"He's&nbsp;moved&nbsp;on,&nbsp;Jim"))<br>

(opaque-statement?&nbsp;q)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(record?&nbsp;q)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f</tt>
<p><a name="./records:s41"></a><span class=formdef><b>procedure</b>: <tt>(record-rtd&nbsp;<i>record</i>)</tt></span>
<br>
<b>returns: </b>the record-type descriptor (rtd) of <tt><i>record</i></tt>
<br>
<b>libraries: </b><tt>(rnrs&nbsp;records&nbsp;inspection)</tt>, <tt>(rnrs)</tt>

<p>The argument must be an instance of a non-opaque record type.
In combination with some of the other procedures described in this
section and Section&nbsp;<a href="./records.html#g140">9.2</a>,
<tt>record-rtd</tt> allows the inspection or mutation
of record instances, even if the type of the instance is unknown
to the inspector.
This capability is illustrated by the procedure <tt>print-fields</tt>
below, which accepts a record argument and writes the name and value of
each field of the record.

<p>

<p><tt>(define&nbsp;print-fields<br>

&nbsp;&nbsp;(lambda&nbsp;(r)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(unless&nbsp;(record?&nbsp;r)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(assertion-violation&nbsp;'print-fields&nbsp;"not&nbsp;a&nbsp;record"&nbsp;r))<br>

&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;loop&nbsp;([rtd&nbsp;(record-rtd&nbsp;r)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([prtd&nbsp;(record-type-parent&nbsp;rtd)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(when&nbsp;prtd&nbsp;(loop&nbsp;prtd)))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let*&nbsp;([v&nbsp;(record-type-field-names&nbsp;rtd)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[n&nbsp;(vector-length&nbsp;v)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(do&nbsp;([i&nbsp;0&nbsp;(+&nbsp;i&nbsp;1)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((=&nbsp;i&nbsp;n))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(write&nbsp;(vector-ref&nbsp;v&nbsp;i))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(display&nbsp;"=")<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(write&nbsp;((record-accessor&nbsp;rtd&nbsp;i)&nbsp;r))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(newline))))))</tt>
<p>With the familiar definitions of <tt>point</tt> and <tt>cpoint</tt>:

<p>

<p><tt>(define-record-type&nbsp;point&nbsp;(fields&nbsp;x&nbsp;y))<br>

(define-record-type&nbsp;cpoint&nbsp;(parent&nbsp;point)&nbsp;(fields&nbsp;color))</tt>
<p>the expression <tt>(print-fields&nbsp;(make-cpoint&nbsp;-3&nbsp;7&nbsp;'blue))</tt> displays
the following three lines.

<p>

<p><tt>x=-3<br>

y=7<br>

color=blue</tt>
<p>



<hr class=copyright align=left>
<p>
R. Kent Dybvig / <it>The Scheme Programming Language, Fourth Edition</it><br>
Copyright &copy; 2009 <a class=plain href="http://mitpress.mit.edu/catalog/item/default.asp?ttype=2&tid=11984">The MIT Press</a>.  Electronically reproduced by permission.<br>
Illustrations &copy; 2009 <a class=plain href="http://hebert.kitp.ucsb.edu/">Jean-Pierre H&eacute;bert</a><br>
ISBN 978-0-262-51298-5 / LOC QA76.73.S34D93<br>
<a class=plain href="http://mitpress.mit.edu/catalog/item/default.asp?ttype=2&tid=11984">to order this book</a> / <a class=plain href="canned/about.html">about this book</a>
</p>
<p><a class=plain href="http://www.scheme.com">http://www.scheme.com</a></p>
</body>
</html>
