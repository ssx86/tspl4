<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
  "http://www.w3.org/TR/html4/loose.dtd"><!-- DO NOT EDIT THIS FILE-->
<!-- Edit the .tex version instead-->

<html>
<head>
<title>Getting Started</title>
<link href="tspl.css" rel="stylesheet" type="text/css">
</head>
<body>
<a name="g4"></a>
<a name="./start:h0"></a>

<div style="font-size: 12px; width: 500px; height: 500px; border: solid thin">
<img style="padding: 20px 10px 20px 20px" src="canned/ch2.png"><img src="canned/jph.png">
</div>
<h1>Chapter 2. Getting Started<a name="CHPTGETTINGSTARTED"></a></h1>





<p>
This chapter is an introduction to Scheme for programmers who are new
to the language.
You will get more from this chapter if you are sitting in front of an
interactive Scheme system, trying out the examples as you go.

<p>
After reading this chapter and working the exercises, you should be
able to start using Scheme.
You will have learned the syntax of Scheme programs and how they are
executed, along with how to use simple data structures and control
mechanisms.


<p>

<h3><a name="g5"></a><a name="./start:h1"></a>Section 2.1. Interacting with Scheme<a name="SECTGSINTERACTING"></a></h3>



<p>
Most Scheme systems provide an interactive programming environment
that simplifies program development and experimentation.
The simplest interaction with Scheme follows a "read-evaluate-print"
cycle.
A program (often called a <i>read-evaluate-print loop</i>, or REPL)
reads each expression you type at the keyboard,
evaluates it, and prints its value.

<p>
With an interactive Scheme system, you can type an expression at 
the keyboard and see its value immediately.
You can define a procedure and apply it to arguments to see how it works. 
You can even type in an entire program consisting of a set of procedure 
definitions and test it without leaving the system.
When your program starts getting longer, it will be more convenient to 
type it into a file (using a text editor), load the file
and test it interactively.
In most Scheme systems, a file may be loaded with the nonstandard
procedure <a name="./start:s0"></a><tt>load</tt>, which takes a string
argument naming the file.
Preparing your program in a file has several advantages: you have a 
chance to compose your program more carefully, you can correct errors 
without retyping the program, and you can retain a copy for later use.
Most Scheme implementations treat expressions loaded from a file the same as expressions 
typed at the keyboard.

<p>
While Scheme provides various input and output procedures, the REPL
takes care of reading expressions and printing their values.
This frees you to concentrate on writing your program without worrying 
about how its results will be displayed.

<p>
The examples in this chapter and in the rest of the book follow a
regular format.
An expression you might type from your keyboard is given first,
possibly spanning several lines.
The value of the expression is given
after the <img src="math/tspl/0.gif" alt="<graphic>">, to be read as "evaluates to."
The <img src="math/tspl/0.gif" alt="<graphic>"> is omitted for definitions and when the value of
an expression is unspecified.

<p>
The example programs are formatted in a style that "looks nice"
and conveys the structure of the program.
The code is easy to read because the relationship between each
expression and its subexpressions is clearly shown.
Scheme ignores indentation and line breaks, however, so there is no
need to follow a particular style.
The important thing is to establish one style and keep to it.
Scheme sees each program as if it were on a single line, with its
subexpressions ordered from left to right.

<p>
<p>If you have access to an interactive Scheme system, it might be a good idea to
start it up now and type in the examples as you read.
One of the simplest Scheme expressions is a <a name="./start:s1"></a>string constant.
Try typing <tt>"Hi&nbsp;Mom!"</tt> (including the double quotes) in response
to the prompt.
The system should respond with <tt>"Hi&nbsp;Mom!"</tt>; the value of any
constant is the constant itself.

<p>

<p><tt>"Hi&nbsp;Mom!"&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;"Hi&nbsp;Mom!"</tt>
<p>Here is a set of expressions, each with Scheme's response.
They are explained in later sections of this chapter, but for now
use them to practice interacting with Scheme.

<p>

<p><tt>"hello"&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;"hello"<br>

42&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;42<br>

22/7&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;22/7<br>

3.141592653&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;3.141592653<br>

+&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#&lt;procedure&gt;<br>

(+&nbsp;76&nbsp;31)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;107<br>

(*&nbsp;-12&nbsp;10)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;-120<br>

'(a&nbsp;b&nbsp;c&nbsp;d)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(a&nbsp;b&nbsp;c&nbsp;d)</tt>
<p>Be careful not to miss any single quotes (&nbsp;<tt>'</tt>&nbsp;), double quotes, or
parentheses.
If you left off a single quote in the last
expression, you probably received a message indicating that an exception
has occurred.
Just try again.
If you left off a closing parenthesis or double quote, the system might
still be waiting for it.

<p>
Here are a few more expressions to try.  You can try to figure out on
your own what they mean or wait to find out later in the chapter.

<p>

<p><tt>(car&nbsp;'(a&nbsp;b&nbsp;c))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;a<br>

(cdr&nbsp;'(a&nbsp;b&nbsp;c))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(b&nbsp;c)<br>

(cons&nbsp;'a&nbsp;'(b&nbsp;c))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(a&nbsp;b&nbsp;c)<br>

(cons&nbsp;(car&nbsp;'(a&nbsp;b&nbsp;c))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cdr&nbsp;'(d&nbsp;e&nbsp;f)))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(a&nbsp;e&nbsp;f)</tt>
<p>As you can see, Scheme expressions may span more than one line.
The Scheme system knows when it has an entire expression by matching
double quotes and parentheses.

<p>
Next, let's try defining a procedure<a name="./start:s2"></a>.

<p>

<p><tt>(define&nbsp;square<br>

&nbsp;&nbsp;(lambda&nbsp;(n)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;n&nbsp;n)))</tt>
<p>The procedure <tt>square</tt> computes the square <i>n</i><sup>2</sup> of any number <i>n</i>.
We say more about the expressions that make up this definition later in
this chapter.
For now it suffices to say that <tt>define</tt> establishes variable bindings,
<tt>lambda</tt> creates procedures, and <tt>*</tt> names the multiplication
procedure.
Note the form of these expressions.
All structured forms are enclosed in parentheses and written in
<a name="./start:s3"></a><i>prefix notation</i>, i.e., the operator precedes the arguments.
As you can see, this is true even for simple arithmetic operations such
as <tt>*</tt>.

<p>
Try using <tt>square</tt>.

<p>

<p><tt>(square&nbsp;5)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;25<br>

(square&nbsp;-200)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;40000<br>

(square&nbsp;0.5)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;0.25<br>

(square&nbsp;-1/2)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;1/4</tt>
<p>Even though the next definition is short, you might enter it into a file.
Let's assume you call the file "reciprocal.ss."

<p>

<p><tt>(define&nbsp;reciprocal<br>

&nbsp;&nbsp;(lambda&nbsp;(n)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(=&nbsp;n&nbsp;0)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"oops!"<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(/&nbsp;1&nbsp;n))))</tt>
<p>This procedure, <a name="./start:s4"></a><tt>reciprocal</tt>, computes the quantity 1/<i>n</i> for any
number <i>n</i> &ne; 0.
For <i>n</i> = 0, <tt>reciprocal</tt> returns the string <tt>"oops!"</tt>.
Return to Scheme and try loading your file with the procedure <tt>load</tt>.

<p>

<p><tt>(load&nbsp;"reciprocal.ss")</tt>
<p>Finally, try using the procedure we have just defined.

<p>

<p><tt>(reciprocal&nbsp;10)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;1/10<br>

(reciprocal&nbsp;1/10)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;10<br>

(reciprocal&nbsp;0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;"oops!"<br>

(reciprocal&nbsp;(reciprocal&nbsp;1/10))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;1/10</tt>
<p>In the next section we will discuss Scheme expressions in more detail.
Throughout this chapter, keep in mind that your Scheme system is one
of the most useful tools for learning Scheme.
Whenever you try one of the examples in the text, follow it up with
your own examples.
In an interactive Scheme system, the cost of trying something out
is relatively small---usually just the time to type it in.


<p>

<h3><a name="g6"></a><a name="./start:h2"></a>Section 2.2. Simple Expressions<a name="SECTGSSIMPLE"></a></h3>



<p>
The simplest Scheme expressions are constant data objects, such as strings,
numbers, symbols, and lists.
Scheme supports other object types, but these four are enough for
many programs.
We saw some examples of strings and numbers in the preceding
section.

<p>
Let's discuss <a name="./start:s5"></a>numbers in a little more detail.
Numbers are constants.
If you enter a number, Scheme echoes it back to you.
The following examples show that Scheme supports several types of
numbers.

<p>

<p><tt>123456789987654321&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;123456789987654321<br>

3/4&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;3/4<br>

2.718281828&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;2.718281828<br>

2.2+1.1i&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;2.2+1.1i</tt>
<p>Scheme numbers include exact and inexact integer, rational, real, and
complex numbers.
Exact integers and rational numbers have arbitrary precision, i.e., they
can be of arbitrary size.
Inexact numbers are usually represented internally using
IEEE standard floating-point representations.

<p>
Scheme provides the names <a name="./start:s6"></a><tt>+</tt>, <a name="./start:s7"></a><tt>-</tt>, <a name="./start:s8"></a><tt>*</tt>, and <a name="./start:s9"></a><tt>/</tt> for
the corresponding arithmetic procedures.
Each procedure accepts two numeric arguments.
The expressions below are called
<a name="./start:s10"></a><i>procedure applications</i>,
because they specify the application of a procedure to
a set of arguments.

<p>

<p><tt>(+&nbsp;1/2&nbsp;1/2)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;1<br>

(-&nbsp;1.5&nbsp;1/2)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;1.0
<br>
<br>
(*&nbsp;3&nbsp;1/2)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;3/2<br>

(/&nbsp;1.5&nbsp;3/4)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;2.0</tt>
<p>Scheme employs <a name="./start:s11"></a>prefix notation even for common arithmetic operations.
Any procedure application, whether the procedure
takes zero, one, two, or more arguments, is written as
<tt>(<i>procedure</i>&nbsp;<i>arg</i>&nbsp;...)</tt>.
This regularity simplifies the syntax of expressions; one notation is
employed regardless of the operation, and there are no complicated rules
regarding the <a name="./start:s12"></a>precedence
or associativity of operators.

<p>
Procedure applications may be nested, in which case the innermost
values are computed first.
We can thus nest applications of the arithmetic procedures given above
to evaluate more complicated formulas. 

<p>

<p><tt>(+&nbsp;(+&nbsp;2&nbsp;2)&nbsp;(+&nbsp;2&nbsp;2))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;8<br>

(-&nbsp;2&nbsp;(*&nbsp;4&nbsp;1/3))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;2/3<br>

(*&nbsp;2&nbsp;(*&nbsp;2&nbsp;(*&nbsp;2&nbsp;(*&nbsp;2&nbsp;2))))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;32<br>

(/&nbsp;(*&nbsp;6/7&nbsp;7/2)&nbsp;(-&nbsp;4.5&nbsp;1.5))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;1.0</tt>
<p>These examples demonstrate everything you need to use Scheme as a
four-function desk calculator.
While we will not discuss them in this chapter, Scheme supports
many other arithmetic procedures.
Now might be a good time to turn to Section&nbsp;<a href="./objects.html#g110">6.4</a> and experiment
with some of them.

<p>
<p><a name="./start:s13"></a>Simple numeric objects are sufficient for many tasks, but
sometimes aggregate data structures containing two or more values
are needed.
In many languages, the basic aggregate data structure is the array.
In Scheme, it is the <i>list</i>.
Lists are written as sequences of objects surrounded by parentheses.
For instance, <tt>(1&nbsp;2&nbsp;3&nbsp;4&nbsp;5)</tt> is a list of numbers, and
<tt>("this"&nbsp;"is"&nbsp;"a"&nbsp;"list")</tt> is a list of strings.
Lists need not contain only one type of object, so
<tt>(4.2&nbsp;"hi")</tt> is a valid list containing a number and a string.
Lists may be nested (may contain other lists), so <tt>((1&nbsp;2)&nbsp;(3&nbsp;4))</tt> is a
valid list with two
elements, each of which is a list of two elements.

<p>
You might notice that lists look just like procedure applications
and wonder how Scheme tells them apart.
That is, how does Scheme distinguish between a list of objects,
<tt>(<i>obj<sub>1</sub></i>&nbsp;<i>obj<sub>2</sub></i>&nbsp;...)</tt>,
and a <a name="./start:s14"></a>procedure application,
<tt>(<i>procedure</i>&nbsp;<i>arg</i>&nbsp;...)</tt>?

<p>
In some cases, the distinction might seem obvious.
The list of numbers <tt>(1&nbsp;2&nbsp;3&nbsp;4&nbsp;5)</tt> could hardly be confused with a
procedure application, since 1 is a number, not a procedure.
So, the answer might be that Scheme looks at the first element of the
list or procedure application and makes its decision based on whether
that first element is a procedure or not.
This answer is not good enough, since we might even want to treat a valid
procedure application such as <tt>(+&nbsp;3&nbsp;4)</tt> as a list.
The answer is that we must tell Scheme explicitly to treat a list as
data rather than as a procedure application.
We do this with <a name="./start:s15"></a><a name="./start:s16"></a><tt>quote</tt>.

<p>

<p><tt>(quote&nbsp;(1&nbsp;2&nbsp;3&nbsp;4&nbsp;5))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(1&nbsp;2&nbsp;3&nbsp;4&nbsp;5)<br>

(quote&nbsp;("this"&nbsp;"is"&nbsp;"a"&nbsp;"list"))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;("this"&nbsp;"is"&nbsp;"a"&nbsp;"list")<br>

(quote&nbsp;(+&nbsp;3&nbsp;4))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(+&nbsp;3&nbsp;4)</tt>
<p>The <tt>quote</tt> forces the list to be treated as data.
Try entering the above expressions without the quote; you will likely
receive a message indicating that an exception has occurred for the first
two and an incorrect answer (<tt>7</tt>) for the third.

<p>
Because <tt>quote</tt> is required fairly frequently in Scheme code, Scheme
recognizes a single quotation mark (&nbsp;<tt>'</tt>&nbsp;) preceding
an expression as an abbreviation for <tt>quote</tt>.

<p>

<p><tt>'(1&nbsp;2&nbsp;3&nbsp;4)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(1&nbsp;2&nbsp;3&nbsp;4)<br>

'((1&nbsp;2)&nbsp;(3&nbsp;4))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;((1&nbsp;2)&nbsp;(3&nbsp;4))<br>

'(/&nbsp;(*&nbsp;2&nbsp;-1)&nbsp;3)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(/&nbsp;(*&nbsp;2&nbsp;-1)&nbsp;3)</tt>
<p>Both forms are referred to as <tt>quote</tt> expressions.
We often say an object is <i>quoted</i> when it is enclosed in
a <tt>quote</tt> expression.

<p>
A <tt>quote</tt> expression is <i>not</i> a procedure application, since
it inhibits the evaluation of its subexpression.
It is an entirely different syntactic form.
Scheme supports several other <a name="./start:s17"></a>syntactic forms in addition to
procedure applications and <tt>quote</tt> expressions.
Each syntactic form is evaluated differently.
Fortunately, the number of different syntactic forms is small.
We will see more of them later in this chapter.

<p>
Not all <tt>quote</tt> expressions involve lists.
Try the following expression with and without the <tt>quote</tt>
wrapper.

<p>

<p><tt>(quote&nbsp;hello)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;hello</tt>
<p>The symbol <tt>hello</tt> must be quoted in order to prevent Scheme from
treating <tt>hello</tt> as a <i>variable</i>.
Symbols and <a name="./start:s18"></a>variables in Scheme are similar to <a name="./start:s19"></a>symbols and
variables in mathematical expressions and equations.
When we evaluate the mathematical expression 1 - <i>x</i> for some value of
<i>x</i>, we think of <i>x</i> as a variable.
On the other hand, when we consider the algebraic equation 
<i>x</i><sup>2</sup> - 1 = (<i>x</i> - 1)(<i>x</i> + 1), we think of <i>x</i> as a symbol (in fact, we
think of the whole equation symbolically).
Just as quoting a list tells Scheme to treat a parenthesized form as
a list rather than as a procedure application,
quoting an identifier tells Scheme to treat the identifier
as a symbol rather than as a variable.
While symbols are commonly used to represent variables in symbolic
representations of equations or programs,
symbols may
also be used, for example, as words in the representation of natural
language sentences.

<p>
You might wonder why applications and variables share notations with
lists and symbols.
The shared notation allows Scheme programs to be represented as Scheme
data, simplifying the writing
of interpreters, compilers, editors, and other tools in Scheme.
This is demonstrated by the Scheme interpreter given in
Section&nbsp;<a href="./examples.html#g187">12.7</a>,
which is itself written in Scheme.
Many people believe this to be one of the most important features of
Scheme.

<p>
Numbers and strings may be quoted, too.

<p>

<p><tt>'2&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;2<br>

'2/3&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;2/3<br>

(quote&nbsp;"Hi&nbsp;Mom!")&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;"Hi&nbsp;Mom!"</tt>
<p>Numbers and strings are treated as constants in any case, however,
so quoting them is unnecessary.

<p>
<p>Now let's discuss some Scheme procedures for manipulating <a name="./start:s20"></a>lists.
There are two basic procedures for taking lists apart: <a name="./start:s21"></a><tt>car</tt> and
<a name="./start:s22"></a><tt>cdr</tt> (pronounced <i>could-er</i>).
<tt>car</tt> returns the first element of a list, and <tt>cdr</tt> returns
the remainder of the list.
(The names "car" and "cdr" are derived from operations
supported by the first computer
on which a Lisp language was implemented, the IBM&nbsp;704.)
Each requires a nonempty list as its argument.

<p>

<p><tt>(car&nbsp;'(a&nbsp;b&nbsp;c))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;a<br>

(cdr&nbsp;'(a&nbsp;b&nbsp;c))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(b&nbsp;c)<br>

(cdr&nbsp;'(a))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;()
<br>
<br>
(car&nbsp;(cdr&nbsp;'(a&nbsp;b&nbsp;c)))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;b<br>

(cdr&nbsp;(cdr&nbsp;'(a&nbsp;b&nbsp;c)))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(c)
<br>
<br>
(car&nbsp;'((a&nbsp;b)&nbsp;(c&nbsp;d)))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(a&nbsp;b)<br>

(cdr&nbsp;'((a&nbsp;b)&nbsp;(c&nbsp;d)))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;((c&nbsp;d))</tt>
<p>The first element of a list is often called the "car" of the
list, and the rest of the list is often called the "cdr" of
the list.
The cdr of a list with one element is <a name="./start:s23"></a><tt>()</tt>, the <a name="./start:s24"></a><i>empty list</i>.

<p>
The procedure <a name="./start:s25"></a><tt>cons</tt> constructs lists.
It takes two arguments.
The second argument is usually a list, and in that case <tt>cons</tt>
returns a list.

<p>

<p><tt>(cons&nbsp;'a&nbsp;'())&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(a)<br>

(cons&nbsp;'a&nbsp;'(b&nbsp;c))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(a&nbsp;b&nbsp;c)<br>

(cons&nbsp;'a&nbsp;(cons&nbsp;'b&nbsp;(cons&nbsp;'c&nbsp;'())))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(a&nbsp;b&nbsp;c)<br>

(cons&nbsp;'(a&nbsp;b)&nbsp;'(c&nbsp;d))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;((a&nbsp;b)&nbsp;c&nbsp;d)
<br>
<br>
(car&nbsp;(cons&nbsp;'a&nbsp;'(b&nbsp;c)))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;a<br>

(cdr&nbsp;(cons&nbsp;'a&nbsp;'(b&nbsp;c)))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(b&nbsp;c)<br>

(cons&nbsp;(car&nbsp;'(a&nbsp;b&nbsp;c))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cdr&nbsp;'(d&nbsp;e&nbsp;f)))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(a&nbsp;e&nbsp;f)<br>

(cons&nbsp;(car&nbsp;'(a&nbsp;b&nbsp;c))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cdr&nbsp;'(a&nbsp;b&nbsp;c)))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(a&nbsp;b&nbsp;c)</tt>
<p>Just as "car" and "cdr" are often used as nouns, "cons" is
often used as a verb.
Creating a new list by adding an element to the beginning of a list
is referred to as <a name="./start:s26"></a><i>consing</i> the element onto the list.

<p>
Notice the word "usually" in the description of <tt>cons</tt>'s second
argument.
The procedure <tt>cons</tt> actually builds <a name="./start:s27"></a><i>pairs</i>, and there is no
reason that the cdr of a pair must be a list.
A list is a sequence of pairs; each pair's cdr is the next pair in
the sequence.
<p>
<img src="math/tspl/1.gif" alt="<graphic>"><p>

The cdr of the last pair in a <a name="./start:s28"></a><i>proper list</i> is the empty list.
Otherwise, the sequence of pairs forms an <a name="./start:s29"></a><i>improper list</i>.
More formally, the empty list is a proper list, and any pair whose cdr
is a proper list is a proper list.

<p>
An improper list is printed in <i>dotted-pair notation</i>, with a
period, or <a name="./start:s30"></a><a name="./start:s31"></a><i>dot</i>,
preceding the final element of the list.

<p>

<p><tt>(cons&nbsp;'a&nbsp;'b)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(a&nbsp;.&nbsp;b)<br>

(cdr&nbsp;'(a&nbsp;.&nbsp;b))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;b<br>

(cons&nbsp;'a&nbsp;'(b&nbsp;.&nbsp;c))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(a&nbsp;b&nbsp;.&nbsp;c)</tt>
<p>Because of its printed notation, a pair whose cdr is not a list is
often called a <a name="./start:s32"></a><i>dotted pair</i>.
Even pairs whose cdrs are lists can be written in dotted-pair
notation, however, although the printer always chooses to write
proper lists without dots.

<p>

<p><tt>'(a&nbsp;.&nbsp;(b&nbsp;.&nbsp;(c&nbsp;.&nbsp;())))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(a&nbsp;b&nbsp;c)</tt>
<p>The procedure <a name="./start:s33"></a><tt>list</tt> is similar to <tt>cons</tt>, except that it takes
an arbitrary number of arguments and always builds a proper list.

<p>

<p><tt>(list&nbsp;'a&nbsp;'b&nbsp;'c)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(a&nbsp;b&nbsp;c)<br>

(list&nbsp;'a)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(a)<br>

(list)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;()</tt>
<p>Section&nbsp;<a href="./objects.html#g109">6.3</a> provides more information on lists and the Scheme
procedures for manipulating them.
This might be a good time to turn to that section and familiarize
yourself with the other procedures given there.

<p>

<h4>Exercise <a name="g7"></a>2.2.1</h4>
<a name="./start:s34"></a>Convert the following arithmetic expressions into Scheme expressions
and evaluate them.

<p>

 
 <table>
<tr valign=top><td><i>&nbsp;&nbsp;a</i>.</td><td>1.2 &times; (2 - 1/3) + -8.7
<tr valign=top><td><i>&nbsp;&nbsp;b</i>.</td><td>(2/3 + 4/9) &divide; (5/11 - 4/3)
<tr valign=top><td><i>&nbsp;&nbsp;c</i>.</td><td>1 + 1 &divide; (2 + 1 &divide; (1 + 1/2))
<tr valign=top><td><i>&nbsp;&nbsp;d</i>.</td><td>1 &times; -2 &times; 3 &times; -4 &times; 5 &times; -6 &times; 7
</table>

<p>


<p>

<h4>Exercise <a name="g8"></a>2.2.2</h4>
<a name="./start:s35"></a>Experiment with the procedures <tt>+</tt>, <tt>-</tt>, <tt>*</tt>, and <tt>/</tt>
to determine Scheme's rules for the type of value returned by
each when given different types of numeric arguments.

<p>


<p>

<h4>Exercise <a name="g9"></a>2.2.3</h4>
<a name="./start:s36"></a><a name="EXEXPRVALUE"></a>Determine the values of the following expressions.
Use your Scheme system to verify your answers.

<p>

 
 <table>
<tr valign=top><td><i>&nbsp;&nbsp;a</i>.</td><td><tt>(cons&nbsp;'car&nbsp;'cdr)</tt>
<tr valign=top><td><i>&nbsp;&nbsp;b</i>.</td><td><tt>(list&nbsp;'this&nbsp;'(is&nbsp;silly))</tt>
<tr valign=top><td><i>&nbsp;&nbsp;c</i>.</td><td><tt>(cons&nbsp;'is&nbsp;'(this&nbsp;silly?))</tt>
<tr valign=top><td><i>&nbsp;&nbsp;d</i>.</td><td><tt>(quote&nbsp;(+&nbsp;2&nbsp;3))</tt>
<tr valign=top><td><i>&nbsp;&nbsp;e</i>.</td><td><tt>(cons&nbsp;'+&nbsp;'(2&nbsp;3))</tt>
<tr valign=top><td><i>&nbsp;&nbsp;f</i>.</td><td><tt>(car&nbsp;'(+&nbsp;2&nbsp;3))</tt>
<tr valign=top><td><i>&nbsp;&nbsp;g</i>.</td><td><tt>(cdr&nbsp;'(+&nbsp;2&nbsp;3))</tt>
<tr valign=top><td><i>&nbsp;&nbsp;h</i>.</td><td><tt>cons</tt>
<tr valign=top><td><i>&nbsp;&nbsp;i</i>.</td><td><tt>(quote&nbsp;cons)</tt>
<tr valign=top><td><i>&nbsp;&nbsp;j</i>.</td><td><tt>(quote&nbsp;(quote&nbsp;cons))</tt>
<tr valign=top><td><i>&nbsp;&nbsp;k</i>.</td><td><tt>(car&nbsp;(quote&nbsp;(quote&nbsp;cons)))</tt>
<tr valign=top><td><i>&nbsp;&nbsp;l</i>.</td><td><tt>(+&nbsp;2&nbsp;3)</tt>
<tr valign=top><td><i>&nbsp;&nbsp;m</i>.</td><td><tt>(+&nbsp;'2&nbsp;'3)</tt>
<tr valign=top><td><i>&nbsp;&nbsp;n</i>.</td><td><tt>(+&nbsp;(car&nbsp;'(2&nbsp;3))&nbsp;(car&nbsp;(cdr&nbsp;'(2&nbsp;3))))</tt>
<tr valign=top><td><i>&nbsp;&nbsp;o</i>.</td><td><tt>((car&nbsp;(list&nbsp;+&nbsp;-&nbsp;*&nbsp;/))&nbsp;2&nbsp;3)</tt>
</table>

<p>


<p>

<h4>Exercise <a name="g10"></a>2.2.4</h4>
<a name="./start:s37"></a><tt>(car&nbsp;(car&nbsp;'((a&nbsp;b)&nbsp;(c&nbsp;d))))</tt> yields <tt>a</tt>.
Determine which compositions of <tt>car</tt> and <tt>cdr</tt> applied
to <tt>((a&nbsp;b)&nbsp;(c&nbsp;d))</tt> yield <tt>b</tt>, <tt>c</tt>, and
<tt>d</tt>.

<p>


<p>

<h4>Exercise <a name="g11"></a>2.2.5</h4>
<a name="./start:s38"></a>Write a Scheme expression that evaluates to the following internal
list structure.

<p>
<p>
<img src="math/tspl/2.gif" alt="<graphic>"><p>


<p>


<p>

<h4>Exercise <a name="g12"></a>2.2.6</h4>
<a name="./start:s39"></a>Draw the internal list structure produced by the expression below.

<p>

<p><tt>(cons&nbsp;1&nbsp;(cons&nbsp;'(2&nbsp;.&nbsp;((3)&nbsp;.&nbsp;()))&nbsp;(cons&nbsp;'(())&nbsp;(cons&nbsp;4&nbsp;5))))</tt>
<p>


<p>

<h4>Exercise <a name="g13"></a>2.2.7</h4>
<a name="./start:s40"></a>The behavior of
<tt>(car&nbsp;(car&nbsp;(car&nbsp;'((a&nbsp;b)&nbsp;(c&nbsp;d)))))</tt> is undefined because
<tt>(car&nbsp;'((a&nbsp;b)&nbsp;(c&nbsp;d)))</tt> is <tt>(a&nbsp;b)</tt>,
<tt>(car&nbsp;'(a&nbsp;b))</tt> is <tt>a</tt>,
and <tt>(car&nbsp;'a)</tt> is undefined.
Determine all legal compositions of <tt>car</tt> and <tt>cdr</tt> applied
to <tt>((a&nbsp;b)&nbsp;(c&nbsp;d))</tt>.


<p>


<p>

<h4>Exercise <a name="g14"></a>2.2.8</h4>
<a name="./start:s41"></a>Try to explain how Scheme expressions are evaluated.
Does your explanation cover the last example in Exercise&nbsp;<a href="./start.html#g9">2.2.3</a>?

<p>


<p>

<h3><a name="g15"></a><a name="./start:h3"></a>Section 2.3. Evaluating Scheme Expressions<a name="SECTGSEVALUATING"></a></h3>



<p>
Let's turn to a discussion of how Scheme evaluates the expressions
you type.
We have already established the rules for <a name="./start:s42"></a>constant objects
such as strings and numbers: the object itself is the value.
You have probably also worked out in your mind a rule for evaluating
<a name="./start:s43"></a>procedure applications of the form
<tt>(<i>procedure</i>&nbsp;<i>arg<sub>1</sub></i>&nbsp;...&nbsp;<i>arg<sub>n</sub></i>)</tt>.
Here, <tt><i>procedure</i></tt> is an expression representing a Scheme procedure,
and <tt><i>arg<sub>1</sub></i>&nbsp;...&nbsp;<i>arg<sub>n</sub></i></tt> are expressions representing its
arguments.
One possibility is the following.

<p>
<ul>
<li>Find the value of <tt><i>procedure</i></tt>.

<p>
<li>Find the value of <tt><i>arg<sub>1</sub></i></tt>.

<p>
<img src="math/tspl/3.gif" alt="<graphic>">

<p>
<li>Find the value of <tt><i>arg<sub>n</sub></i></tt>.

<p>
<li>Apply the value of <tt><i>procedure</i></tt> to the values
of <tt><i>arg<sub>1</sub></i>&nbsp;...&nbsp;<i>arg<sub>n</sub></i></tt>.
</ul>
<p>

<p>
For example, consider the simple procedure application <tt>(+&nbsp;3&nbsp;4)</tt>.
The value of <tt>+</tt> is the addition procedure, the value of 3
is the number 3, and the value of 4 is the number 4.
Applying the addition procedure to 3 and 4 yields 7, so our value
is the object 7.

<p>
By applying this process at each level, we can find the value of the
nested expression <tt>(*&nbsp;(+&nbsp;3&nbsp;4)&nbsp;2)</tt>.
The value of <tt>*</tt> is the multiplication procedure, the value of
<tt>(+&nbsp;3&nbsp;4)</tt> we can determine to be the number 7, and the
value of 2 is the number 2.
Multiplying 7 by 2 we get 14, so our answer is 14.

<p>
This rule works for procedure applications but not
for
<a name="./start:s44"></a><a name="./start:s45"></a><tt>quote</tt> expressions
because the subexpressions of a procedure application are
evaluated, whereas the subexpression of a <tt>quote</tt> expression is
not.
The evaluation of a <tt>quote</tt> expression is more similar to the
evaluation of constant objects.
The value of a <tt>quote</tt> expression of the form
<tt>(quote&nbsp;<i>object</i>)</tt>
is simply <tt><i>object</i></tt>.

<p>
Constant objects, procedure applications, and <tt>quote</tt> expressions
are only three of the many syntactic forms provided by Scheme.
Fortunately, only a few of the other syntactic forms need to be
understood directly by a Scheme programmer; these are referred to as
<i>core</i> syntactic forms.
The remaining syntactic forms are <a name="./start:s46"></a><i>syntactic extensions</i>
defined, ultimately, in terms of the <a name="./start:s47"></a>core syntactic forms.
We will discuss the remaining core syntactic forms and a few
syntactic extensions in the remaining sections of this chapter.
Section&nbsp;<a href="./further.html#g50">3.1</a> summarizes the core syntactic forms and introduces
the syntactic extension mechanism.

<p>
<p>Before we go on to more syntactic forms and procedures,
two points related to the evaluation of procedure applications
are worthy of note.
<a name="./start:s48"></a>First, the process given above is
overspecified, in that it requires the subexpressions to be evaluated
from left to right.
That is, <tt><i>procedure</i></tt> is evaluated before <tt><i>arg<sub>1</sub></i></tt>,
<tt><i>arg<sub>1</sub></i></tt> is evaluated before <tt><i>arg<sub>2</sub></i></tt>, and so on.
This need not be the case.
A Scheme evaluator is free to evaluate the expressions in
any order---left to right, right to left, or any other sequential
order.
In fact, the subexpressions may be evaluated in different orders
for different applications, even in the same implementation.

<p>
The second point is that <tt><i>procedure</i></tt> is evaluated in the
same way as <tt><i>arg<sub>1</sub></i>&nbsp;...&nbsp;<i>arg<sub>n</sub></i></tt>.
While <tt><i>procedure</i></tt> is often a variable
that names a particular procedure, this need not be the case.
Exercise&nbsp;<a href="./start.html#g9">2.2.3</a> had you determine
the value of the expression <tt>((car&nbsp;(list&nbsp;+&nbsp;-&nbsp;*&nbsp;/))&nbsp;2&nbsp;3)</tt>.
Here, <tt><i>procedure</i></tt> is <tt>(car&nbsp;(list&nbsp;+&nbsp;-&nbsp;*&nbsp;/))</tt>.
The value of <tt>(car&nbsp;(list&nbsp;+&nbsp;-&nbsp;*&nbsp;/))</tt> is the addition procedure,
just as if <tt><i>procedure</i></tt> were simply the variable
<tt>+</tt>.

<p>

<h4>Exercise <a name="g16"></a>2.3.1</h4>
<a name="./start:s49"></a>Write down the steps necessary to evaluate the expression below.

<p>

<p><tt>((car&nbsp;(cdr&nbsp;(list&nbsp;+&nbsp;-&nbsp;*&nbsp;/)))&nbsp;17&nbsp;5)</tt>
<p>

<p>

<h3><a name="g17"></a><a name="./start:h4"></a>Section 2.4. Variables and Let Expressions<a name="SECTGSIDENTIFIERS"></a></h3>



<p>
<a name="./start:s50"></a>Suppose <tt><i>expr</i></tt> is a Scheme expression that contains
a variable <tt><i>var</i></tt>.
Suppose, additionally, that we would like <tt><i>var</i></tt> to have the value 
<tt><i>val</i></tt> when we evaluate <tt><i>expr</i></tt>.
For example, we might like <tt>x</tt> to have the value 2 when we 
evaluate <tt>(+&nbsp;x&nbsp;3)</tt>.
Or, we might want <tt>y</tt> to have the value 3 when we evaluate 
<tt>(+&nbsp;2&nbsp;y)</tt>.
The following examples demonstrate how to do this using Scheme's
<a name="./start:s51"></a><tt>let</tt> syntactic form.

<p>

<p><tt>(let&nbsp;((x&nbsp;2))<br>

&nbsp;&nbsp;(+&nbsp;x&nbsp;3))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;5
<br>
<br>
(let&nbsp;((y&nbsp;3))<br>

&nbsp;&nbsp;(+&nbsp;2&nbsp;y))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;5
<br>
<br>
(let&nbsp;((x&nbsp;2)&nbsp;(y&nbsp;3))<br>

&nbsp;&nbsp;(+&nbsp;x&nbsp;y))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;5</tt>
<p>The <tt>let</tt> syntactic form includes a list of variable-expression pairs, 
along with a sequence of expressions referred to as the <i>body</i> of the
<tt>let</tt>. 
The general form of a <tt>let</tt> expression is

<p>

<p><tt>(let&nbsp;((<i>var</i>&nbsp;<i>expr</i>)&nbsp;...)&nbsp;<i>body<sub>1</sub></i>&nbsp;<i>body<sub>2</sub></i>&nbsp;...)</tt>
<p><a name="./start:s52"></a>We say the variables are <i>bound</i> to the
values by the <tt>let</tt>.
We refer to variables bound by <tt>let</tt> as
<a name="./start:s53"></a><tt>let</tt>-<i>bound</i> variables.

<p>
A <tt>let</tt> expression is often used to simplify an expression that
would contain two identical subexpressions.
Doing so also ensures that the
value of the common subexpression is computed only once.

<p>

<p><tt>(+&nbsp;(*&nbsp;4&nbsp;4)&nbsp;(*&nbsp;4&nbsp;4))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;32
<br>
<br>
(let&nbsp;((a&nbsp;(*&nbsp;4&nbsp;4)))&nbsp;(+&nbsp;a&nbsp;a))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;32</tt>
<p>Brackets are often used in place of parentheses to delimit the bindings of
a <tt>let</tt> expression.

<p>

<p><tt>(let&nbsp;([list1&nbsp;'(a&nbsp;b&nbsp;c)]&nbsp;[list2&nbsp;'(d&nbsp;e&nbsp;f)])<br>

&nbsp;&nbsp;(cons&nbsp;(cons&nbsp;(car&nbsp;list1)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(car&nbsp;list2))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cons&nbsp;(car&nbsp;(cdr&nbsp;list1))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(car&nbsp;(cdr&nbsp;list2)))))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;((a&nbsp;.&nbsp;d)&nbsp;b&nbsp;.&nbsp;e)</tt>
<p>Scheme treats forms enclosed in brackets just like forms enclosed in
parentheses.
An open bracket must be matched by a close bracket, and an open
parenthesis must be matched by a close parenthesis.
We use brackets for <tt>let</tt> (and, as we'll see, several other
standard syntactic forms) to improve readability, especially when we might
otherwise have two or more consecutive open parentheses.

<p>
Since expressions in the first position of a procedure application
are evaluated no differently from other expressions, a <tt>let</tt>-bound
variable may be used there as well.

<p>

<p><tt>(let&nbsp;([f&nbsp;+])<br>

&nbsp;&nbsp;(f&nbsp;2&nbsp;3))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;5
<br>
<br>
(let&nbsp;([f&nbsp;+]&nbsp;[x&nbsp;2])<br>

&nbsp;&nbsp;(f&nbsp;x&nbsp;3))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;5
<br>
<br>
(let&nbsp;([f&nbsp;+]&nbsp;[x&nbsp;2]&nbsp;[y&nbsp;3])<br>

&nbsp;&nbsp;(f&nbsp;x&nbsp;y))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;5</tt>
<p>The variables bound by <tt>let</tt> are visible only within the body of 
the <tt>let</tt>.

<p>

<p><tt>(let&nbsp;([+&nbsp;*])<br>

&nbsp;&nbsp;(+&nbsp;2&nbsp;3))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;6
<br>
<br>
(+&nbsp;2&nbsp;3)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;5</tt>
<p>This is fortunate, because we would not want the
value of <tt>+</tt> to be the multiplication procedure everywhere.

<p>
It is possible to nest <tt>let</tt> expressions.

<p>

<p><tt>(let&nbsp;([a&nbsp;4]&nbsp;[b&nbsp;-3])<br>

&nbsp;&nbsp;(let&nbsp;([a-squared&nbsp;(*&nbsp;a&nbsp;a)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[b-squared&nbsp;(*&nbsp;b&nbsp;b)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;(+&nbsp;a-squared&nbsp;b-squared)))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;25</tt>
<p>When nested <tt>let</tt> expressions bind the same variable, only the 
binding created by the inner <tt>let</tt> is visible within its body.

<p>

<p><tt>(let&nbsp;([x&nbsp;1])<br>

&nbsp;&nbsp;(let&nbsp;([x&nbsp;(+&nbsp;x&nbsp;1)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;(+&nbsp;x&nbsp;x)))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;4</tt>
<p>The outer <tt>let</tt> expression binds <tt>x</tt> to 1 within its
body, which is the second <tt>let</tt> expression.
The inner <tt>let</tt> expression binds <tt>x</tt> to <tt>(+&nbsp;x&nbsp;1)</tt> within
its body, which is the expression <tt>(+&nbsp;x&nbsp;x)</tt>.
What is the value of <tt>(+&nbsp;x&nbsp;1)</tt>?
Since <tt>(+&nbsp;x&nbsp;1)</tt> appears within the body of the outer <tt>let</tt>
but not within the body of the inner <tt>let</tt>, the value of <tt>x</tt>
must be 1 and hence the value of <tt>(+&nbsp;x&nbsp;1)</tt> is 2.
What about <tt>(+&nbsp;x&nbsp;x)</tt>?
It appears within the body of both <tt>let</tt> expressions.
Only the inner binding for <tt>x</tt> is visible, so <tt>x</tt> is 2
and <tt>(+&nbsp;x&nbsp;x)</tt> is 4.


<p>
<a name="./start:s54"></a>The inner binding for <tt>x</tt> is said to <i>shadow</i> the
outer binding.
A <tt>let</tt>-bound variable is visible everywhere within the body of its
<tt>let</tt> expression except where it is shadowed.
The region where a variable binding is visible is called its
<a name="./start:s55"></a><i>scope</i>.
The scope of the first <tt>x</tt> in the example above is the body of
the outer <tt>let</tt> expression minus the body of the inner <tt>let</tt>
expression, where it is shadowed by the second <tt>x</tt>.
This form of scoping is referred to as <a name="./start:s56"></a><i>lexical scoping</i>,
since the scope of each binding can be determined by a straightforward
textual analysis of the program.


<p>
Shadowing may be avoided by choosing different names
for variables.
The expression above could be rewritten so that the variable bound
by the inner <tt>let</tt> is <tt>new-x</tt>.

<p>

<p><tt>(let&nbsp;([x&nbsp;1])<br>

&nbsp;&nbsp;(let&nbsp;([new-x&nbsp;(+&nbsp;x&nbsp;1)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;(+&nbsp;new-x&nbsp;new-x)))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;4</tt>
<p>Although choosing different names can sometimes prevent confusion,
shadowing can help prevent the accidental use of an
"old" value.
For example, with the original version of the preceding example,
it would be impossible for us to mistakenly refer to the outer <tt>x</tt>
within the body of the inner <tt>let</tt>.

<p>

<h4>Exercise <a name="g18"></a>2.4.1</h4>
<a name="./start:s57"></a>Rewrite the following expressions, using <tt>let</tt> to remove common
subexpressions and to improve the structure of the code.
Do not perform any algebraic simplifications.

<p>

 
 <table>
<tr valign=top><td><i>&nbsp;&nbsp;a</i>.</td><td><tt>(+&nbsp;(-&nbsp;(*&nbsp;3&nbsp;a)&nbsp;b)&nbsp;(+&nbsp;(*&nbsp;3&nbsp;a)&nbsp;b))</tt>
<tr valign=top><td><i>&nbsp;&nbsp;b</i>.</td><td><tt>(cons&nbsp;(car&nbsp;(list&nbsp;a&nbsp;b&nbsp;c))&nbsp;(cdr&nbsp;(list&nbsp;a&nbsp;b&nbsp;c)))</tt>
</table>

<p>


<p>

<h4>Exercise <a name="g19"></a>2.4.2</h4>
<a name="./start:s58"></a>Determine the value of the following expression.
Explain how you derived this value.

<p>

<p><tt>(let&nbsp;([x&nbsp;9])<br>

&nbsp;&nbsp;(*&nbsp;x<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([x&nbsp;(/&nbsp;x&nbsp;3)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(+&nbsp;x&nbsp;x))))</tt>
<p>

<p>

<h4>Exercise <a name="g20"></a>2.4.3</h4>
<a name="./start:s59"></a>Rewrite the following expressions to give unique names to each different
<tt>let</tt>-bound variable so that none of the variables is shadowed.
Verify that the value of your expression is the same as that of the
original expression.

<p>

 
 <table>
<tr valign=top><td><i>&nbsp;&nbsp;a</i>.</td><td>
<p><tt>(let&nbsp;([x&nbsp;'a]&nbsp;[y&nbsp;'b])<br>

&nbsp;&nbsp;(list&nbsp;(let&nbsp;([x&nbsp;'c])&nbsp;(cons&nbsp;x&nbsp;y))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([y&nbsp;'d])&nbsp;(cons&nbsp;x&nbsp;y))))</tt>
<p><tr valign=top><td><i>&nbsp;&nbsp;b</i>.</td><td>
<p><tt>(let&nbsp;([x&nbsp;'((a&nbsp;b)&nbsp;c)])<br>

&nbsp;&nbsp;(cons&nbsp;(let&nbsp;([x&nbsp;(cdr&nbsp;x)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(car&nbsp;x))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([x&nbsp;(car&nbsp;x)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cons&nbsp;(let&nbsp;([x&nbsp;(cdr&nbsp;x)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(car&nbsp;x))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cons&nbsp;(let&nbsp;([x&nbsp;(car&nbsp;x)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cdr&nbsp;x))))))</tt>
<p></table>

<p>



<p>

<h3><a name="g21"></a><a name="./start:h5"></a>Section 2.5. Lambda Expressions<a name="SECTGSLAMBDA"></a></h3>



<p>
In the expression <tt>(let&nbsp;([x&nbsp;(*&nbsp;3&nbsp;4)])&nbsp;(+&nbsp;x&nbsp;x))</tt>, the variable
<tt>x</tt> is bound to the value of <tt>(*&nbsp;3&nbsp;4)</tt>.
What if we would like the value of <tt>(+&nbsp;x&nbsp;x)</tt> where <tt>x</tt> is
bound to the value of <tt>(/&nbsp;99&nbsp;11)</tt>?
Where <tt>x</tt> is bound to the value of <tt>(-&nbsp;2&nbsp;7)</tt>?
In each case we need a different <tt>let</tt> expression.
When the body of the <tt>let</tt> is complicated, however, having to
repeat it can be inconvenient.

<p>
Instead, we can use the syntactic form <a name="./start:s60"></a><tt>lambda</tt> to create a new
<a name="./start:s61"></a>procedure that has <tt>x</tt> as a parameter and has the same
body as the <tt>let</tt> expression.

<p>

<p><tt>(lambda&nbsp;(x)&nbsp;(+&nbsp;x&nbsp;x))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#&lt;procedure&gt;</tt>
<p>The general form of a <tt>lambda</tt> expression is

<p>

<p><tt>(lambda&nbsp;(<i>var</i>&nbsp;...)&nbsp;<i>body<sub>1</sub></i>&nbsp;<i>body<sub>2</sub></i>&nbsp;...)</tt>
<p>The variables <tt><i>var</i>&nbsp;...</tt> are the <a name="./start:s62"></a><i>formal parameters</i>
of the procedure, and the sequence of expressions
<tt><i>body<sub>1</sub></i>&nbsp;<i>body<sub>2</sub></i>&nbsp;...</tt> is its body.
(Actually, the true general form is somewhat more general than this,
as you will see later.)

<p>
A procedure is just as much an object as a number, string, symbol,
or pair.
It does not have any meaningful printed representation as
far as Scheme is concerned, however, so this book uses the notation
<tt>#&lt;procedure&gt;</tt> to show that the value of an expression is a
procedure.

<p>
The most common operation to perform on a procedure is to apply it
to one or more values.

<p>

<p><tt>((lambda&nbsp;(x)&nbsp;(+&nbsp;x&nbsp;x))&nbsp;(*&nbsp;3&nbsp;4))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;24</tt>
<p>This is no different from any other <a name="./start:s63"></a>procedure application.
The procedure is the value of <tt>(lambda&nbsp;(x)&nbsp;(+&nbsp;x&nbsp;x))</tt>, and the
only argument is the value of <tt>(*&nbsp;3&nbsp;4)</tt>, or 12.
The argument values, or <a name="./start:s64"></a><i>actual parameters</i>, are bound to the
formal parameters within the body of the <tt>lambda</tt> expression
in the same way as <tt>let</tt>-bound variables are bound to their values.
In this case, <tt>x</tt> is bound to 12, and
the value of <tt>(+&nbsp;x&nbsp;x)</tt> is 24.
Thus, the result of applying the procedure to the value 12 is 24.

<p>
Because procedures are objects, we can establish
a procedure as the value of a variable and use the procedure more
than once.<a name="./start:s65"></a>

<p>

<p><tt>(let&nbsp;([double&nbsp;(lambda&nbsp;(x)&nbsp;(+&nbsp;x&nbsp;x))])<br>

&nbsp;&nbsp;(list&nbsp;(double&nbsp;(*&nbsp;3&nbsp;4))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(double&nbsp;(/&nbsp;99&nbsp;11))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(double&nbsp;(-&nbsp;2&nbsp;7))))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(24&nbsp;18&nbsp;-10)</tt>
<p>Here, we establish a binding for <tt>double</tt> to a procedure, then
use this procedure to double three different values.

<p>
The procedure expects its actual parameter to be a number, since
it passes the actual parameter on to <tt>+</tt>.
In general, the actual parameter may be any sort of object.
Consider, for example, a similar procedure that uses <tt>cons</tt>
instead of <tt>+</tt>.<a name="./start:s66"></a>

<p>

<p><tt>(let&nbsp;([double-cons&nbsp;(lambda&nbsp;(x)&nbsp;(cons&nbsp;x&nbsp;x))])<br>

&nbsp;&nbsp;(double-cons&nbsp;'a))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(a&nbsp;.&nbsp;a)</tt>
<p>Noting the similarity between <tt>double</tt> and <tt>double-cons</tt>,
you should not be surprised to learn that they may be collapsed
into a single procedure by adding an additional argument.

<p>

<p><tt>(let&nbsp;([double-any&nbsp;(lambda&nbsp;(f&nbsp;x)&nbsp;(f&nbsp;x&nbsp;x))])<br>

&nbsp;&nbsp;(list&nbsp;(double-any&nbsp;+&nbsp;13)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(double-any&nbsp;cons&nbsp;'a)))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(26&nbsp;(a&nbsp;.&nbsp;a))</tt>
<p>This demonstrates that procedures may accept more than
one argument and that arguments passed to a procedure may
themselves be procedures.

<p>
<p>As with <tt>let</tt> expressions, <tt>lambda</tt> expressions become
somewhat more interesting when they are nested within other
<tt>lambda</tt> or <tt>let</tt> expressions.

<p>

<p><tt>(let&nbsp;([x&nbsp;'a])<br>

&nbsp;&nbsp;(let&nbsp;([f&nbsp;(lambda&nbsp;(y)&nbsp;(list&nbsp;x&nbsp;y))])<br>

&nbsp;&nbsp;&nbsp;&nbsp;(f&nbsp;'b)))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(a&nbsp;b)</tt>
<p>The occurrence of <tt>x</tt> within the <tt>lambda</tt> expression
refers to the <tt>x</tt> outside the <tt>lambda</tt> that is bound by
the outer <tt>let</tt> expression.
The variable <tt>x</tt> is said to <a name="./start:s67"></a><i>occur free</i>
in the <tt>lambda</tt> expression or to be a
<a name="./start:s68"></a><i>free variable</i> of the <tt>lambda</tt> expression.
The variable <tt>y</tt> does not occur free in the <tt>lambda</tt>
expression since it is bound by the <tt>lambda</tt> expression.
A variable that occurs free in a <tt>lambda</tt> expression
should be bound, e.g., by an enclosing <tt>lambda</tt> or <tt>let</tt>
expression, unless the variable is (like the names of primitive
procedures) bound outside of the expression, as we discuss in
the following section.

<p>
What happens when the procedure is applied somewhere outside
the scope of the bindings for variables that occur free
within the procedure, as in the following expression?

<p>

<p><tt>(let&nbsp;([f&nbsp;(let&nbsp;([x&nbsp;'sam])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(y&nbsp;z)&nbsp;(list&nbsp;x&nbsp;y&nbsp;z)))])<br>

&nbsp;&nbsp;(f&nbsp;'i&nbsp;'am))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(sam&nbsp;i&nbsp;am)</tt>
<p>The answer is that the same bindings that were in effect when
the procedure was created are in effect again when the procedure
is applied.
This is true even if another binding for <tt>x</tt>
is visible where the procedure is applied.

<p>

<p><tt>(let&nbsp;([f&nbsp;(let&nbsp;([x&nbsp;'sam])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(y&nbsp;z)&nbsp;(list&nbsp;x&nbsp;y&nbsp;z)))])<br>

&nbsp;&nbsp;(let&nbsp;([x&nbsp;'not-sam])<br>

&nbsp;&nbsp;&nbsp;&nbsp;(f&nbsp;'i&nbsp;'am)))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(sam&nbsp;i&nbsp;am)</tt>
<p>In both cases, the value of <tt>x</tt> within the procedure named
<tt>f</tt> is <tt>sam</tt>.


<p>
<p>Incidentally, a <tt>let</tt> expression is nothing more than the
direct application of a <tt>lambda</tt> expression to a set of
argument expressions.
For example, the two expressions below are equivalent.

<p>
<p><tt>(let&nbsp;([x&nbsp;'a])&nbsp;(cons&nbsp;x&nbsp;x))</tt>&nbsp;&equiv;&nbsp;<tt>((lambda&nbsp;(x)&nbsp;(cons&nbsp;x&nbsp;x))&nbsp;'a)</tt>

<p>
<p>In fact, a <a name="./start:s69"></a><tt>let</tt> expression is a syntactic extension defined
in terms of <tt>lambda</tt> and procedure application, which are
both core syntactic forms.
In general, any expression of the form

<p>

<p><tt>(let&nbsp;((<i>var</i>&nbsp;<i>expr</i>)&nbsp;...)&nbsp;<i>body<sub>1</sub></i>&nbsp;<i>body<sub>2</sub></i>&nbsp;...)</tt>
<p>is equivalent to the following.

<p>

<p><tt>((lambda&nbsp;(<i>var</i>&nbsp;...)&nbsp;<i>body<sub>1</sub></i>&nbsp;<i>body<sub>2</sub></i>&nbsp;...)<br>

&nbsp;<i>expr</i>&nbsp;...)</tt>
<p>See Section&nbsp;<a href="./further.html#g50">3.1</a> for more about core forms and syntactic
extensions.

<p>
<p>As mentioned above, the general form of
<a name="./start:s70"></a><a name="./start:s71"></a><tt>lambda</tt> is a bit
more complicated than the form we saw earlier, in that the
formal parameter specification, <tt>(<i>var</i>&nbsp;...)</tt>, need not be a proper list,
or indeed even a list at all.
The formal parameter specification can be in any of the following three forms:

<p>
<ul>
<li>a proper list of variables, <tt>(<i>var<sub>1</sub></i>&nbsp;...&nbsp;<i>var<sub>n</sub></i>)</tt>, such
as we have already seen,

<p>
<li>a single variable, <tt><i>var<sub>r</sub></i></tt>, or

<p>
<li>an improper list of variables,
<tt>(<i>var<sub>1</sub></i>&nbsp;...&nbsp;<i>var<sub>n</sub></i>&nbsp;.&nbsp;<i>var<sub>r</sub></i>)</tt>.
</ul>
<p>

<p>
In the first case, exactly <i>n</i> actual parameters must
be supplied, and
each variable is bound to the corresponding actual parameter.
In the second, any number of actual parameters is valid; all of the
actual parameters
are put into a single list and the single variable is bound to this
list.
The third case is a hybrid of the first two cases.
At least <i>n</i> actual parameters must be supplied.
The variables <tt><i>var<sub>1</sub></i>&nbsp;...&nbsp;<i>var<sub>n</sub></i></tt>
are bound to the corresponding actual parameters,
and the variable <tt><i>var<sub>r</sub></i></tt> is bound to a list containing
the remaining actual parameters.
In the second and third cases, <tt><i>var<sub>r</sub></i></tt> is sometimes referred to
as a "rest" parameter because it holds the rest of the actual
parameters beyond those that are individually named.

<p>
Let's consider a few examples to help clarify the more general
syntax of <tt>lambda</tt> expressions.

<p>

<p><tt>(let&nbsp;([f&nbsp;(lambda&nbsp;x&nbsp;x)])<br>

&nbsp;&nbsp;(f&nbsp;1&nbsp;2&nbsp;3&nbsp;4))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(1&nbsp;2&nbsp;3&nbsp;4)
<br>
<br>
(let&nbsp;([f&nbsp;(lambda&nbsp;x&nbsp;x)])<br>

&nbsp;&nbsp;(f))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;()
<br>
<br>
(let&nbsp;([g&nbsp;(lambda&nbsp;(x&nbsp;.&nbsp;y)&nbsp;(list&nbsp;x&nbsp;y))])<br>

&nbsp;&nbsp;(g&nbsp;1&nbsp;2&nbsp;3&nbsp;4))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(1&nbsp;(2&nbsp;3&nbsp;4))
<br>
<br>
(let&nbsp;([h&nbsp;(lambda&nbsp;(x&nbsp;y&nbsp;.&nbsp;z)&nbsp;(list&nbsp;x&nbsp;y&nbsp;z))])<br>

&nbsp;&nbsp;(h&nbsp;'a&nbsp;'b&nbsp;'c&nbsp;'d))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(a&nbsp;b&nbsp;(c&nbsp;d))</tt>
<p>In the first two examples, the procedure named <tt>f</tt> accepts any
number of arguments.
These arguments are automatically formed into a list to which the
variable <tt>x</tt> is bound; the value of <tt>f</tt> is this list.
In the first example, the arguments are 1, 2, 3,
and 4, so the answer is <tt>(1&nbsp;2&nbsp;3&nbsp;4)</tt>.
In the second, there are no arguments, so the answer is the empty
list <tt>()</tt>.
The value of the procedure named <tt>g</tt> in the third example
is a list whose first element is the first argument and whose
second element is a list containing the remaining arguments.
The procedure named <tt>h</tt> is similar but separates out the
second argument.
While <tt>f</tt> accepts any number of arguments, <tt>g</tt> must receive
at least one and <tt>h</tt> must receive at least two.

<p>

<h4>Exercise <a name="g22"></a>2.5.1</h4>
<a name="./start:s72"></a>Determine the values of the expressions below.

<p>

 
 <table>
<tr valign=top><td><i>&nbsp;&nbsp;a</i>.</td><td>
<p><tt>(let&nbsp;([f&nbsp;(lambda&nbsp;(x)&nbsp;x)])<br>

&nbsp;&nbsp;(f&nbsp;'a))</tt>
<p><tr valign=top><td><i>&nbsp;&nbsp;b</i>.</td><td>
<p><tt>(let&nbsp;([f&nbsp;(lambda&nbsp;x&nbsp;x)])<br>

&nbsp;&nbsp;(f&nbsp;'a))</tt>
<p><tr valign=top><td><i>&nbsp;&nbsp;c</i>.</td><td>
<p><tt>(let&nbsp;([f&nbsp;(lambda&nbsp;(x&nbsp;.&nbsp;y)&nbsp;x)])<br>

&nbsp;&nbsp;(f&nbsp;'a))</tt>
<p><tr valign=top><td><i>&nbsp;&nbsp;d</i>.</td><td>
<p><tt>(let&nbsp;([f&nbsp;(lambda&nbsp;(x&nbsp;.&nbsp;y)&nbsp;y)])<br>

&nbsp;&nbsp;(f&nbsp;'a))</tt>
<p></table>

<p>


<p>

<h4>Exercise <a name="g23"></a>2.5.2</h4>
<a name="./start:s73"></a>How might the primitive procedure <tt>list</tt> be defined?

<p>


<p>

<h4>Exercise <a name="g24"></a>2.5.3</h4>
<a name="./start:s74"></a>List the variables that <a name="./start:s75"></a>occur free in each of the <tt>lambda</tt>
expressions below.
Do not omit variables that name primitive procedures such as
<tt>+</tt> or <tt>cons</tt>.

<p>

 
 <table>
<tr valign=top><td><i>&nbsp;&nbsp;a</i>.</td><td><tt>(lambda&nbsp;(f&nbsp;x)&nbsp;(f&nbsp;x))</tt>
<tr valign=top><td><i>&nbsp;&nbsp;b</i>.</td><td><tt>(lambda&nbsp;(x)&nbsp;(+&nbsp;x&nbsp;x))</tt>
<tr valign=top><td><i>&nbsp;&nbsp;c</i>.</td><td><tt>(lambda&nbsp;(x&nbsp;y)&nbsp;(f&nbsp;x&nbsp;y))</tt>
<tr valign=top><td><i>&nbsp;&nbsp;d</i>.</td><td>
<p><tt>(lambda&nbsp;(x)<br>

&nbsp;&nbsp;(cons&nbsp;x&nbsp;(f&nbsp;x&nbsp;y)))</tt>
<p><tr valign=top><td><i>&nbsp;&nbsp;e</i>.</td><td>
<p><tt>(lambda&nbsp;(x)<br>

&nbsp;&nbsp;(let&nbsp;([z&nbsp;(cons&nbsp;x&nbsp;y)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;(x&nbsp;y&nbsp;z)))</tt>
<p><tr valign=top><td><i>&nbsp;&nbsp;f</i>.</td><td>
<p><tt>(lambda&nbsp;(x)<br>

&nbsp;&nbsp;(let&nbsp;([y&nbsp;(cons&nbsp;x&nbsp;y)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;(x&nbsp;y&nbsp;z)))</tt>
<p></table>

<p>


<p>

<h3><a name="g25"></a><a name="./start:h6"></a>Section 2.6. Top-Level Definitions<a name="SECTGSTOPLEVEL"></a></h3>



<p>
<a name="./start:s76"></a>The <a name="./start:s77"></a>variables bound by <tt>let</tt> and <tt>lambda</tt>
expressions are not visible outside the bodies of these expressions.
Suppose you have created an object, perhaps a procedure, that must
be accessible anywhere, like <tt>+</tt> or <tt>cons</tt>.
What you need is a <i>top-level definition</i>, which may be established
with <a name="./start:s78"></a><tt>define</tt>.
Top-level definitions, which are supported by most interactive Scheme
systems, are visible in every expression you enter,
except where shadowed by another binding.

<p>
Let's establish a top-level definition of the <a name="./start:s79"></a><tt>double-any</tt>
procedure of the last section.

<p>

<p><tt>(define&nbsp;double-any<br>

&nbsp;&nbsp;(lambda&nbsp;(f&nbsp;x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(f&nbsp;x&nbsp;x)))</tt>
<p>The variable <tt>double-any</tt> now has the same status as <tt>cons</tt>
or the name of any other primitive procedure.
We can use <tt>double-any</tt> as if it were a primitive procedure.

<p>

<p><tt>(double-any&nbsp;+&nbsp;10)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;20<br>

(double-any&nbsp;cons&nbsp;'a)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(a&nbsp;.&nbsp;a)</tt>
<p>A top-level definition may be established for any object, not just
for procedures.

<p>

<p><tt>(define&nbsp;sandwich&nbsp;"peanut-butter-and-jelly")
<br>
<br>
sandwich&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;"peanut-butter-and-jelly"</tt>
<p><a name="./start:s80"></a>Most often, though, top-level definitions are
used for procedures.

<p>
<a name="./start:s81"></a>As suggested above, top-level definitions may be shadowed
by <tt>let</tt> or <tt>lambda</tt> bindings.

<p>

<p><tt>(define&nbsp;xyz&nbsp;'(x&nbsp;y&nbsp;z))<br>

(let&nbsp;([xyz&nbsp;'(z&nbsp;y&nbsp;x)])<br>

&nbsp;&nbsp;xyz)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(z&nbsp;y&nbsp;x)</tt>
<p>Variables with top-level definitions act almost as if they were bound
by a <tt>let</tt> expression enclosing all of the expressions you type.

<p>
<a name="defn:list"></a>Given only the simple tools you have read about up to this point,
it is already possible to define some of the primitive procedures
provided by Scheme and described later in this book.
If you completed the exercises from the last section, you should
already know how to define <a name="./start:s82"></a><tt>list</tt>.

<p>

<p><tt>(define&nbsp;list&nbsp;(lambda&nbsp;x&nbsp;x))</tt>
<p>Also, Scheme provides the abbreviations <a name="./start:s83"></a><tt>cadr</tt> and <a name="./start:s84"></a><tt>cddr</tt> for
the compositions of <tt>car</tt> with <tt>cdr</tt> and <tt>cdr</tt> with <tt>cdr</tt>.
That is, <tt>(cadr&nbsp;<i>list</i>)</tt> is equivalent to
<tt>(car&nbsp;(cdr&nbsp;<i>list</i>))</tt>, and, similarly,
<tt>(cddr&nbsp;<i>list</i>)</tt> is equivalent to
<tt>(cdr&nbsp;(cdr&nbsp;<i>list</i>))</tt>.
They are easily defined as follows.

<p>

<p><tt>(define&nbsp;cadr<br>

&nbsp;&nbsp;(lambda&nbsp;(x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(car&nbsp;(cdr&nbsp;x))))
<br>
<br>
(define&nbsp;cddr<br>

&nbsp;&nbsp;(lambda&nbsp;(x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(cdr&nbsp;(cdr&nbsp;x))))</tt>
<p>
<p><tt>(cadr&nbsp;'(a&nbsp;b&nbsp;c))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;b<br>

(cddr&nbsp;'(a&nbsp;b&nbsp;c))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(c)</tt>
<p>Any definition <tt>(define&nbsp;<i>var</i>&nbsp;<i>expr</i>)</tt> where <tt><i>expr</i></tt> is a
<tt>lambda</tt> expression can be written in a shorter form that suppresses
the <tt>lambda</tt>.
The exact syntax depends upon the format of the <tt>lambda</tt> expression's
formal parameter specifier, i.e., whether it is a proper list of
variables, a single variable, or an improper list of variables.
A definition of the form

<p>

<p><tt>(define&nbsp;<i>var<sub>0</sub></i><br>

&nbsp;&nbsp;(lambda&nbsp;(<i>var<sub>1</sub></i>&nbsp;...&nbsp;<i>var<sub>n</sub></i>)<br>

&nbsp;&nbsp;&nbsp;&nbsp;<i>e<sub>1</sub></i>&nbsp;<i>e<sub>2</sub></i>&nbsp;...))</tt>
<p>may be abbreviated

<p>

<p><tt>(define&nbsp;(<i>var<sub>0</sub></i>&nbsp;<i>var<sub>1</sub></i>&nbsp;...&nbsp;<i>var<sub>n</sub></i>)<br>

&nbsp;&nbsp;<i>e<sub>1</sub></i>&nbsp;<i>e<sub>2</sub></i>&nbsp;...)</tt>
<p>while

<p>

<p><tt>(define&nbsp;<i>var<sub>0</sub></i><br>

&nbsp;&nbsp;(lambda&nbsp;<i>var<sub>r</sub></i><br>

&nbsp;&nbsp;&nbsp;&nbsp;<i>e<sub>1</sub></i>&nbsp;<i>e<sub>2</sub></i>&nbsp;...))</tt>
<p>may be abbreviated

<p>

<p><tt>(define&nbsp;(<i>var<sub>0</sub></i>&nbsp;.&nbsp;<i>var<sub>r</sub></i>)<br>

&nbsp;&nbsp;<i>e<sub>1</sub></i>&nbsp;<i>e<sub>2</sub></i>&nbsp;...)</tt>
<p>and

<p>

<p><tt>(define&nbsp;<i>var<sub>0</sub></i><br>

&nbsp;&nbsp;(lambda&nbsp;(<i>var<sub>1</sub></i>&nbsp;...&nbsp;<i>var<sub>n</sub></i>&nbsp;.&nbsp;<i>var<sub>r</sub></i>)<br>

&nbsp;&nbsp;&nbsp;&nbsp;<i>e<sub>1</sub></i>&nbsp;<i>e<sub>2</sub></i>&nbsp;...))</tt>
<p>may be abbreviated

<p>

<p><tt>(define&nbsp;(<i>var<sub>0</sub></i>&nbsp;<i>var<sub>1</sub></i>&nbsp;...&nbsp;<i>var<sub>n</sub></i>&nbsp;.&nbsp;<i>var<sub>r</sub></i>)<br>

&nbsp;&nbsp;<i>e<sub>1</sub></i>&nbsp;<i>e<sub>2</sub></i>&nbsp;...)</tt>
<p>For example, the definitions of <a name="./start:s85"></a><tt>cadr</tt> and <a name="./start:s86"></a><tt>list</tt> might be written
as follows.

<p>

<p><tt>(define&nbsp;(cadr&nbsp;x)<br>

&nbsp;&nbsp;(car&nbsp;(cdr&nbsp;x)))
<br>
<br>
(define&nbsp;(list&nbsp;.&nbsp;x)&nbsp;x)</tt>
<p>This book does not often employ this alternative syntax.
Although it is shorter, it tends to mask the reality that procedures
are not intimately tied to variables, or names, as they are in many
other languages.
This syntax is often referred to, somewhat pejoratively,
as the <a name="./start:s87"></a>"defun" syntax for <tt>define</tt>, after the
<tt>defun</tt> form provided by Lisp languages in which procedures are more
closely tied to their names.

<p>
<p>Top-level definitions make it easier for us to experiment with a
procedure interactively
because we need not retype the procedure each time it is used.
Let's try defining a somewhat more complicated variation of <tt>double-any</tt>,
one that turns an "ordinary" two-argument procedure into a "doubling"
one-argument <a name="./start:s88"></a>procedure.

<p>

<p><tt>(define&nbsp;doubler<br>

&nbsp;&nbsp;(lambda&nbsp;(f)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(x)&nbsp;(f&nbsp;x&nbsp;x))))</tt>
<p><tt>doubler</tt> accepts one argument, <tt>f</tt>, which must be a
procedure that accepts two arguments.
The procedure returned by <tt>doubler</tt> accepts one argument, which
it uses for both arguments in an application of <tt>f</tt>.
We can define, with <tt>doubler</tt>, the simple
<a name="./start:s89"></a><tt>double</tt> and
<a name="./start:s90"></a><tt>double-cons</tt> procedures
of the last section.

<p>

<p><tt>(define&nbsp;double&nbsp;(doubler&nbsp;+))<br>

(double&nbsp;13/2)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;13
<br>
<br>
(define&nbsp;double-cons&nbsp;(doubler&nbsp;cons))<br>

(double-cons&nbsp;'a)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(a&nbsp;.&nbsp;a)</tt>
<p>We can also define <tt>double-any</tt> with <tt>doubler</tt>.

<p>

<p><tt>(define&nbsp;double-any<br>

&nbsp;&nbsp;(lambda&nbsp;(f&nbsp;x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;((doubler&nbsp;f)&nbsp;x)))</tt>
<p>Within <tt>double</tt> and
<tt>double-cons</tt>, <tt>f</tt> has the appropriate value, i.e., <tt>+</tt>
or <tt>cons</tt>, even though the procedures are clearly applied outside the
scope of <tt>f</tt>.

<p>
<p>What happens if you attempt to use a variable that is not bound by a
<tt>let</tt> or <tt>lambda</tt> expression and that does not have a top-level
definition?
Try using the variable <tt>i-am-not-defined</tt> to see what happens.

<p>

<p><tt>(i-am-not-defined&nbsp;3)</tt>
<p>Most Scheme systems print a message
indicating that an unbound- or undefined-variable exception
has occurred.

<p>
The system should not, however, complain
about the appearance of an undefined variable
within a <tt>lambda</tt> expression, until and unless the resulting procedure
is applied.
The following should <i>not</i> cause an exception, even though we have not yet
established a top-level definition of <tt>proc2</tt>.

<p>

<p><tt>(define&nbsp;proc1<br>

&nbsp;&nbsp;(lambda&nbsp;(x&nbsp;y)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(proc2&nbsp;y&nbsp;x)))</tt>
<p>If you try to apply <tt>proc1</tt> before defining <tt>proc2</tt>, you should get
a undefined exception message.
Let's give <tt>proc2</tt> a top-level definition and try <tt>proc1</tt>.

<p>

<p><tt>(define&nbsp;proc2&nbsp;cons)<br>

(proc1&nbsp;'a&nbsp;'b)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(b&nbsp;.&nbsp;a)</tt>
<p>When you define <tt>proc1</tt>, the system accepts your promise to define
<tt>proc2</tt>, and does not complain unless you use <tt>proc1</tt> before
defining <tt>proc2</tt>.
This allows you to define procedures in any order you please.
This is especially useful when you are trying to organize a file full of
procedure definitions in a way that makes your program more readable.
It is necessary when two procedures defined at top level depend upon
each other; we will see some examples of this later.

<p>

<h4>Exercise <a name="g26"></a>2.6.1</h4>
<a name="./start:s91"></a>What would happen if you were to type

<p>

<p><tt>(double-any&nbsp;double-any&nbsp;double-any)</tt>
<p>given the definition of <tt>double-any</tt> from the beginning of this
section?

<p>


<p>

<h4>Exercise <a name="g27"></a>2.6.2</h4>
<a name="./start:s92"></a>A more elegant (though possibly less efficient) way to define <a name="./start:s93"></a><tt>cadr</tt>
and <a name="./start:s94"></a><tt>cddr</tt> than given in this
section is to define a procedure that composes two procedures to create
a third.
Write the procedure <a name="./start:s95"></a><tt>compose</tt>, such that
<tt>(compose&nbsp;<i>p<sub>1</sub></i>&nbsp;<i>p<sub>2</sub></i>)</tt> is the composition of
<tt><i>p<sub>1</sub></i></tt> and <tt><i>p<sub>2</sub></i></tt> (assuming both take one argument).
That is, <tt>(compose&nbsp;<i>p<sub>1</sub></i>&nbsp;<i>p<sub>2</sub></i>)</tt> should return a new
procedure of one argument that applies <tt><i>p<sub>1</sub></i></tt> to the result of
applying <tt><i>p<sub>2</sub></i></tt> to the argument.
Use <tt>compose</tt> to define <tt>cadr</tt> and <tt>cddr</tt>.

<p>


<p>

<h4>Exercise <a name="g28"></a>2.6.3</h4>
<a name="./start:s96"></a>Scheme also provides
<a name="./start:s97"></a><tt>caar</tt>, <tt>cdar</tt>, <tt>caaar</tt>, <tt>caadr</tt>,
and so on, with any combination of up to four <tt>a</tt>'s (representing
<tt>car</tt>) and <tt>d</tt>'s (representing <tt>cdr</tt>) between the <tt>c</tt>
and the <tt>r</tt> (see Section&nbsp;<a href="./objects.html#g109">6.3</a>).
Define each of these with the <tt>compose</tt> procedure of the preceding
exercise.

<p>


<p>

<h3><a name="g29"></a><a name="./start:h7"></a>Section 2.7. Conditional Expressions<a name="SECTGSCONDITIONALS"></a></h3>



<p>
So far we have considered expressions that perform a given task
unconditionally.
Suppose that we wish to write the procedure <a name="./start:s98"></a><tt>abs</tt>.
If its argument <i>x</i> is negative, <tt>abs</tt>
returns -<i>x</i>; otherwise, it returns <i>x</i>.
The most straightforward way to write <tt>abs</tt> is to determine
whether the argument is negative and if so negate it, using the
<a name="./start:s99"></a><tt>if</tt> syntactic form.


<p>

<p><tt>(define&nbsp;abs<br>

&nbsp;&nbsp;(lambda&nbsp;(n)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(&lt;&nbsp;n&nbsp;0)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(-&nbsp;0&nbsp;n)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n)))
<br>
<br>
(abs&nbsp;77)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;77<br>

(abs&nbsp;-77)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;77</tt>
<p>An <tt>if</tt> expression has the form
<tt>(if&nbsp;<i>test</i>&nbsp;<i>consequent</i>&nbsp;<i>alternative</i>)</tt>, where
<tt><i>consequent</i></tt> is the expression to evaluate if <tt><i>test</i></tt> is true
and 
<tt><i>alternative</i></tt> is the expression to evaluate if <tt><i>test</i></tt> is false.
In the expression above, <tt><i>test</i></tt> is <tt>(&lt;&nbsp;n&nbsp;0)</tt>, <tt><i>consequent</i></tt>
is <tt>(-&nbsp;0&nbsp;n)</tt>, and <tt><i>alternative</i></tt> is <tt>n</tt>.

<p>
The procedure <tt>abs</tt> could be written in a variety of other ways.
Any of the following are valid definitions of <tt>abs</tt>.

<p>

<p><tt>(define&nbsp;abs<br>

&nbsp;&nbsp;(lambda&nbsp;(n)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(&gt;=&nbsp;n&nbsp;0)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(-&nbsp;0&nbsp;n))))
<br>
<br>
(define&nbsp;abs<br>

&nbsp;&nbsp;(lambda&nbsp;(n)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(not&nbsp;(&lt;&nbsp;n&nbsp;0))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(-&nbsp;0&nbsp;n))))
<br>
<br>
(define&nbsp;abs<br>

&nbsp;&nbsp;(lambda&nbsp;(n)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(or&nbsp;(&gt;&nbsp;n&nbsp;0)&nbsp;(=&nbsp;n&nbsp;0))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(-&nbsp;0&nbsp;n))))
<br>
<br>
(define&nbsp;abs<br>

&nbsp;&nbsp;(lambda&nbsp;(n)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(=&nbsp;n&nbsp;0)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(&lt;&nbsp;n&nbsp;0)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(-&nbsp;0&nbsp;n)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n))))
<br>
<br>
(define&nbsp;abs<br>

&nbsp;&nbsp;(lambda&nbsp;(n)<br>

&nbsp;&nbsp;&nbsp;&nbsp;((if&nbsp;(&gt;=&nbsp;n&nbsp;0)&nbsp;+&nbsp;-)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n)))</tt>
<p>The first of these definitions asks if <tt>n</tt> is greater
than or equal to zero, inverting the test.
The second asks if <tt>n</tt> is not less than zero, using the procedure
<a name="./start:s100"></a><tt>not</tt> with <tt>&lt;</tt>.
The third asks if <tt>n</tt> is greater than zero or <tt>n</tt> is equal to
zero, using the syntactic form <a name="./start:s101"></a><tt>or</tt>.
The fourth treats zero separately, though there is no benefit in doing so.
The fifth is somewhat tricky; <tt>n</tt> is either added to or subtracted from
zero, depending upon whether <tt>n</tt> is greater than or equal to zero.

<p>
Why is <a name="./start:s102"></a><tt>if</tt> a syntactic form and not a procedure?
In order to answer this, let's revisit the definition of
<tt>reciprocal</tt> from the first section of this chapter.

<p>

<p><tt>(define&nbsp;reciprocal<br>

&nbsp;&nbsp;(lambda&nbsp;(n)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(=&nbsp;n&nbsp;0)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"oops!"<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(/&nbsp;1&nbsp;n))))</tt>
<p>The second argument to the division procedure should not be zero,
since the result is mathematically undefined.
Our definition of <tt>reciprocal</tt> avoids this problem by
testing for zero before dividing.
Were <tt>if</tt> a procedure, its arguments (including <tt>(/&nbsp;1&nbsp;n)</tt>)
would be evaluated before it had a chance to choose between the
consequent and alternative.
Like <tt>quote</tt>, which does not evaluate its only subexpression,
<tt>if</tt> does not evaluate all of its subexpressions and so cannot
be a procedure.

<p>
The syntactic form <a name="./start:s103"></a><tt>or</tt> operates in a manner similar to <tt>if</tt>.
The general form of an <tt>or</tt> expression is <tt>(or&nbsp;<i>expr</i>&nbsp;...)</tt>.
If there are no subexpressions, i.e., the expression is simply <tt>(or)</tt>,
the value is false.
Otherwise, each <tt><i>expr</i></tt> is evaluated in turn until either (a) one of
the expressions evaluates to true or (b) no more expressions are left.
In case (a), the value is true; in case (b), the value is false.

<p>
To be more precise, in case (a), the value of the <tt>or</tt>
expression is the value of the last subexpression evaluated.
This clarification is necessary because there are many possible true
values.
Usually, the value of a test expression is one of the two objects
<a name="./start:s104"></a><tt>#t</tt>, for true, or <a name="./start:s105"></a><tt>#f</tt>, for false.

<p>

<p><tt>(&lt;&nbsp;-1&nbsp;0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(&gt;&nbsp;-1&nbsp;0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f</tt>
<p>Every Scheme object, however, is considered to be either <a name="./start:s106"></a>true
or <a name="./start:s107"></a>false by conditional expressions and by
the procedure <tt>not</tt>.
Only <tt>#f</tt> is considered false; all other objects are considered
true.

<p>

<p><tt>(if&nbsp;#t&nbsp;'true&nbsp;'false)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;true<br>

(if&nbsp;#f&nbsp;'true&nbsp;'false)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;false<br>

(if&nbsp;'()&nbsp;'true&nbsp;'false)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;true<br>

(if&nbsp;1&nbsp;'true&nbsp;'false)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;true<br>

(if&nbsp;'(a&nbsp;b&nbsp;c)&nbsp;'true&nbsp;'false)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;true
<br>
<br>
(not&nbsp;#t)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(not&nbsp;"false")&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(not&nbsp;#f)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t
<br>
<br>
(or)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(or&nbsp;#f)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(or&nbsp;#f&nbsp;#t)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(or&nbsp;#f&nbsp;'a&nbsp;#f)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;a</tt>
<p><p>The <a name="./start:s108"></a><tt>and</tt> syntactic form is similar in form to <tt>or</tt>, but an
<tt>and</tt> expression is true if all its subexpressions are true, and
false otherwise.
In the case where there are no subexpressions, i.e., the expression is
simply <tt>(and)</tt>, the value is true.
Otherwise, the subexpressions are evaluated in turn until either
no more subexpressions are left or the value of a subexpression is
false.
The value of the <tt>and</tt> expression
is the value of the last subexpression evaluated.

<p>
Using <tt>and</tt>, we can define a slightly different version of
<a name="./start:s109"></a><tt>reciprocal</tt>.

<p>

<p><tt>(define&nbsp;reciprocal<br>

&nbsp;&nbsp;(lambda&nbsp;(n)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(and&nbsp;(not&nbsp;(=&nbsp;n&nbsp;0))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(/&nbsp;1&nbsp;n))))
<br>
<br>
(reciprocal&nbsp;3)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;1/3<br>

(reciprocal&nbsp;0.5)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;2.0<br>

(reciprocal&nbsp;0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f</tt>
<p>In this version, the value is <tt>#f</tt> if <tt>n</tt> is zero and <tt>1/n</tt> otherwise.

<p>
<p>The procedures <tt>=</tt>, <tt>&lt;</tt>, <tt>&gt;</tt>, <tt>&lt;=</tt>, and <tt>&gt;=</tt> are
called <a name="./start:s110"></a><i>predicates</i>.
A predicate is a procedure that answers a specific question about its
arguments and returns one of the two values <tt>#t</tt> or <tt>#f</tt>.
The names of most predicates end with a
<a name="./start:s111"></a><a name="./start:s112"></a>question mark (&nbsp;<tt>?</tt>&nbsp;); the
common numeric procedures listed above are exceptions to this
rule.
Not all predicates require numeric arguments, of course.
The predicate <a name="./start:s113"></a><tt>null?</tt> returns true if its argument is the empty
list <tt>()</tt> and false otherwise.

<p>

<p><tt>(null?&nbsp;'())&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(null?&nbsp;'abc)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(null?&nbsp;'(x&nbsp;y&nbsp;z))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(null?&nbsp;(cdddr&nbsp;'(x&nbsp;y&nbsp;z)))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t</tt>
<p>The procedure <a name="./start:s114"></a><tt>cdr</tt> must not be passed anything other than a pair,
and an exception is raised when this happens.
Common Lisp, however, defines <tt>(cdr&nbsp;'())</tt> to be <tt>()</tt>.
The following procedure, <a name="./start:s115"></a><tt>lisp-cdr</tt>, is 
defined using <tt>null?</tt> to return
<tt>()</tt> if its argument is <tt>()</tt>.

<p>

<p><tt>(define&nbsp;lisp-cdr<br>

&nbsp;&nbsp;(lambda&nbsp;(x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(null?&nbsp;x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'()<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cdr&nbsp;x))))
<br>
<br>
(lisp-cdr&nbsp;'(a&nbsp;b&nbsp;c))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(b&nbsp;c)<br>

(lisp-cdr&nbsp;'(c))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;()<br>

(lisp-cdr&nbsp;'())&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;()</tt>
<p>Another useful predicate is <a name="./start:s116"></a><tt>eqv?</tt>, which
requires two arguments.
If the two arguments are equivalent, <tt>eqv?</tt> returns true.
Otherwise, <tt>eqv?</tt> returns false.

<p>

<p><tt>(eqv?&nbsp;'a&nbsp;'a)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(eqv?&nbsp;'a&nbsp;'b)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(eqv?&nbsp;#f&nbsp;#f)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(eqv?&nbsp;#t&nbsp;#t)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(eqv?&nbsp;#f&nbsp;#t)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(eqv?&nbsp;3&nbsp;3)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(eqv?&nbsp;3&nbsp;2)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(let&nbsp;([x&nbsp;"Hi&nbsp;Mom!"])<br>

&nbsp;&nbsp;(eqv?&nbsp;x&nbsp;x))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(let&nbsp;([x&nbsp;(cons&nbsp;'a&nbsp;'b)])<br>

&nbsp;&nbsp;(eqv?&nbsp;x&nbsp;x))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(eqv?&nbsp;(cons&nbsp;'a&nbsp;'b)&nbsp;(cons&nbsp;'a&nbsp;'b))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f</tt>
<p>As you can see, <tt>eqv?</tt> returns true if the arguments are the same
symbol, boolean, number, pair, or string.
Two pairs are not the same by <tt>eqv?</tt> if they are created by different
calls to <tt>cons</tt>, even if they have the same contents.
Detailed equivalence rules for <tt>eqv?</tt> are given in Section&nbsp;<a href="./objects.html#g108">6.2</a>.

<p>
Scheme also provides a set
of <a name="./start:s117"></a><i>type predicates</i> that return true
or false depending on the type of the object, e.g., <a name="./start:s118"></a><tt>pair?</tt>,
<a name="./start:s119"></a><tt>symbol?</tt>, <a name="./start:s120"></a><tt>number?</tt>, and <a name="./start:s121"></a><tt>string?</tt>.
The predicate <a name="./start:s122"></a><tt>pair?</tt>, for example, returns true only if its argument
is a pair.

<p>

<p><tt>(pair?&nbsp;'(a&nbsp;.&nbsp;c))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(pair?&nbsp;'(a&nbsp;b&nbsp;c))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(pair?&nbsp;'())&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(pair?&nbsp;'abc)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(pair?&nbsp;"Hi&nbsp;Mom!")&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(pair?&nbsp;1234567890)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f</tt>
<p>Type predicates are useful for deciding if the argument passed to a
procedure is of the appropriate type.
For example, the following version of <a name="./start:s123"></a><tt>reciprocal</tt> checks first to
see that its argument is a number before testing against zero or
performing the division. 

<p>

<p><tt>(define&nbsp;reciprocal<br>

&nbsp;&nbsp;(lambda&nbsp;(n)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(and&nbsp;(number?&nbsp;n)&nbsp;(not&nbsp;(=&nbsp;n&nbsp;0)))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(/&nbsp;1&nbsp;n)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"oops!")))
<br>
<br>
(reciprocal&nbsp;2/3)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;3/2<br>

(reciprocal&nbsp;'a)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;"oops!"</tt>
<p>By the way, the code that uses <tt>reciprocal</tt> must check to see that
the returned value is a number and not a string.
To relieve the caller of this obligation, it is usually preferable
to report the error, using <tt>assertion-violation</tt>,
as follows.

<p>

<p><tt>(define&nbsp;reciprocal<br>

&nbsp;&nbsp;(lambda&nbsp;(n)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(and&nbsp;(number?&nbsp;n)&nbsp;(not&nbsp;(=&nbsp;n&nbsp;0)))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(/&nbsp;1&nbsp;n)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(assertion-violation&nbsp;'reciprocal<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"improper&nbsp;argument"<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n))))
<br>
<br>
(reciprocal&nbsp;.25)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;4.0<br>

(reciprocal&nbsp;0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;<i>exception&nbsp;in&nbsp;reciprocal:&nbsp;improper&nbsp;argument&nbsp;0</i><br>

(reciprocal&nbsp;'a)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;<i>exception&nbsp;in&nbsp;reciprocal:&nbsp;improper&nbsp;argument&nbsp;a</i></tt>
<p>The first argument to <tt>assertion-violation</tt> is a symbol identifying where
the message originates, the second is a string describing the error,
and the third and subsequent arguments are "irritants" to be included with
the error message.

<p>
Let's look at one more conditional expression, <a name="./start:s124"></a><tt>cond</tt>, that is often
useful in place of <a name="./start:s125"></a><tt>if</tt>.
<tt>cond</tt> is similar to <tt>if</tt> except that it allows multiple
test and alternative expressions.
Consider the following definition of <tt>sign</tt>, which returns
<tt>-1</tt> for negative inputs,
<tt>+1</tt> for positive inputs, and
<tt>0</tt> for zero.

<p>

<p><tt>(define&nbsp;sign<br>

&nbsp;&nbsp;(lambda&nbsp;(n)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(&lt;&nbsp;n&nbsp;0)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-1<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(&gt;&nbsp;n&nbsp;0)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+1<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0))))</tt>
<p>
<p><tt>(sign&nbsp;-88.3)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;-1<br>

(sign&nbsp;0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;0<br>

(sign&nbsp;333333333333)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;1<br>

(*&nbsp;(sign&nbsp;-88.3)&nbsp;(abs&nbsp;-88.3))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;-88.3</tt>
<p>The two <tt>if</tt> expressions may be replaced by a single <tt>cond</tt>
expression as follows.

<p>

<p><tt>(define&nbsp;sign<br>

&nbsp;&nbsp;(lambda&nbsp;(n)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(cond<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(&lt;&nbsp;n&nbsp;0)&nbsp;-1]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(&gt;&nbsp;n&nbsp;0)&nbsp;+1]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[else&nbsp;0])))</tt>
<p>A <tt>cond</tt> expression usually takes the form

<p>

<p><tt>(cond&nbsp;(<i>test</i>&nbsp;<i>expr</i>)&nbsp;...&nbsp;(else&nbsp;<i>expr</i>))</tt>
<p>though the <tt>else</tt> clause may be omitted.
This should be done only when there is no possibility that all the tests
will fail, as in the new version of <tt>sign</tt> below.

<p>

<p><tt>(define&nbsp;sign<br>

&nbsp;&nbsp;(lambda&nbsp;(n)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(cond<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(&lt;&nbsp;n&nbsp;0)&nbsp;-1]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(&gt;&nbsp;n&nbsp;0)&nbsp;+1]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(=&nbsp;n&nbsp;0)&nbsp;0])))</tt>
<p>These definitions of <tt>sign</tt> do not depend on the order in which the
tests are performed, since only one of the tests can be true for any
value of <tt>n</tt>.
The following procedure computes the tax on a given amount of income in
a progressive tax system with breakpoints at 10,000, 20,000, and 30,000
dollars.

<p>

<p><tt>(define&nbsp;income-tax<br>

&nbsp;&nbsp;(lambda&nbsp;(income)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(cond<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(&lt;=&nbsp;income&nbsp;10000)&nbsp;(*&nbsp;income&nbsp;.05)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(&lt;=&nbsp;income&nbsp;20000)&nbsp;(+&nbsp;(*&nbsp;(-&nbsp;income&nbsp;10000)&nbsp;.08)&nbsp;500.00)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(&lt;=&nbsp;income&nbsp;30000)&nbsp;(+&nbsp;(*&nbsp;(-&nbsp;income&nbsp;20000)&nbsp;.13)&nbsp;1300.00)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[else&nbsp;(+&nbsp;(*&nbsp;(-&nbsp;income&nbsp;30000)&nbsp;.21)&nbsp;2600.00)])))</tt>
<p>
<p><tt>(income-tax&nbsp;5000)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;250.0<br>

(income-tax&nbsp;15000)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;900.0<br>

(income-tax&nbsp;25000)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;1950.0<br>

(income-tax&nbsp;50000)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;6800.0</tt>
<p>In this example, the order in which the tests are performed,
left to right (top to bottom), is significant.

<p>

<h4>Exercise <a name="g30"></a>2.7.1</h4>
<a name="./start:s126"></a>Define the predicate <a name="./start:s127"></a><tt>atom?</tt>, which returns true if its argument
is not a pair and false if it is.

<p>


<p>

<h4>Exercise <a name="g31"></a>2.7.2</h4>
<a name="./start:s128"></a><a name="EXSHORTER1"></a>The procedure <tt>length</tt> returns the length of its argument, which
must be a list.
For example, <tt>(length&nbsp;'(a&nbsp;b&nbsp;c))</tt> is 3.
Using <tt>length</tt>, define the procedure <a name="./start:s129"></a><tt>shorter</tt>, which returns the
shorter of two list arguments.
Have it return the first list if they have the same length.

<p>

<p><tt>(shorter&nbsp;'(a&nbsp;b)&nbsp;'(c&nbsp;d&nbsp;e))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(a&nbsp;b)<br>

(shorter&nbsp;'(a&nbsp;b)&nbsp;'(c&nbsp;d))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(a&nbsp;b)<br>

(shorter&nbsp;'(a&nbsp;b)&nbsp;'(c))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(c)</tt>
<p>

<p>

<h3><a name="g32"></a><a name="./start:h8"></a>Section 2.8. Simple Recursion<a name="SECTGSRECURSION"></a></h3>



<p>
<a name="./start:s130"></a>We have seen how we can control whether or not
expressions are evaluated with <tt>if</tt>, <tt>and</tt>, <tt>or</tt>,
and <tt>cond</tt>.
We can also perform an expression more than once by creating a
procedure containing the expression and invoking the procedure
more than once.
What if we need to perform some expression repeatedly, say for
all the elements of a list or all the numbers from one to ten?
We can do so via <a name="./start:s131"></a>recursion.
Recursion is a simple concept: the application of a procedure from
within that procedure.
It can be tricky to master recursion at first, but once mastered it
provides expressive power far beyond ordinary looping constructs.

<p>
A <a name="./start:s132"></a><i>recursive procedure</i> is a procedure that applies itself.
Perhaps the simplest recursive procedure is the following, which we will
call <a name="./start:s133"></a><tt>goodbye</tt>.

<p>

<p><tt>(define&nbsp;goodbye<br>

&nbsp;&nbsp;(lambda&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;(goodbye)))
<br>
<br>
(goodbye)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>"></tt>
<p>This procedure takes no arguments and simply applies itself immediately.
There is no value after the <img src="math/tspl/0.gif" alt="<graphic>"> because <tt>goodbye</tt> never returns.

<p>
Obviously, to make practical use out of a recursive procedure, we must
have some way to terminate the recursion.
Most recursive procedures should have at least two basic elements, a
<a name="./start:s134"></a><i>base case</i> and a <a name="./start:s135"></a><i>recursion step</i>.
The base case terminates the recursion, giving the value of the
procedure for some base argument.
The recursion step gives the value in terms of the value of the procedure
applied to a different argument.
In order for the recursion to terminate, the different argument must
be closer to the base argument in some way.

<p>
<a name="./start:s136"></a>Let's consider the problem of finding the length of a
proper list recursively.
We need a base case and a recursion step.
The logical base argument for recursion on lists is nearly always the empty
list.
The length of the empty list is zero, so the base case should give the
value zero for the empty list.
In order to become closer to the empty list, the natural recursion step
involves the cdr of the argument.
A nonempty list is one element longer than its cdr, so the recursion
step gives the value as one more than the length of the cdr of the
list<a name="defn:simplelength"></a>.

<p>

<p><tt>(define&nbsp;length<br>

&nbsp;&nbsp;(lambda&nbsp;(ls)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(null?&nbsp;ls)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(+&nbsp;(length&nbsp;(cdr&nbsp;ls))&nbsp;1))))</tt>
<p>
<p><tt>(length&nbsp;'())&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;0<br>

(length&nbsp;'(a))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;1<br>

(length&nbsp;'(a&nbsp;b))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;2</tt>
<p>The <tt>if</tt> expression asks if the list is empty.
If so, the value is zero.
This is the base case.
If not, the value is one more than the length of the cdr of the list.
This is the recursion step.

<p>
Many Scheme implementations allow you to trace the execution of a procedure to
see how it operates.
<a name="./start:s137"></a><a name="./start:s138"></a>In
<a name="./start:s139"></a>Chez&nbsp;Scheme, for example, one way to
trace a procedure is to type <tt>(trace&nbsp;<i>name</i>)</tt>, where
<tt><i>name</i></tt> is the name of a procedure you have defined at top level.
If you trace <tt>length</tt> as defined above and pass it the argument
<tt>'(a&nbsp;b&nbsp;c&nbsp;d)</tt>, you should see something like this:

<p>

<p><tt>|(length&nbsp;(a&nbsp;b&nbsp;c&nbsp;d))<br>

|&nbsp;(length&nbsp;(b&nbsp;c&nbsp;d))<br>

|&nbsp;|(length&nbsp;(c&nbsp;d))<br>

|&nbsp;|&nbsp;(length&nbsp;(d))<br>

|&nbsp;|&nbsp;|(length&nbsp;())<br>

|&nbsp;|&nbsp;|0<br>

|&nbsp;|&nbsp;1<br>

|&nbsp;|2<br>

|&nbsp;3<br>

|4</tt>
<p>The indentation shows the nesting level of the recursion; the vertical
lines associate applications visually with their values.
Notice that on each application of <tt>length</tt> the list gets smaller until
it finally reaches <tt>()</tt>.
The value at <tt>()</tt> is 0, and each outer level adds 1 to arrive
at the final value.

<p>
Let's write a procedure, <a name="./start:s140"></a><tt>list-copy</tt>, that returns a copy of its
argument, which must be a list.
That is, <tt>list-copy</tt> returns a new list consisting of the elements
(but not the pairs) of the old list.
Making a copy might be useful if either the original list or the copy
might be altered via <tt>set-car!</tt> or <tt>set-cdr!</tt>, which we discuss later.

<p>

<p><tt>(list-copy&nbsp;'())&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;()<br>

(list-copy&nbsp;'(a&nbsp;b&nbsp;c))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(a&nbsp;b&nbsp;c)</tt>
<p>See if you can define <tt>list-copy</tt> before studying the definition below.

<p>

<p><tt>(define&nbsp;list-copy<br>

&nbsp;&nbsp;(lambda&nbsp;(ls)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(null?&nbsp;ls)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'()<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cons&nbsp;(car&nbsp;ls)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(list-copy&nbsp;(cdr&nbsp;ls))))))</tt>
<p>The definition of <tt>list-copy</tt> is similar to the definition of
<tt>length</tt>.
The test in the base case is the same, <tt>(null?&nbsp;ls)</tt>.
The value in the base case is <tt>()</tt>, however, not 0, because we
are building up a list, not a number.
The recursive call is the same, but instead of adding one, <tt>list-copy</tt>
conses the car of the list onto the value of the recursive call.

<p>
There is no reason why there cannot be more than one base case.
The procedure <a name="./start:s141"></a><tt>memv</tt> takes two arguments, an object and a list.
It returns the first sublist, or <i>tail</i>,
of the list whose car is equal to the object, or
<tt>#f</tt> if the object is not found in the list.
The value of <tt>memv</tt> may be used as a list or as a truth value
in a conditional expression.

<p>

<p><tt>(define&nbsp;memv<br>

&nbsp;&nbsp;(lambda&nbsp;(x&nbsp;ls)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(cond<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(null?&nbsp;ls)&nbsp;#f]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(eqv?&nbsp;(car&nbsp;ls)&nbsp;x)&nbsp;ls]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[else&nbsp;(memv&nbsp;x&nbsp;(cdr&nbsp;ls))])))</tt>
<p>
<p><tt>(memv&nbsp;'a&nbsp;'(a&nbsp;b&nbsp;b&nbsp;d))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(a&nbsp;b&nbsp;b&nbsp;d)<br>

(memv&nbsp;'b&nbsp;'(a&nbsp;b&nbsp;b&nbsp;d))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(b&nbsp;b&nbsp;d)<br>

(memv&nbsp;'c&nbsp;'(a&nbsp;b&nbsp;b&nbsp;d))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(memv&nbsp;'d&nbsp;'(a&nbsp;b&nbsp;b&nbsp;d))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(d)<br>

(if&nbsp;(memv&nbsp;'b&nbsp;'(a&nbsp;b&nbsp;b&nbsp;d))<br>

&nbsp;&nbsp;&nbsp;&nbsp;"yes"<br>

&nbsp;&nbsp;&nbsp;&nbsp;"no")&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;"yes"</tt>
<p>Here there are two conditions to check, hence the use of <a name="./start:s142"></a><tt>cond</tt>.
The first cond clause checks for the base value of <tt>()</tt>; no object is a
member of <tt>()</tt>, so the answer is <tt>#f</tt>.
The second clause asks if the car of the list is the object, in which
case the list is returned, being the first tail whose car contains
the object.
The recursion step just continues down the list.

<p>
There may also be more than one recursion case.
Like <tt>memv</tt>, the procedure <a name="./start:s143"></a><tt>remv</tt> defined below takes two
arguments, an object and a list.
It returns a new list with all occurrences of the object removed from
the list.

<p>

<p><tt>(define&nbsp;remv<br>

&nbsp;&nbsp;(lambda&nbsp;(x&nbsp;ls)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(cond<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(null?&nbsp;ls)&nbsp;'()]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(eqv?&nbsp;(car&nbsp;ls)&nbsp;x)&nbsp;(remv&nbsp;x&nbsp;(cdr&nbsp;ls))]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[else&nbsp;(cons&nbsp;(car&nbsp;ls)&nbsp;(remv&nbsp;x&nbsp;(cdr&nbsp;ls)))])))</tt>
<p>
<p><tt>(remv&nbsp;'a&nbsp;'(a&nbsp;b&nbsp;b&nbsp;d))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(b&nbsp;b&nbsp;d)<br>

(remv&nbsp;'b&nbsp;'(a&nbsp;b&nbsp;b&nbsp;d))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(a&nbsp;d)<br>

(remv&nbsp;'c&nbsp;'(a&nbsp;b&nbsp;b&nbsp;d))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(a&nbsp;b&nbsp;b&nbsp;d)<br>

(remv&nbsp;'d&nbsp;'(a&nbsp;b&nbsp;b&nbsp;d))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(a&nbsp;b&nbsp;b)</tt>
<p>This definition is similar to the definition of <tt>memv</tt> above,
except <tt>remv</tt> does not quit once it finds the element in the car
of the list.
Rather, it continues, simply ignoring the element.
If the element is not found in the car of the list, <tt>remv</tt> does
the same thing as <tt>list-copy</tt> above: it conses the car of the list
onto the recursive value.

<p>
Up to now, the recursion has been only on the cdr of a list.
It is sometimes useful, however, for a procedure to recur on
the car as well as the cdr of the list.
The procedure <a name="./start:s144"></a><tt>tree-copy</tt> defined below
treats the structure of pairs as a tree
rather than as a list, with the left subtree being the car of the pair and
the right subtree being the cdr of the pair.
It performs a similar operation to <tt>list-copy</tt>, building new pairs
while leaving the elements (leaves) alone.

<p>

<p><tt>(define&nbsp;tree-copy<br>

&nbsp;&nbsp;(lambda&nbsp;(tr)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(not&nbsp;(pair?&nbsp;tr))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tr<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cons&nbsp;(tree-copy&nbsp;(car&nbsp;tr))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(tree-copy&nbsp;(cdr&nbsp;tr))))))</tt>
<p>
<p><tt>(tree-copy&nbsp;'((a&nbsp;.&nbsp;b)&nbsp;.&nbsp;c))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;((a&nbsp;.&nbsp;b)&nbsp;.&nbsp;c)</tt>
<p>The natural base argument for a tree structure is anything that is not a
pair, since the recursion traverses pairs rather than lists.
The recursive step in this case is <i>doubly recursive</i>, finding the
value recursively for the car as well as the cdr of the argument.

<p>
<p>At this point, readers who are familiar with other languages that provide
special iteration constructs, e.g., <i>while</i> or <i>for</i> loops, might
wonder whether similar constructs are required in Scheme.
Such constructs are unnecessary; <a name="./start:s145"></a>iteration in Scheme
is expressed more clearly and succinctly via recursion.
Recursion is more general and eliminates the need for the variable
assignments required by many other languages' iteration constructs,
resulting in code that is more reliable and easier to follow.
Some recursion is essentially iteration and executes as such;
Section&nbsp;<a href="./further.html#g55">3.2</a> has more to say about this.
Often, there is no need to make a distinction, however.
Concentrate instead on writing clear, concise, and correct programs.

<p>
Before we leave the topic of recursion, let's consider a special form of
repetition called <a name="./start:s146"></a><i>mapping</i>.
Consider the following procedure, <tt>abs-all</tt>, that takes a list of
numbers as input and returns a list of their absolute values.

<p>

<p><tt>(define&nbsp;abs-all<br>

&nbsp;&nbsp;(lambda&nbsp;(ls)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(null?&nbsp;ls)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'()<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cons&nbsp;(abs&nbsp;(car&nbsp;ls))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(abs-all&nbsp;(cdr&nbsp;ls))))))</tt>
<p>
<p><tt>(abs-all&nbsp;'(1&nbsp;-2&nbsp;3&nbsp;-4&nbsp;5&nbsp;-6))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(1&nbsp;2&nbsp;3&nbsp;4&nbsp;5&nbsp;6)</tt>
<p>This procedure forms a new list from the input list by applying the
procedure <tt>abs</tt> to each element.
We say that <tt>abs-all</tt> <i>maps</i> <tt>abs</tt> over the input list to
produce the output list.
Mapping a procedure over a list is a fairly common thing to do, so Scheme
provides the procedure <tt>map</tt>, which maps its first argument,
a procedure, over its second, a list.
We can use <a name="./start:s147"></a><tt>map</tt> to define <tt>abs-all</tt>.

<p>

<p><tt>(define&nbsp;abs-all<br>

&nbsp;&nbsp;(lambda&nbsp;(ls)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(map&nbsp;abs&nbsp;ls)))</tt>
<p>We really do not need <tt>abs-all</tt>, however, since the corresponding
direct application of <tt>map</tt> is just as short and perhaps clearer.

<p>

<p><tt>(map&nbsp;abs&nbsp;'(1&nbsp;-2&nbsp;3&nbsp;-4&nbsp;5&nbsp;-6))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(1&nbsp;2&nbsp;3&nbsp;4&nbsp;5&nbsp;6)</tt>
<p>Of course, we can use <tt>lambda</tt> to create the procedure argument to
<tt>map</tt>, e.g., to square the elements of a list of numbers.

<p>

<p><tt>(map&nbsp;(lambda&nbsp;(x)&nbsp;(*&nbsp;x&nbsp;x))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'(1&nbsp;-3&nbsp;-5&nbsp;7))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(1&nbsp;9&nbsp;25&nbsp;49)</tt>
<p>We can map a multiple-argument procedure over multiple lists, as
in the following example.

<p>

<p><tt>(map&nbsp;cons&nbsp;'(a&nbsp;b&nbsp;c)&nbsp;'(1&nbsp;2&nbsp;3))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;((a&nbsp;.&nbsp;1)&nbsp;(b&nbsp;.&nbsp;2)&nbsp;(c&nbsp;.&nbsp;3))</tt>
<p>The lists must be of the same length, and the procedure should accept as
many arguments as there are lists.
Each element of the output list is the result of applying the procedure
to corresponding members of the input list.

<p>
Looking at the first definition of <tt>abs-all</tt> above, you should be able
to derive, before studying it, the following definition of
<a name="./start:s148"></a><tt>map1</tt>, a restricted version of
<tt>map</tt> that maps a one-argument procedure over a single list.

<p>

<p><tt>(define&nbsp;map1<a name="defn:map1"></a><br>

&nbsp;&nbsp;(lambda&nbsp;(p&nbsp;ls)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(null?&nbsp;ls)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'()<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cons&nbsp;(p&nbsp;(car&nbsp;ls))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(map1&nbsp;p&nbsp;(cdr&nbsp;ls))))))</tt>
<p>
<p><tt>(map1&nbsp;abs&nbsp;'(1&nbsp;-2&nbsp;3&nbsp;-4&nbsp;5&nbsp;-6))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(1&nbsp;2&nbsp;3&nbsp;4&nbsp;5&nbsp;6)</tt>
<p>All we have done is to replace the call to <tt>abs</tt> in <tt>abs-all</tt>
with a call to the new parameter <tt>p</tt>.
A definition of the more general <tt>map</tt> is given in Section&nbsp;<a href="./control.html#g100">5.4</a>.


<p>

<h4>Exercise <a name="g33"></a>2.8.1</h4>
<a name="./start:s149"></a>Describe what would happen if you switched the order of the arguments
to <tt>cons</tt> in the definition of <tt>tree-copy</tt>.

<p>


<p>

<h4>Exercise <a name="g34"></a>2.8.2</h4>
<a name="./start:s150"></a>Consult Section&nbsp;<a href="./objects.html#g109">6.3</a> for the description of
<a name="./start:s151"></a><tt>append</tt> and
define a two-argument version of it.
What would happen if you switched the order of the arguments in the
call to <tt>append</tt> within your definition of <tt>append</tt>?

<p>


<p>

<h4>Exercise <a name="g35"></a>2.8.3</h4>
<a name="./start:s152"></a>Define the procedure <a name="./start:s153"></a><tt>make-list</tt>, which
takes a nonnegative integer
<tt><i>n</i></tt> and an object and returns a new list, <tt><i>n</i></tt> long, each
element of which is the object.

<p>

<p><tt>(make-list&nbsp;7&nbsp;'())&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(()&nbsp;()&nbsp;()&nbsp;()&nbsp;()&nbsp;()&nbsp;())</tt>
<p>[<i>Hint</i>: The base test should be <tt>(=&nbsp;<i>n</i>&nbsp;0)</tt>, and the recursion
step should involve <tt>(-&nbsp;<i>n</i>&nbsp;1)</tt>.
Whereas <tt>()</tt> is the natural base case for recursion on lists, 0
is the natural base case for recursion on nonnegative integers.
Similarly, subtracting 1 is the natural way to bring a nonnegative
integer closer to 0.]

<p>


<p>

<h4>Exercise <a name="g36"></a>2.8.4</h4>
<a name="./start:s154"></a>The procedures <tt>list-ref</tt> and <tt>list-tail</tt> return the
<i>n</i>th element and <i>n</i>th tail of a list <i>ls</i>.

<p>

<p><tt>(list-ref&nbsp;'(1&nbsp;2&nbsp;3&nbsp;4)&nbsp;0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;1<br>

(list-tail&nbsp;'(1&nbsp;2&nbsp;3&nbsp;4)&nbsp;0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(1&nbsp;2&nbsp;3&nbsp;4)<br>

(list-ref&nbsp;'(a&nbsp;short&nbsp;(nested)&nbsp;list)&nbsp;2)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(nested)<br>

(list-tail&nbsp;'(a&nbsp;short&nbsp;(nested)&nbsp;list)&nbsp;2)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;((nested)&nbsp;list)</tt>
<p>Define both procedures.

<p>


<p>

<h4>Exercise <a name="g37"></a>2.8.5</h4>
<a name="./start:s155"></a>Exercise&nbsp;<a href="./start.html#g31">2.7.2</a> had you use <tt>length</tt> in the definition
of <a name="./start:s156"></a><tt>shorter</tt>,
which returns the shorter of its two list arguments, or the first
if the two have the same length.
Write <tt>shorter</tt> without using <tt>length</tt>.
[<i>Hint</i>: Define a recursive helper,
<a name="./start:s157"></a><tt>shorter?</tt>, and use it
in place of the length comparison.]

<p>


<p>

<h4>Exercise <a name="g38"></a>2.8.6</h4>
<a name="./start:s158"></a><a name="EXEVENODD"></a>All of the recursive procedures shown so far have been directly recursive.
That is, each procedure directly applies itself to a new argument.
It is also possible to write two procedures that use each other, resulting
in indirect recursion.
Define the procedures <a name="./start:s159"></a><tt>odd?</tt> and <a name="./start:s160"></a><tt>even?</tt>, each in terms of the
other.
[<i>Hint</i>: What should each return when its argument is 0?]

<p>

<p><tt>(even?&nbsp;17)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(odd?&nbsp;17)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t</tt>
<p>


<p>

<h4>Exercise <a name="g39"></a>2.8.7</h4>
<a name="./start:s161"></a>Use <a name="./start:s162"></a><tt>map</tt> to define a procedure, <tt>transpose</tt>, that takes a list
of pairs and returns a pair of lists as follows.

<p>

<p><tt>(transpose&nbsp;'((a&nbsp;.&nbsp;1)&nbsp;(b&nbsp;.&nbsp;2)&nbsp;(c&nbsp;.&nbsp;3)))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;((a&nbsp;b&nbsp;c)&nbsp;1&nbsp;2&nbsp;3)</tt>
<p>[<i>Hint</i>: <tt>((a&nbsp;b&nbsp;c)&nbsp;1&nbsp;2&nbsp;3)</tt> is the same as
<tt>((a&nbsp;b&nbsp;c)&nbsp;.&nbsp;(1&nbsp;2&nbsp;3))</tt>.]

<p>


<p>

<h3><a name="g40"></a><a name="./start:h9"></a>Section 2.9. Assignment<a name="SECTGSASSIGNMENT"></a></h3>



<p>
Although many programs can be written without them, <a name="./start:s163"></a>assignments to top-level
<a name="./start:s164"></a>variables or <tt>let</tt>-bound and <tt>lambda</tt>-bound variables are sometimes useful.
Assignments do not create new bindings, as with <tt>let</tt> or
<tt>lambda</tt>, but rather change the values of existing bindings.
Assignments are performed with <a name="./start:s165"></a><tt>set!</tt>.

<p>

<p><tt>(define&nbsp;abcde&nbsp;'(a&nbsp;b&nbsp;c&nbsp;d&nbsp;e))<br>

abcde&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(a&nbsp;b&nbsp;c&nbsp;d&nbsp;e)<br>

(set!&nbsp;abcde&nbsp;(cdr&nbsp;abcde))<br>

abcde&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(b&nbsp;c&nbsp;d&nbsp;e)<br>

(let&nbsp;([abcde&nbsp;'(a&nbsp;b&nbsp;c&nbsp;d&nbsp;e)])<br>

&nbsp;&nbsp;(set!&nbsp;abcde&nbsp;(reverse&nbsp;abcde))<br>

&nbsp;&nbsp;abcde)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(e&nbsp;d&nbsp;c&nbsp;b&nbsp;a)</tt>
<p>Many languages require the use of assignments to initialize local
variables, separate from the declaration or binding of the variables.
In Scheme, all local variables are given a value immediately upon binding.
Besides making the separate assignment to initialize local variables
unnecessary, it ensures that the programmer cannot forget to initialize them,
a common source of errors in most languages.

<p>
In fact, most of the assignments that are either necessary or convenient in
other languages are both unnecessary and inconvenient in Scheme, since there
is typically a clearer way to express the same algorithm without assignments.
One common practice in some languages is to sequence expression evaluation
with a series of assignments, as in the following procedure that finds the
roots of a quadratic equation.

<p>

<p><tt>(define&nbsp;quadratic-formula<br>

&nbsp;&nbsp;(lambda&nbsp;(a&nbsp;b&nbsp;c)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([root1&nbsp;0]&nbsp;[root2&nbsp;0]&nbsp;[minusb&nbsp;0]&nbsp;[radical&nbsp;0]&nbsp;[divisor&nbsp;0])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set!&nbsp;minusb&nbsp;(-&nbsp;0&nbsp;b))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set!&nbsp;radical&nbsp;(sqrt&nbsp;(-&nbsp;(*&nbsp;b&nbsp;b)&nbsp;(*&nbsp;4&nbsp;(*&nbsp;a&nbsp;c)))))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set!&nbsp;divisor&nbsp;(*&nbsp;2&nbsp;a))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set!&nbsp;root1&nbsp;(/&nbsp;(+&nbsp;minusb&nbsp;radical)&nbsp;divisor))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set!&nbsp;root2&nbsp;(/&nbsp;(-&nbsp;minusb&nbsp;radical)&nbsp;divisor))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cons&nbsp;root1&nbsp;root2))))</tt>
<p>The roots are computed according to the well-known quadratic formula,

<p>
<p>
<img src="math/tspl/4.gif" alt="<graphic>"><p>


<p>
which yields the solutions to the equation 0 = <i>ax</i><sup>2</sup> + <i>bx</i> + <i>c</i>.
The <tt>let</tt> expression in this definition is employed solely to establish
the variable bindings, corresponding to the declarations required in other
languages.
The first three assignment expressions compute subpieces of the formula,
namely -<i>b</i>, <img src="math/tspl/5.gif" alt="<graphic>">, and 2<i>a</i>.
The last two assignment expressions compute the two roots in terms of the
subpieces.
A pair of the two roots is the value of <a name="./start:s166"></a><tt>quadratic-formula</tt>.
For example, the two roots of 2<i>x</i><sup>2</sup> - 4<i>x</i> - 6 are <i>x</i> = 3 and <i>x</i> = -1.

<p>

<p><tt>(quadratic-formula&nbsp;2&nbsp;-4&nbsp;-6)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(3&nbsp;.&nbsp;-1)</tt>
<p>The definition above works, but it can be written more clearly without the
assignments, as shown below.

<p>

<p><tt>(define&nbsp;quadratic-formula<br>

&nbsp;&nbsp;(lambda&nbsp;(a&nbsp;b&nbsp;c)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([minusb&nbsp;(-&nbsp;0&nbsp;b)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[radical&nbsp;(sqrt&nbsp;(-&nbsp;(*&nbsp;b&nbsp;b)&nbsp;(*&nbsp;4&nbsp;(*&nbsp;a&nbsp;c))))]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[divisor&nbsp;(*&nbsp;2&nbsp;a)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([root1&nbsp;(/&nbsp;(+&nbsp;minusb&nbsp;radical)&nbsp;divisor)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[root2&nbsp;(/&nbsp;(-&nbsp;minusb&nbsp;radical)&nbsp;divisor)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cons&nbsp;root1&nbsp;root2)))))</tt>
<p>In this version, the <tt>set!</tt> expressions are gone, and we are left with
essentially the same algorithm.
By employing two <tt>let</tt> expressions, however, the definition makes
clear the dependency of <tt>root1</tt> and <tt>root2</tt> on the values of
<tt>minusb</tt>, <tt>radical</tt>, and <tt>divisor</tt>.
Equally important, the <tt>let</tt> expressions make clear the <i>lack</i> of
dependencies among <tt>minusb</tt>, <tt>radical</tt>, and <tt>divisor</tt> and
between <tt>root1</tt> and <tt>root2</tt>.

<p>
<p>Assignments do have some uses in Scheme, otherwise the language
would not support them.
Consider the following version of <tt>cons</tt> that counts the number of times
it is called, storing the count in a variable named <tt>cons-count</tt>.
It uses <tt>set!</tt> to increment the count; there is no way to achieve the
same behavior without assignments.

<p>

<p><tt>(define&nbsp;kons-count&nbsp;0)<br>

(define&nbsp;kons<br>

&nbsp;&nbsp;(lambda&nbsp;(x&nbsp;y)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(set!&nbsp;kons-count&nbsp;(+&nbsp;kons-count&nbsp;1))<br>

&nbsp;&nbsp;&nbsp;&nbsp;(cons&nbsp;x&nbsp;y)))
<br>
<br>
(kons&nbsp;'a&nbsp;'(b&nbsp;c))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(a&nbsp;b&nbsp;c)<br>

kons-count&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;1<br>

(kons&nbsp;'a&nbsp;(kons&nbsp;'b&nbsp;(kons&nbsp;'c&nbsp;'())))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(a&nbsp;b&nbsp;c)<br>

kons-count&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;4</tt>
<p>Assignments are commonly used to implement procedures that must maintain
some <a name="./start:s167"></a>internal state.
For example, suppose we would like to define a procedure that returns
0 the first time it is called, 1 the second time, 2 the third time,
and so on indefinitely.
We could write something similar to the definition of <tt>cons-count</tt>
above:

<p>

<p><tt>(define&nbsp;next&nbsp;0)<br>

(define&nbsp;count<br>

&nbsp;&nbsp;(lambda&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([v&nbsp;next])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set!&nbsp;next&nbsp;(+&nbsp;next&nbsp;1))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v)))
<br>
<br>
(count)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;0<br>

(count)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;1</tt>
<p>This solution is somewhat undesirable in that the variable <tt>next</tt> is visible
at top level even though it need not be.
Since it is visible at top level, any code in the system can change its
value, perhaps inadvertently affecting the behavior of
<tt>count</tt> in a subtle way.
We can solve this problem by <tt>let</tt>-binding <tt>next</tt> outside of the
<tt>lambda</tt> expression:

<p>

<p><tt>(define&nbsp;count<br>

&nbsp;&nbsp;(let&nbsp;([next&nbsp;0])<br>

&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([v&nbsp;next])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set!&nbsp;next&nbsp;(+&nbsp;next&nbsp;1))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v))))</tt>
<p>The latter solution also generalizes easily to provide multiple counters,
each with its own local counter.
The procedure <a name="./start:s168"></a><tt>make-counter</tt>, defined below, returns a new counting
procedure each time it is called.

<p>

<p><tt>(define&nbsp;make-counter<br>

&nbsp;&nbsp;(lambda&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([next&nbsp;0])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([v&nbsp;next])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set!&nbsp;next&nbsp;(+&nbsp;next&nbsp;1))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v)))))</tt>
<p>Since <tt>next</tt> is bound inside of <tt>make-counter</tt> but outside of
the procedure returned by <tt>make-counter</tt>, each procedure it returns
maintains its own unique counter.

<p>

<p><tt>(define&nbsp;count1&nbsp;(make-counter))<br>

(define&nbsp;count2&nbsp;(make-counter))
<br>
<br>
(count1)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;0<br>

(count2)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;0<br>

(count1)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;1<br>

(count1)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;2<br>

(count2)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;1</tt>
<p>If a state variable must be shared by more than one
procedure defined at top level, but we do not want the state
variable to be visible at top level, we can use <tt>let</tt>
to bind the variable and <tt>set!</tt> to make the procedures
visible at top level.<a name="./start:s169"></a><a name="./start:s170"></a>

<p>

<p><tt>(define&nbsp;shhh&nbsp;#f)<br>

(define&nbsp;tell&nbsp;#f)<br>

(let&nbsp;([secret&nbsp;0])<br>

&nbsp;&nbsp;(set!&nbsp;shhh<br>

&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(message)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set!&nbsp;secret&nbsp;message)))<br>

&nbsp;&nbsp;(set!&nbsp;tell<br>

&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;secret)))
<br>
<br>
(shhh&nbsp;"sally&nbsp;likes&nbsp;harry")<br>

(tell)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;"sally&nbsp;likes&nbsp;harry"<br>

secret&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;<i>exception:&nbsp;variable&nbsp;secret&nbsp;is&nbsp;not&nbsp;bound</i></tt>
<p>Variables must be defined
before they can be assigned, so we define 
<tt>shhh</tt> and <tt>tell</tt> to be
<tt>#f</tt> initially.
(Any initial value would do.)
We'll see this structure again in Section&nbsp;<a href="./further.html#g79">3.5</a>
and a better way to structure code like this as a library in
Section&nbsp;<a href="./further.html#g84">3.6</a>.

<p>
<a name="./start:s171"></a>Local state is sometimes useful for caching
computed values or allowing a computation to be
evaluated <i>lazily</i>, i.e., only once and only on demand.
The procedure <a name="./start:s172"></a><tt>lazy</tt> below accepts a
<a name="./start:s173"></a><i>thunk</i>, or
zero-argument procedure, as an argument.
Thunks are often used to "freeze" computations that must be
delayed for some reason, which is exactly what we need to do in
this situation.
When passed a thunk <tt><i>t</i></tt>, <tt>lazy</tt> returns a new thunk that, when
invoked, returns the value of invoking <tt><i>t</i></tt>.
Once computed, the value is saved in a local variable so that the
computation need not be performed again.
A boolean flag is used to record whether <tt><i>t</i></tt> has been
invoked and its value saved.

<p>

<p><tt>(define&nbsp;lazy<br>

&nbsp;&nbsp;(lambda&nbsp;(t)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([val&nbsp;#f]&nbsp;[flag&nbsp;#f])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(not&nbsp;flag)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(begin&nbsp;(set!&nbsp;val&nbsp;(t))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set!&nbsp;flag&nbsp;#t)))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val))))</tt>
<p>The syntactic form <a name="./start:s174"></a><tt>begin</tt>, used here for the first time, evaluates
its subexpressions in sequence from left to right and returns the value
of the last subexpression,
like the body of a <tt>let</tt> or <tt>lambda</tt> expression.
We also see that the <tt><i>alternative</i></tt> subexpression of an <a name="./start:s175"></a><tt>if</tt>
expression can be omitted.
This should be done only when the value of the <tt>if</tt> is discarded, as
it is in this case.

<p>
Lazy evaluation is especially useful for values that require
considerable time to compute.
By delaying the evaluation, we might avoid computing the value
altogether, and by saving the value, we avoid computing it
more than once.

<p>
The operation of <tt>lazy</tt> can best be illustrated by printing a
message from within a thunk passed to <tt>lazy</tt>.

<p>

<p><tt>(define&nbsp;p<br>

&nbsp;&nbsp;(lazy&nbsp;(lambda&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(display&nbsp;"Ouch!")<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(newline)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"got&nbsp;me")))</tt>
<p>The first time <tt>p</tt> is invoked, the message <tt>Ouch!</tt> is printed
and the string <tt>"got&nbsp;me"</tt> is returned.
Thereafter, <tt>"got&nbsp;me"</tt> is returned but the message is not printed.
The procedures <tt>display</tt> and <tt>newline</tt> are the first examples
of explicit input/output we have seen; <tt>display</tt> prints the string
without quotation marks, and <tt>newline</tt> prints a newline character.

<p>
To further illustrate the use of <tt>set!</tt>,
let's consider the implementation of <a name="./start:s176"></a>stack objects whose
internal workings are not visible on the outside.
A stack object accepts one of four <a name="./start:s177"></a><i>messages</i>: <tt>empty?</tt>, which
returns <tt>#t</tt> if the stack is empty; <tt>push!</tt>, which adds an object
to the top of the stack; <tt>top</tt>, which returns the object on the top of
the stack; and <tt>pop!</tt>, which removes the object on top of the stack.
The procedure <a name="./start:s178"></a><tt>make-stack</tt> given below creates a new stack each time
it is called in a manner similar to <tt>make-counter</tt>.

<p>

<p><tt>(define&nbsp;make-stack<br>

&nbsp;&nbsp;(lambda&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([ls&nbsp;'()])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(msg&nbsp;.&nbsp;args)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cond<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(eqv?&nbsp;msg&nbsp;'empty?)&nbsp;(null?&nbsp;ls)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(eqv?&nbsp;msg&nbsp;'push!)&nbsp;(set!&nbsp;ls&nbsp;(cons&nbsp;(car&nbsp;args)&nbsp;ls))]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(eqv?&nbsp;msg&nbsp;'top)&nbsp;(car&nbsp;ls)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(eqv?&nbsp;msg&nbsp;'pop!)&nbsp;(set!&nbsp;ls&nbsp;(cdr&nbsp;ls))]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[else&nbsp;"oops"])))))</tt>
<p>Each stack is stored as a list bound to the variable <tt>ls</tt>; <tt>set!</tt>
is used to change this binding for <tt>push!</tt> and <tt>pop!</tt>.
Notice that the argument list of the inner <tt>lambda</tt> expression uses the
improper list syntax to bind <tt>args</tt> to a list of all arguments but the
first.
This is useful here because in the case of <tt>empty?</tt>, <tt>top</tt>, and
<tt>pop!</tt> there is only one argument (the message), but in the case of
<tt>push!</tt> there are two (the message and the object to push onto the
stack).

<p>

<p><tt>(define&nbsp;stack1&nbsp;(make-stack))<br>

(define&nbsp;stack2&nbsp;(make-stack))<br>

(list&nbsp;(stack1&nbsp;'empty?)&nbsp;(stack2&nbsp;'empty?))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(#t&nbsp;#t)
<br>
<br>
(stack1&nbsp;'push!&nbsp;'a)<br>

(list&nbsp;(stack1&nbsp;'empty?)&nbsp;(stack2&nbsp;'empty?))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(#f&nbsp;#t)
<br>
<br>
(stack1&nbsp;'push!&nbsp;'b)<br>

(stack2&nbsp;'push!&nbsp;'c)<br>

(stack1&nbsp;'top)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;b<br>

(stack2&nbsp;'top)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;c
<br>
<br>
(stack1&nbsp;'pop!)<br>

(stack1&nbsp;'top)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;a<br>

(list&nbsp;(stack1&nbsp;'empty?)&nbsp;(stack2&nbsp;'empty?))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(#f&nbsp;#f)
<br>
<br>
(stack1&nbsp;'pop!)<br>

(list&nbsp;(stack1&nbsp;'empty?)&nbsp;(stack2&nbsp;'empty?))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(#t&nbsp;#f)</tt>
<p>As with the counters created by <tt>make-counter</tt>, the state maintained
by each stack object is directly accessible only within the object.
Each reference or change to this state is made explicitly by the object
itself.
One important benefit is that we can change the internal structure
of the stack, perhaps to use a vector (see Section&nbsp;<a href="./objects.html#g115">6.9</a>) instead
of a list to hold the elements,
without changing its external behavior.
Because the behavior of the object is known abstractly (not operationally),
it is known as an <i>abstract object</i>.
See Section&nbsp;<a href="./examples.html#g193">12.8</a> for more about creating <a name="./start:s179"></a>abstract objects.

<p>
In addition to changing the values of variables, we can also change
the values of the car and cdr fields of a pair, using the procedures
<tt>set-car!</tt> and <tt>set-cdr!</tt>.

<p>

<p><tt>(define&nbsp;p&nbsp;(list&nbsp;1&nbsp;2&nbsp;3))<br>

(set-car!&nbsp;(cdr&nbsp;p)&nbsp;'two)<br>

p&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(1&nbsp;two&nbsp;3)<br>

(set-cdr!&nbsp;p&nbsp;'())<br>

p&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(1)</tt>
<p><a name="queue-datatype"></a><a name="./start:s180"></a>We can use these operators to define a queue
data type, which is like a stack except that new elements are added at
one end and extracted from the other.
The following queue implementation uses a <a name="./start:s181"></a><i>tconc</i>
structure.
A tconc consists of a nonempty list and a header.
The header is a pair whose car points to the first pair (head) of the
list and whose cdr points to the last pair (end) of the list.

<p>
<p>
<img src="math/tspl/6.gif" alt="<graphic>"><p>


<p>
The last element of the list is a placeholder and not considered part
of the queue.

<p>
Four operations on queues are defined below:
<a name="./start:s182"></a><tt>make-queue</tt>, which constructs a queue;
<a name="./start:s183"></a><tt>putq!</tt>, which adds an element to the end
of a queue;
<a name="./start:s184"></a><tt>getq</tt>, which retrieves the element at the
front of a queue; and
<a name="./start:s185"></a><tt>delq!</tt>, which removes the element at the
front of a queue.

<p>

<p><tt>(define&nbsp;make-queue<br>

&nbsp;&nbsp;(lambda&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([end&nbsp;(cons&nbsp;'ignored&nbsp;'())])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cons&nbsp;end&nbsp;end))))
<br>
<br>
(define&nbsp;putq!<br>

&nbsp;&nbsp;(lambda&nbsp;(q&nbsp;v)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([end&nbsp;(cons&nbsp;'ignored&nbsp;'())])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set-car!&nbsp;(cdr&nbsp;q)&nbsp;v)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set-cdr!&nbsp;(cdr&nbsp;q)&nbsp;end)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set-cdr!&nbsp;q&nbsp;end))))
<br>
<br>
(define&nbsp;getq<br>

&nbsp;&nbsp;(lambda&nbsp;(q)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(car&nbsp;(car&nbsp;q))))
<br>
<br>
(define&nbsp;delq!<br>

&nbsp;&nbsp;(lambda&nbsp;(q)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(set-car!&nbsp;q&nbsp;(cdr&nbsp;(car&nbsp;q)))))</tt>
<p>All are simple operations except for <tt>putq!</tt>, which modifies the
end pair to contain the new value and adds a new end pair.

<p>

<p><tt>(define&nbsp;myq&nbsp;(make-queue))
<br>
<br>
(putq!&nbsp;myq&nbsp;'a)<br>

(putq!&nbsp;myq&nbsp;'b)<br>

(getq&nbsp;myq)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;a<br>

(delq!&nbsp;myq)<br>

(getq&nbsp;myq)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;b<br>

(delq!&nbsp;myq)<br>

(putq!&nbsp;myq&nbsp;'c)<br>

(putq!&nbsp;myq&nbsp;'d)<br>

(getq&nbsp;myq)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;c<br>

(delq!&nbsp;myq)<br>

(getq&nbsp;myq)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;d</tt>
<p>
<h4>Exercise <a name="g41"></a>2.9.1</h4>
<a name="./start:s186"></a>Modify <a name="./start:s187"></a><tt>make-counter</tt> to take two
arguments: an initial value for the
counter to use in place of 0 and an amount to increment the counter
by each time.

<p>


<p>

<h4>Exercise <a name="g42"></a>2.9.2</h4>
<a name="./start:s188"></a>Look up the description of <a name="./start:s189"></a><tt>case</tt> in Section&nbsp;<a href="./control.html#g99">5.3</a>.
Replace the <tt>cond</tt> expression in
<a name="./start:s190"></a><tt>make-stack</tt> with an equivalent
<tt>case</tt> expression.
Add <tt>mt?</tt> as a second name for the <tt>empty?</tt> message.

<p>


<p>

<h4>Exercise <a name="g43"></a>2.9.3</h4>
<a name="./start:s191"></a><a name="EXSTACKREFANDSET"></a>Modify the <tt>stack</tt> object to allow the two messages <tt>ref</tt> and
<tt>set!</tt>.
<tt>(<i>stack</i>&nbsp;'ref&nbsp;<i>i</i>)</tt> should return the <tt><i>i</i></tt>th element from
the top of the stack; <tt>(<i>stack</i>&nbsp;'ref&nbsp;0)</tt> should be equivalent
to <tt>(<i>stack</i>&nbsp;'top)</tt>.
<tt>(<i>stack</i>&nbsp;'set!&nbsp;<i>i</i>&nbsp;<i>v</i>)</tt> should change the <tt><i>i</i></tt>th
element from the top of the stack to <tt><i>v</i></tt>.

<p>

<p><tt>(define&nbsp;stack&nbsp;(make-stack))
<br>
<br>
(stack&nbsp;'push!&nbsp;'a)<br>

(stack&nbsp;'push!&nbsp;'b)<br>

(stack&nbsp;'push!&nbsp;'c)
<br>
<br>
(stack&nbsp;'ref&nbsp;0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;c<br>

(stack&nbsp;'ref&nbsp;2)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;a<br>

(stack&nbsp;'set!&nbsp;1&nbsp;'d)<br>

(stack&nbsp;'ref&nbsp;1)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;d<br>

(stack&nbsp;'top)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;c<br>

(stack&nbsp;'pop!)<br>

(stack&nbsp;'top)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;d</tt>
<p>[<i>Hint</i>: Use <tt>list-ref</tt> to implement <tt>ref</tt> and <tt>list-tail</tt>
with <tt>set-car!</tt> to implement <tt>set!</tt>.]

<p>


<p>

<h4>Exercise <a name="g44"></a>2.9.4</h4>
<a name="./start:s192"></a><a name="./start:s193"></a>Scheme supports <i>vectors</i> as well as lists.
Like lists, vectors are aggregate objects that contain other
objects.
Unlike lists, vectors have a fixed size and are laid out
in one flat block of memory, typically with a header containing
the length of the vector, as in the ten-element vector below.

<p>
<p>
<img src="math/tspl/7.gif" alt="<graphic>"><p>


<p>
This makes vectors more suitable for applications needing
fast access to any element of the aggregate but less suitable for
applications needing data structures that grow and shrink
as needed.

<p>
Look up the basic vector operations in
Section&nbsp;<a href="./objects.html#g115">6.9</a> and reimplement the
<tt>stack</tt> object to use a vector instead of a list to hold
the stack contents.
Include the <tt>ref</tt> and <tt>set!</tt> messages of
Exercise&nbsp;<a href="./start.html#g43">2.9.3</a>.
Have the new <tt>make-stack</tt> accept a size argument <i>n</i>
and make the vector length <i>n</i>, but do not otherwise change
the external (abstract) interface.

<p>


<p>

<h4>Exercise <a name="g45"></a>2.9.5</h4>
<a name="./start:s194"></a>Define a predicate, <tt>emptyq?</tt>, for determining if a queue is empty.
Modify <tt>getq</tt> and <tt>delq!</tt> to raise an exception when an empty
queue is found, using <tt>assertion-violation</tt>.

<p>



<p>

<h4>Exercise <a name="g46"></a>2.9.6</h4>
<a name="./start:s195"></a>In the queue implementation, the last pair in the encapsulated
list is a placeholder, i.e., it never holds anything useful.
Recode the queue operators to avoid this wasted pair.
Make sure that the series of queue operations given earlier
works with the new implementation.
Which implementation do you prefer?

<p>


<p>

<h4>Exercise <a name="g47"></a>2.9.7</h4>
<a name="./start:s196"></a>Using <a name="./start:s197"></a><tt>set-cdr!</tt>, it is possible to create <a name="./start:s198"></a><i>cyclic lists</i>.
For example, the following expression evaluates to a list whose
car is the symbol <tt>a</tt> and whose cdr is the list itself.

<p>

<p><tt>(let&nbsp;([ls&nbsp;(cons&nbsp;'a&nbsp;'())])<br>

&nbsp;&nbsp;(set-cdr!&nbsp;ls&nbsp;ls)<br>

&nbsp;&nbsp;ls)</tt>
<p>What happens when you enter the above expression during an interactive
Scheme session?
What will the implementation of <tt>length</tt> on page&nbsp;<a href="./start.html#defn:simplelength">42</a>
do when given a cyclic list?
What does the built-in <tt>length</tt> primitive do?

<p>



<p>

<h4>Exercise <a name="g48"></a>2.9.8</h4>
<a name="./start:s199"></a><a name="EXLIST?"></a>Define the predicate <a name="./start:s200"></a><tt>list?</tt>, which returns
<tt>#t</tt> if its argument is a <a name="./start:s201"></a>proper list and <tt>#f</tt> otherwise
(see Section&nbsp;<a href="./objects.html#g109">6.3</a>).
It should return <tt>#f</tt> for cyclic lists as well as for lists
terminated by objects other than <tt>()</tt>.

<p>

<p><tt>(list?&nbsp;'())&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(list?&nbsp;'(1&nbsp;2&nbsp;3))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(list?&nbsp;'(a&nbsp;.&nbsp;b))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(list?&nbsp;(let&nbsp;([ls&nbsp;(cons&nbsp;'a&nbsp;'())])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set-cdr!&nbsp;ls&nbsp;ls)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ls))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f</tt>
<p>First write a simplified version of <tt>list?</tt> that does not handle
cyclic lists, then extend this to handle cyclic lists correctly.
Revise your definition until you are satisfied that it is as clear
and concise as possible.
[<i>Hint</i>: Use the following "<a name="./start:s202"></a>hare and tortoise" algorithm to
detect cycles.
Define a recursive help procedure of two arguments, the hare and the tortoise.
Start both the hare and the tortoise at the beginning of the list.
Have the hare advance by two cdrs each time the tortoise
advances by one cdr.
If the hare catches the tortoise, there must be a cycle.]

<p>


<p>




<hr class=copyright align=left>
<p>
R. Kent Dybvig / <it>The Scheme Programming Language, Fourth Edition</it><br>
Copyright &copy; 2009 <a class=plain href="http://mitpress.mit.edu/catalog/item/default.asp?ttype=2&tid=11984">The MIT Press</a>.  Electronically reproduced by permission.<br>
Illustrations &copy; 2009 <a class=plain href="http://hebert.kitp.ucsb.edu/">Jean-Pierre H&eacute;bert</a><br>
ISBN 978-0-262-51298-5 / LOC QA76.73.S34D93<br>
<a class=plain href="http://mitpress.mit.edu/catalog/item/default.asp?ttype=2&tid=11984">to order this book</a> / <a class=plain href="canned/about.html">about this book</a>
</p>
<p><a class=plain href="http://www.scheme.com">http://www.scheme.com</a></p>
</body>
</html>
