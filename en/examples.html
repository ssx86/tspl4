<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
  "http://www.w3.org/TR/html4/loose.dtd"><!-- DO NOT EDIT THIS FILE-->
<!-- Edit the .tex version instead-->

<html>
<head>
<title>Extended Examples</title>
<link href="tspl.css" rel="stylesheet" type="text/css">
</head>
<body>
<a name="g151"></a>
<a name="./examples:h0"></a>

<div style="font-size: 12px; width: 500px; height: 500px; border: solid thin">
<img style="padding: 20px 10px 20px 20px" src="canned/ch12.png"><img src="canned/jph.png">
</div>
<h1>Chapter 12. Extended Examples<a name="CHPTEXAMPLES"></a></h1>





<p>
<a name="./examples:s0"></a>This chapter presents a series of programs
that perform more complicated tasks than most of the examples
found throughout the earlier chapters of the book.
They illustrate a variety of programming techniques and demonstrate a
particular programming style.

<p>
Each section of this chapter describes one program in detail and gives
examples of its use.
This is followed by a listing of the code.
At the end of each section are exercises intended to stimulate thought
about the program and to suggest possible extensions.
These exercises are generally more difficult than those found in
Chapters&nbsp;<a href="./start.html#g4">2</a> and&nbsp;<a href="./further.html#g49">3</a>, and a few
are major projects.

<p>
Section <a href="./examples.html#g152">12.1</a> presents a simple matrix multiplication
package.
It demonstrates a set of procedures that could be written in almost any
language.
Its most interesting features are that all multiplication operations
are performed by calling a single <i>generic</i> procedure,
<tt>mul</tt>, which calls the appropriate help procedure depending upon
the dimensions of its arguments, and that it dynamically allocates
results of the proper size.
Section <a href="./examples.html#g158">12.2</a> presents a merge sorting
algorithm for ordering lists according to arbitrary predicates.
Section <a href="./examples.html#g162">12.3</a> describes a syntactic form that is used to
construct sets.
It demonstrates a simple but efficient syntactic transformation from
set notation to Scheme code.
Section <a href="./examples.html#g169">12.4</a> presents a word-counting program borrowed
from <i>The C Programming Language</i>&nbsp;[<a class=citation href="./bibliography.html#g237">19</a>], translated
from C into Scheme.
It shows character and string manipulation, data structure creation and
manipulation, and basic file input and output.
Section <a href="./examples.html#g176">12.5</a> presents a Scheme printer that implements
basic versions of <tt>put-datum</tt>, <tt>write</tt>, and
<tt>display</tt>.
Section <a href="./examples.html#g180">12.6</a> presents a simple formatted output facility
similar to those found in many Scheme systems and in other languages.
Section <a href="./examples.html#g187">12.7</a> presents a simple interpreter for
Scheme that illustrates Scheme as a language implementation vehicle while
giving an informal operational semantics for Scheme as well as a useful
basis for investigating extensions to Scheme.
Section <a href="./examples.html#g193">12.8</a> presents a small, extensible abstract
object facility that could serve as the basis for an entire
object-oriented subsystem.
Section <a href="./examples.html#g198">12.9</a> presents a recursive algorithm for computing
the Fourier transform of a sequence of input values.
It highlights the use of Scheme's complex arithmetic.
Section <a href="./examples.html#g204">12.10</a> presents a concise unification algorithm
that shows how procedures can be used as continuations and as
substitutions (unifiers) in Scheme.
Section <a href="./examples.html#g208">12.11</a> describes a multitasking facility and its
implementation in terms of continuations.


<p>

<h3><a name="g152"></a><a name="./examples:h1"></a>Section 12.1. Matrix and Vector Multiplication<a name="SECTEXMATMUL"></a></h3>



<p>
<a name="./examples:s1"></a>This example program involves mostly basic
programming techniques.
It demonstrates simple arithmetic and vector operations, looping
with the <tt>do</tt> syntactic form, dispatching based on object type,
and raising exceptions.

<p>
Multiplication of scalar to scalar, scalar to matrix, or matrix to
matrix is performed by a single <i>generic</i> procedure, called
<a name="./examples:s2"></a><tt>mul</tt>.
<tt>mul</tt> is called with two arguments, and it decides based
on the types of its arguments what operation to perform.
Because scalar operations use Scheme's multiplication procedure,
<tt>*</tt>, <tt>mul</tt> scalars can be any built-in numeric type (exact or inexact
complex, real, rational, or integer).

<p>
The product of an <i>m</i> &times; <i>n</i> matrix <i>A</i> and an <i>n</i> &times; <i>p</i> matrix <i>B</i>
is the <i>m</i> &times; <i>p</i> matrix <i>C</i> whose entries are defined by

<p>
<p>
<img src="math/tspl/26.gif" alt="<graphic>"><p>


<p>
The product of a scalar <i>x</i> and an <i>m</i> &times; <i>n</i> matrix <i>A</i> is the
<i>m</i> &times; <i>n</i> matrix <i>C</i> whose entries are defined by the equation

<p>
<p>
<i>C</i><sub><i>ij</i></sub> = <i>xA</i><sub><i>ij</i></sub>.<p>


<p>
That is, each element of <i>C</i> is the product of <i>x</i> and the corresponding
element of <i>A</i>.
Vector-vector, vector-matrix, and matrix-vector multiplication may be
considered special cases of matrix-matrix multiplication, where a
vector is  represented as a 1 &times; <i>n</i> or <i>n</i> &times; 1 matrix.

<p>
Here are a few examples, each preceded by the equivalent operation
in standard mathematical notation.

<p>
<ul>
<li>Scalar times scalar:

<p>
<p>
3 &times; 4 = 12<p>


<p>

<p><tt>(mul&nbsp;3&nbsp;4)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;12</tt>
<p><li>Scalar times vector (1 &times; 3 matrix):

<p>
<p>
<img src="math/tspl/27.gif" alt="<graphic>"><p>


<p>

<p><tt>(mul&nbsp;1/2&nbsp;'#(#(1&nbsp;2&nbsp;3)))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#(#(1/2&nbsp;1&nbsp;3/2))</tt>
<p><li>Scalar times matrix:

<p>
<p>
<img src="math/tspl/28.gif" alt="<graphic>"><p>


<p>

<p><tt>(mul&nbsp;-2<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'#(#(3&nbsp;-2&nbsp;-1)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#(-3&nbsp;0&nbsp;-5)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#(7&nbsp;-1&nbsp;-1)))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#(#(-6&nbsp;4&nbsp;2)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="gifs/ghostRightarrow.gif">&nbsp;&nbsp;&nbsp;#(6&nbsp;0&nbsp;10)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="gifs/ghostRightarrow.gif">&nbsp;&nbsp;&nbsp;#(-14&nbsp;2&nbsp;2))</tt>
<p><li>Vector times matrix:

<p>
<p>
<img src="math/tspl/29.gif" alt="<graphic>"><p>


<p>

<p><tt>(mul&nbsp;'#(#(1&nbsp;2&nbsp;3))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'#(#(2&nbsp;3)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#(3&nbsp;4)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#(4&nbsp;5)))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#(#(20&nbsp;26))</tt>
<p><li>Matrix times vector:

<p>
<p>
<img src="math/tspl/30.gif" alt="<graphic>"><p>


<p>

<p><tt>(mul&nbsp;'#(#(2&nbsp;3&nbsp;4)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#(3&nbsp;4&nbsp;5))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'#(#(1)&nbsp;#(2)&nbsp;#(3)))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#(#(20)&nbsp;#(26))</tt>
<p><li>Matrix times matrix:

<p>
<p>
<img src="math/tspl/31.gif" alt="<graphic>"><p>


<p>

<p><tt>(mul&nbsp;'#(#(1&nbsp;2&nbsp;3)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#(4&nbsp;5&nbsp;6))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'#(#(1&nbsp;2&nbsp;3&nbsp;4)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#(2&nbsp;3&nbsp;4&nbsp;5)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#(3&nbsp;4&nbsp;5&nbsp;6)))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#(#(14&nbsp;20&nbsp;26&nbsp;32)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="gifs/ghostRightarrow.gif">&nbsp;&nbsp;&nbsp;#(32&nbsp;47&nbsp;62&nbsp;77))</tt>
<p></ul>
<p>

<p>
The code for <tt>mul</tt> and its helpers, which is structured as
a library, appears below.
The first few definitions establish a set of procedures that support
the matrix data type.
A matrix is a vector of <a name="./examples:s3"></a>vectors.
Included are a procedure to create matrices, procedures to access and
assign matrix elements, and a matrix predicate.
Following these definitions is the definition of <tt>mul</tt> itself.
Inside the <tt>lambda</tt> expression for <tt>mul</tt> are a set of definitions
for help procedures that support <tt>mul</tt>.

<p>
<tt>mul</tt> checks the types of its arguments and
chooses the appropriate help procedure to do the work.
Each helper operates on arguments of specific types.
For example, <tt>mat-sca-mul</tt> multiplies a matrix by a scalar.
If the type of either argument is invalid or the arguments are
incompatible, e.g., rows or columns do not match up, <tt>mul</tt> or one
of its helpers raises an exception.

<p>

<p><tt>
(library&nbsp;(tspl&nbsp;matrix)<br>

&nbsp;&nbsp;(export&nbsp;make-matrix&nbsp;matrix?&nbsp;matrix-rows&nbsp;matrix-columns<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;matrix-ref&nbsp;matrix-set!&nbsp;mul)<br>

&nbsp;&nbsp;(import&nbsp;(rnrs))
<br>
<br>
&nbsp;;&nbsp;make-matrix&nbsp;creates&nbsp;a&nbsp;matrix&nbsp;(a&nbsp;vector&nbsp;of&nbsp;vectors).<br>

&nbsp;&nbsp;(define&nbsp;make-matrix<br>

&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(rows&nbsp;columns)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(do&nbsp;([m&nbsp;(make-vector&nbsp;rows)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[i&nbsp;0&nbsp;(+&nbsp;i&nbsp;1)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((=&nbsp;i&nbsp;rows)&nbsp;m)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(vector-set!&nbsp;m&nbsp;i&nbsp;(make-vector&nbsp;columns)))))
<br>
<br>
&nbsp;;&nbsp;matrix?&nbsp;checks&nbsp;to&nbsp;see&nbsp;if&nbsp;its&nbsp;argument&nbsp;is&nbsp;a&nbsp;matrix.<br>

&nbsp;;&nbsp;It&nbsp;isn't&nbsp;foolproof,&nbsp;but&nbsp;it's&nbsp;generally&nbsp;good&nbsp;enough.<br>

&nbsp;&nbsp;(define&nbsp;matrix?<br>

&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(and&nbsp;(vector?&nbsp;x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(&gt;&nbsp;(vector-length&nbsp;x)&nbsp;0)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(vector?&nbsp;(vector-ref&nbsp;x&nbsp;0)))))
<br>
<br>
&nbsp;;&nbsp;matrix-rows&nbsp;returns&nbsp;the&nbsp;number&nbsp;of&nbsp;rows&nbsp;in&nbsp;a&nbsp;matrix.<br>

&nbsp;&nbsp;(define&nbsp;matrix-rows<br>

&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(vector-length&nbsp;x)))
<br>
<br>
&nbsp;;&nbsp;matrix-columns&nbsp;returns&nbsp;the&nbsp;number&nbsp;of&nbsp;columns&nbsp;in&nbsp;a&nbsp;matrix.<br>

&nbsp;&nbsp;(define&nbsp;matrix-columns<br>

&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(vector-length&nbsp;(vector-ref&nbsp;x&nbsp;0))))
<br>
<br>
&nbsp;;&nbsp;matrix-ref&nbsp;returns&nbsp;the&nbsp;jth&nbsp;element&nbsp;of&nbsp;the&nbsp;ith&nbsp;row.<br>

&nbsp;&nbsp;(define&nbsp;matrix-ref<br>

&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(m&nbsp;i&nbsp;j)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(vector-ref&nbsp;(vector-ref&nbsp;m&nbsp;i)&nbsp;j)))
<br>
<br>
&nbsp;;&nbsp;matrix-set!&nbsp;changes&nbsp;the&nbsp;jth&nbsp;element&nbsp;of&nbsp;the&nbsp;ith&nbsp;row.<br>

&nbsp;&nbsp;(define&nbsp;matrix-set!<br>

&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(m&nbsp;i&nbsp;j&nbsp;x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(vector-set!&nbsp;(vector-ref&nbsp;m&nbsp;i)&nbsp;j&nbsp;x)))
<br>
<br>
&nbsp;;&nbsp;mat-sca-mul&nbsp;multiplies&nbsp;a&nbsp;matrix&nbsp;by&nbsp;a&nbsp;scalar.<br>

&nbsp;&nbsp;(define&nbsp;mat-sca-mul<br>

&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(m&nbsp;x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let*&nbsp;([nr&nbsp;(matrix-rows&nbsp;m)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[nc&nbsp;(matrix-columns&nbsp;m)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[r&nbsp;(make-matrix&nbsp;nr&nbsp;nc)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(do&nbsp;([i&nbsp;0&nbsp;(+&nbsp;i&nbsp;1)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((=&nbsp;i&nbsp;nr)&nbsp;r)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(do&nbsp;([j&nbsp;0&nbsp;(+&nbsp;j&nbsp;1)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((=&nbsp;j&nbsp;nc))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(matrix-set!&nbsp;r&nbsp;i&nbsp;j&nbsp;(*&nbsp;x&nbsp;(matrix-ref&nbsp;m&nbsp;i&nbsp;j))))))))
<br>
<br>
&nbsp;;&nbsp;mat-mat-mul&nbsp;multiplies&nbsp;one&nbsp;matrix&nbsp;by&nbsp;another,&nbsp;after&nbsp;verifying<br>

&nbsp;;&nbsp;that&nbsp;the&nbsp;first&nbsp;matrix&nbsp;has&nbsp;as&nbsp;many&nbsp;columns&nbsp;as&nbsp;the&nbsp;second<br>

&nbsp;;&nbsp;matrix&nbsp;has&nbsp;rows.<br>

&nbsp;&nbsp;(define&nbsp;mat-mat-mul<br>

&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(m1&nbsp;m2)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let*&nbsp;([nr1&nbsp;(matrix-rows&nbsp;m1)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[nr2&nbsp;(matrix-rows&nbsp;m2)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[nc2&nbsp;(matrix-columns&nbsp;m2)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[r&nbsp;(make-matrix&nbsp;nr1&nbsp;nc2)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(unless&nbsp;(=&nbsp;(matrix-columns&nbsp;m1)&nbsp;nr2)&nbsp;(match-error&nbsp;m1&nbsp;m2))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(do&nbsp;([i&nbsp;0&nbsp;(+&nbsp;i&nbsp;1)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((=&nbsp;i&nbsp;nr1)&nbsp;r)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(do&nbsp;([j&nbsp;0&nbsp;(+&nbsp;j&nbsp;1)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((=&nbsp;j&nbsp;nc2))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(do&nbsp;([k&nbsp;0&nbsp;(+&nbsp;k&nbsp;1)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[a&nbsp;0&nbsp;(+&nbsp;a<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;(matrix-ref&nbsp;m1&nbsp;i&nbsp;k)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(matrix-ref&nbsp;m2&nbsp;k&nbsp;j)))])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((=&nbsp;k&nbsp;nr2)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(matrix-set!&nbsp;r&nbsp;i&nbsp;j&nbsp;a))))))))
<br>
<br>
&nbsp;;&nbsp;type-error&nbsp;is&nbsp;called&nbsp;to&nbsp;complain&nbsp;when&nbsp;mul&nbsp;receives&nbsp;an&nbsp;invalid<br>

&nbsp;;&nbsp;type&nbsp;of&nbsp;argument.<br>

&nbsp;&nbsp;(define&nbsp;type-error<br>

&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(what)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(assertion-violation&nbsp;'mul<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"not&nbsp;a&nbsp;number&nbsp;or&nbsp;matrix"<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;what)))
<br>
<br>
&nbsp;;&nbsp;match-error&nbsp;is&nbsp;called&nbsp;to&nbsp;complain&nbsp;when&nbsp;mul&nbsp;receives&nbsp;a&nbsp;pair&nbsp;of<br>

&nbsp;;&nbsp;incompatible&nbsp;arguments.<br>

&nbsp;&nbsp;(define&nbsp;match-error<br>

&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(what1&nbsp;what2)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(assertion-violation&nbsp;'mul<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"incompatible&nbsp;operands"&nbsp;what1<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;what2)))
<br>
<br>
&nbsp;;&nbsp;mul&nbsp;is&nbsp;the&nbsp;generic&nbsp;matrix/scalar&nbsp;multiplication&nbsp;procedure<br>

&nbsp;&nbsp;(define&nbsp;mul<br>

&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(x&nbsp;y)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cond<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(number?&nbsp;x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cond<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(number?&nbsp;y)&nbsp;(*&nbsp;x&nbsp;y)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(matrix?&nbsp;y)&nbsp;(mat-sca-mul&nbsp;y&nbsp;x)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[else&nbsp;(type-error&nbsp;y)])]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(matrix?&nbsp;x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cond<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(number?&nbsp;y)&nbsp;(mat-sca-mul&nbsp;x&nbsp;y)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(matrix?&nbsp;y)&nbsp;(mat-mat-mul&nbsp;x&nbsp;y)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[else&nbsp;(type-error&nbsp;y)])]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[else&nbsp;(type-error&nbsp;x)]))))</tt>
<p>
<h4>Exercise <a name="g153"></a>12.1.1</h4>
<a name="./examples:s4"></a>Make the necessary changes to rename <tt>mul</tt> to <tt>*</tt>.

<p>

<h4>Exercise <a name="g154"></a>12.1.2</h4>
<a name="./examples:s5"></a><a name="exercise:reliable"></a>
The predicate <tt>matrix?</tt> is usually sufficient but not completely
reliable, since it may return <tt>#t</tt> for objects that are not
matrices.
In particular, it does not verify that all of the matrix rows are vectors,
that each row has the same number of elements, or that the elements
themselves are numbers.
Modify <tt>matrix?</tt> to perform each of these additional checks.

<p>

<h4>Exercise <a name="g155"></a>12.1.3</h4>
<a name="./examples:s6"></a>Another solution to Exercise&nbsp;<a href="./examples.html#g154">12.1.2</a> is to define a matrix
record type encapsulating the vectors of the matrix.
If the matrix creation routine never allows a malformed matrix record
to be created, a matrix record check is the only check needed to ensure
that the input is well formed.
Define a matrix record type and recode the library to use it.

<p>

<h4>Exercise <a name="g156"></a>12.1.4</h4>
<a name="./examples:s7"></a>Write similar generic procedures for addition and subtraction.
Devise a generic <tt>dispatch</tt> procedure or syntactic form so that the type
dispatching code need not be rewritten for each new operation.

<p>

<h4>Exercise <a name="g157"></a>12.1.5</h4>
<a name="./examples:s8"></a>This version of <tt>mul</tt> uses vectors
of vectors to represent matrices.
Rewrite the system, using nested lists to represent matrices.
What efficiency is gained or lost by this change?


<p>

<h3><a name="g158"></a><a name="./examples:h2"></a>Section 12.2. Sorting<a name="SECTEXSORTMERGE"></a></h3>



<p>
<a name="./examples:s9"></a>This section illustrates a list sorting algorithm based on a simple
technique known as merge sorting.
The procedure <a name="./examples:s10"></a><tt>sort</tt> defined here
accepts two arguments: a predicate and a list, just like the built-in
<tt>list-sort</tt>.
It returns a list containing the elements of the old list sorted
according to the predicate.
As with <tt>list-sort</tt>,
the predicate should be a procedure that expects two arguments and
returns <tt>#t</tt> if its first argument must precede its
second in the sorted list and false otherwise.
That is, if the predicate is applied to two elements <tt><i>x</i></tt> and
<tt><i>y</i></tt>, where <tt><i>x</i></tt> appears after <tt><i>y</i></tt> in the input
list, it should return true only if <tt><i>x</i></tt> should appear before
<tt><i>y</i></tt> in the output list.
If this constraint is met, <tt>sort</tt> will perform a <i>stable sort</i>;
with a stable sort, two elements that are already sorted with respect
to each other will appear in the output in the same order in which
they appeared in the input.
Thus, sorting a list that is already sorted will result in no
reordering, even if there are equivalent elements.

<p>

<p><tt>(sort&nbsp;&lt;&nbsp;'(3&nbsp;4&nbsp;2&nbsp;1&nbsp;2&nbsp;5))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(1&nbsp;2&nbsp;2&nbsp;3&nbsp;4&nbsp;5)<br>

(sort&nbsp;&gt;&nbsp;'(0.5&nbsp;1/2))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(0.5&nbsp;1/2)<br>

(sort&nbsp;&gt;&nbsp;'(1/2&nbsp;0.5))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(1/2&nbsp;0.5)<br>

(list-&gt;string<br>

&nbsp;&nbsp;(sort&nbsp;char&gt;?<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(string-&gt;list&nbsp;"coins")))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;"sonic"</tt>
<p>A companion procedure, <a name="./examples:s11"></a><tt>merge</tt>,
is also defined by the code.
<tt>merge</tt> accepts a predicate and two sorted lists and returns a
merged list in sorted order of the elements of the two lists.
With a properly defined predicate, <tt>merge</tt> is also stable in the
sense that an item from the first list will appear before an item
from the second list unless it is necessary that the item from
the second list appear first.


<p>

<p><tt>(merge&nbsp;char&lt;?<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'(#\a&nbsp;#\c)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'(#\b&nbsp;#\c&nbsp;#\d))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(#\a&nbsp;#\b&nbsp;#\c&nbsp;#\c&nbsp;#\d)<br>

(merge&nbsp;&lt;<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'(1/2&nbsp;2/3&nbsp;3/4)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'(0.5&nbsp;0.6&nbsp;0.7))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(1/2&nbsp;0.5&nbsp;0.6&nbsp;2/3&nbsp;0.7&nbsp;3/4)<br>

(list-&gt;string<br>

&nbsp;&nbsp;(merge&nbsp;char&gt;?<br>

&nbsp;&nbsp;&nbsp;&nbsp;(string-&gt;list&nbsp;"old")<br>

&nbsp;&nbsp;&nbsp;&nbsp;(string-&gt;list&nbsp;"toe")))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;"tooled"</tt>
<p>The merge sorting algorithm is simple and elegant.
The input list is split into two approximately equal sublists.
These sublists are sorted recursively, yielding two sorted lists.
The sorted lists are then merged to form a single sorted list.
The base case for the recursion is a list of one element,
which is already sorted.

<p>
To reduce overhead, the implementation computes the length of the input
list once, in <tt>sort</tt>, rather than at each step of the recursion,
in <tt>dosort</tt>.
This also allows <tt>dosort</tt> to isolate the first half of the list
merely by halving the length, saving the cost of allocating a new list
containing half of the elements.
As a result, <tt>ls</tt> may contain more than <tt>n</tt> elements,
but only the first <tt>n</tt> elements are considered part of the list.

<p>

<p><tt>
(library&nbsp;(tspl&nbsp;sort)<br>

&nbsp;&nbsp;(export&nbsp;sort&nbsp;merge)<br>

&nbsp;&nbsp;(import&nbsp;(rnrs))
<br>
<br>
&nbsp;&nbsp;(define&nbsp;dosort<br>

&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(pred?&nbsp;ls&nbsp;n)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(=&nbsp;n&nbsp;1)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(list&nbsp;(car&nbsp;ls))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([i&nbsp;(div&nbsp;n&nbsp;2)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(domerge&nbsp;pred?<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(dosort&nbsp;pred?&nbsp;ls&nbsp;i)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(dosort&nbsp;pred?&nbsp;(list-tail&nbsp;ls&nbsp;i)&nbsp;(-&nbsp;n&nbsp;i)))))))
<br>
<br>
&nbsp;&nbsp;(define&nbsp;domerge<br>

&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(pred?&nbsp;l1&nbsp;l2)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cond<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(null?&nbsp;l1)&nbsp;l2]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(null?&nbsp;l2)&nbsp;l1]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(pred?&nbsp;(car&nbsp;l2)&nbsp;(car&nbsp;l1))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cons&nbsp;(car&nbsp;l2)&nbsp;(domerge&nbsp;pred?&nbsp;l1&nbsp;(cdr&nbsp;l2)))]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[else&nbsp;(cons&nbsp;(car&nbsp;l1)&nbsp;(domerge&nbsp;pred?&nbsp;(cdr&nbsp;l1)&nbsp;l2))])))
<br>
<br>
&nbsp;&nbsp;(define&nbsp;sort<br>

&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(pred?&nbsp;l)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(null?&nbsp;l)&nbsp;l&nbsp;(dosort&nbsp;pred?&nbsp;l&nbsp;(length&nbsp;l)))))
<br>
<br>
&nbsp;&nbsp;(define&nbsp;merge<br>

&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(pred?&nbsp;l1&nbsp;l2)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(domerge&nbsp;pred?&nbsp;l1&nbsp;l2))))</tt>
<p>
<h4>Exercise <a name="g159"></a>12.2.1</h4>
<a name="./examples:s12"></a>In <tt>dosort</tt>, when <tt>n</tt> is 1, why is
<tt>(list&nbsp;(car&nbsp;ls))</tt> returned instead of just <tt>ls</tt>?
How much allocation would be saved overall by replacing
<tt>(list&nbsp;(car&nbsp;ls))</tt> with
<tt>(if&nbsp;(null?&nbsp;(cdr&nbsp;ls))&nbsp;ls&nbsp;(list&nbsp;(car&nbsp;ls)))</tt>?

<p>

<h4>Exercise <a name="g160"></a>12.2.2</h4>
<a name="./examples:s13"></a>How much
work is actually saved by not copying the first part of the input
list when splitting it in <tt>dosort</tt>?

<p>

<h4>Exercise <a name="g161"></a>12.2.3</h4>
<a name="./examples:s14"></a>All or nearly all allocation could be saved if the algorithm were to work
destructively, using <tt>set-cdr!</tt> to separate and join lists.
Write destructive versions <tt>sort!</tt> and <tt>merge!</tt> of the <tt>sort</tt> and
<tt>merge</tt>.
Determine the difference between the two sets of procedures in
terms of allocation and run time for various inputs.


<p>

<h3><a name="g162"></a><a name="./examples:h3"></a>Section 12.3. A Set Constructor<a name="SECTEXSETS"></a></h3>



<p>
This example describes a syntactic extension, <a name="./examples:s15"></a><tt>set-of</tt>, that allows
the construction of <a name="./examples:s16"></a>sets represented as lists with no repeated
elements&nbsp;[<a class=citation href="./bibliography.html#g240">22</a>].
It uses <a name="./examples:s17"></a><tt>define-syntax</tt> and
<a name="./examples:s18"></a><tt>syntax-rules</tt>
to compile set expressions into recursion expressions.
The expanded code is often as efficient as that which can be
produced by hand.

<p>
A <tt>set-of</tt> expression takes the following form.

<p>

<p><tt>(set-of&nbsp;<i>expr</i>&nbsp;<i>clause</i>&nbsp;...)</tt>
<p><tt><i>expr</i></tt> describes the elements of the set in terms of the bindings
established by the <tt>set-of</tt> clauses <tt><i>clause</i>&nbsp;...</tt>.
Each <tt><i>clause</i></tt> can take one of three forms:

<p>
<ol>
<a name="g163"></a><li>A clause of the form <tt>(<i>x</i>&nbsp;in&nbsp;<i>s</i>)</tt> establishes a
binding for <tt><i>x</i></tt> to each element of the set <tt><i>s</i></tt> in turn.
This binding is visible within the remaining clauses
and the expression <tt><i>expr</i></tt>.

<p>
<a name="g164"></a><li>A clause of the form <tt>(<i>x</i>&nbsp;is&nbsp;<i>e</i>)</tt> establishes a binding
for <tt><i>x</i></tt> to <tt><i>e</i></tt>.
This binding is visible within the remaining clauses
and the expression <tt><i>expr</i></tt>.
This form is essentially an abbreviation for <tt>(<i>x</i>&nbsp;in&nbsp;(list&nbsp;<i>e</i>))</tt>.

<p>
<a name="g165"></a><li>A clause taking any other form is treated as a predicate; this is
used to force refusal of certain elements as in the second of the
examples below.
</ol>
<p>

<p>

<p><tt>(set-of&nbsp;x<br>

&nbsp;&nbsp;(x&nbsp;in&nbsp;'(a&nbsp;b&nbsp;c)))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(a&nbsp;b&nbsp;c)
<br>
<br>
(set-of&nbsp;x<br>

&nbsp;&nbsp;(x&nbsp;in&nbsp;'(1&nbsp;2&nbsp;3&nbsp;4))<br>

&nbsp;&nbsp;(even?&nbsp;x))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(2&nbsp;4)
<br>
<br>
(set-of&nbsp;(cons&nbsp;x&nbsp;y)<br>

&nbsp;&nbsp;(x&nbsp;in&nbsp;'(1&nbsp;2&nbsp;3))<br>

&nbsp;&nbsp;(y&nbsp;is&nbsp;(*&nbsp;x&nbsp;x)))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;((1&nbsp;.&nbsp;1)&nbsp;(2&nbsp;.&nbsp;4)&nbsp;(3&nbsp;.&nbsp;9))</tt>
<p>
<p><tt>(set-of&nbsp;(cons&nbsp;x&nbsp;y)<br>

&nbsp;&nbsp;(x&nbsp;in&nbsp;'(a&nbsp;b))<br>

&nbsp;&nbsp;(y&nbsp;in&nbsp;'(1&nbsp;2)))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;((a&nbsp;.&nbsp;1)&nbsp;(a&nbsp;.&nbsp;2)&nbsp;(b&nbsp;.&nbsp;1)&nbsp;(b&nbsp;.&nbsp;2))</tt>
<p>A <tt>set-of</tt> expression is transformed into nested <tt>let</tt>, named <tt>let</tt>,
and <tt>if</tt> expressions, corresponding to each <tt>is</tt>, <tt>in</tt>, or predicate
subexpression.
For example, the simple expression

<p>

<p><tt>(set-of&nbsp;x&nbsp;(x&nbsp;in&nbsp;'(a&nbsp;b&nbsp;c)))</tt>
<p>is transformed into

<p>

<p><tt>(let&nbsp;loop&nbsp;([set&nbsp;'(a&nbsp;b&nbsp;c)])<br>

&nbsp;&nbsp;(if&nbsp;(null?&nbsp;set)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'()<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([x&nbsp;(car&nbsp;set)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set-cons&nbsp;x&nbsp;(loop&nbsp;(cdr&nbsp;set))))))</tt>
<p>The expression

<p>

<p><tt>(set-of&nbsp;x&nbsp;(x&nbsp;in&nbsp;'(1&nbsp;2&nbsp;3&nbsp;4))&nbsp;(even?&nbsp;x))</tt>
<p>is transformed into

<p>

<p><tt>(let&nbsp;loop&nbsp;([set&nbsp;'(1&nbsp;2&nbsp;3&nbsp;4)])<br>

&nbsp;&nbsp;(if&nbsp;(null?&nbsp;set)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'()<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([x&nbsp;(car&nbsp;set)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(even?&nbsp;x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set-cons&nbsp;x&nbsp;(loop&nbsp;(cdr&nbsp;set)))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(loop&nbsp;(cdr&nbsp;set))))))</tt>
<p>The more complicated expression

<p>

<p><tt>(set-of&nbsp;(cons&nbsp;x&nbsp;y)&nbsp;(x&nbsp;in&nbsp;'(1&nbsp;2&nbsp;3))&nbsp;(y&nbsp;is&nbsp;(*&nbsp;x&nbsp;x)))</tt>
<p>is transformed into

<p>

<p><tt>(let&nbsp;loop&nbsp;([set&nbsp;'(1&nbsp;2&nbsp;3)])<br>

&nbsp;&nbsp;(if&nbsp;(null?&nbsp;set)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'()<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([x&nbsp;(car&nbsp;set)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([y&nbsp;(*&nbsp;x&nbsp;x)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set-cons&nbsp;(cons&nbsp;x&nbsp;y)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(loop&nbsp;(cdr&nbsp;set)))))))</tt>
<p>Finally, the expression

<p>

<p><tt>(set-of&nbsp;(cons&nbsp;x&nbsp;y)&nbsp;(x&nbsp;in&nbsp;'(a&nbsp;b))&nbsp;(y&nbsp;in&nbsp;'(1&nbsp;2)))</tt>
<p>is transformed into nested named <tt>let</tt> expressions:

<p>

<p><tt>(let&nbsp;loop1&nbsp;([set1&nbsp;'(a&nbsp;b)])<br>

&nbsp;&nbsp;(if&nbsp;(null?&nbsp;set1)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'()<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([x&nbsp;(car&nbsp;set1)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;loop2&nbsp;([set2&nbsp;'(1&nbsp;2)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(null?&nbsp;set2)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(loop1&nbsp;(cdr&nbsp;set1))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([y&nbsp;(car&nbsp;set2)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set-cons&nbsp;(cons&nbsp;x&nbsp;y)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(loop2&nbsp;(cdr&nbsp;set2)))))))))</tt>
<p>These are fairly straightforward transformations, except that the
base case for the recursion on nested named <tt>let</tt> expressions
varies depending upon the level.
The base case for the outermost named <tt>let</tt> is always the empty
list <tt>()</tt>, while the base case for an internal named <tt>let</tt>
is the recursion step for the next outer named <tt>let</tt>.
In order to handle this, the definition of <tt>set-of</tt> employs a
help syntactic extension <tt>set-of-help</tt>.
<tt>set-of-help</tt> takes an additional expression, <tt>base</tt>, which
is the base case for recursion at the current level.

<p>

<p><tt>
(library&nbsp;(tspl&nbsp;sets)<br>

&nbsp;&nbsp;(export&nbsp;set-of&nbsp;set-cons&nbsp;in&nbsp;is)<br>

&nbsp;&nbsp;(import&nbsp;(rnrs))
<br>
<br>
&nbsp;;&nbsp;set-of&nbsp;uses&nbsp;helper&nbsp;syntactic&nbsp;extension&nbsp;set-of-help,&nbsp;passing&nbsp;it<br>

&nbsp;;&nbsp;an&nbsp;initial&nbsp;base&nbsp;expression&nbsp;of&nbsp;'()<br>

&nbsp;&nbsp;(define-syntax&nbsp;set-of<br>

&nbsp;&nbsp;&nbsp;&nbsp;(syntax-rules&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;e&nbsp;m&nbsp;...)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set-of-help&nbsp;e&nbsp;'()&nbsp;m&nbsp;...)]))
<br>
<br>
&nbsp;;&nbsp;set-of-help&nbsp;recognizes&nbsp;in,&nbsp;is,&nbsp;and&nbsp;predicate&nbsp;expressions&nbsp;and<br>

&nbsp;;&nbsp;changes&nbsp;them&nbsp;into&nbsp;nested&nbsp;named&nbsp;let,&nbsp;let,&nbsp;and&nbsp;if&nbsp;expressions.<br>

&nbsp;&nbsp;(define-syntax&nbsp;set-of-help<br>

&nbsp;&nbsp;&nbsp;&nbsp;(syntax-rules&nbsp;(in&nbsp;is)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;e&nbsp;base)&nbsp;(set-cons&nbsp;e&nbsp;base)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;e&nbsp;base&nbsp;(x&nbsp;in&nbsp;s)&nbsp;m&nbsp;...)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;loop&nbsp;([set&nbsp;s])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(null?&nbsp;set)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;base<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([x&nbsp;(car&nbsp;set)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set-of-help&nbsp;e&nbsp;(loop&nbsp;(cdr&nbsp;set))&nbsp;m&nbsp;...))))]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;e&nbsp;base&nbsp;(x&nbsp;is&nbsp;y)&nbsp;m&nbsp;...)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([x&nbsp;y])&nbsp;(set-of-help&nbsp;e&nbsp;base&nbsp;m&nbsp;...))]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;e&nbsp;base&nbsp;p&nbsp;m&nbsp;...)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;p&nbsp;(set-of-help&nbsp;e&nbsp;base&nbsp;m&nbsp;...)&nbsp;base)]))
<br>
<br>
&nbsp;;&nbsp;since&nbsp;in&nbsp;and&nbsp;is&nbsp;are&nbsp;used&nbsp;as&nbsp;auxiliary&nbsp;keywords&nbsp;by&nbsp;set-of,&nbsp;the<br>

&nbsp;;&nbsp;library&nbsp;must&nbsp;export&nbsp;definitions&nbsp;for&nbsp;them&nbsp;as&nbsp;well<br>

&nbsp;&nbsp;(define-syntax&nbsp;in<br>

&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(syntax-violation&nbsp;'in&nbsp;"misplaced&nbsp;auxiliary&nbsp;keyword"&nbsp;x)))
<br>
<br>
&nbsp;&nbsp;(define-syntax&nbsp;is<br>

&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(syntax-violation&nbsp;'is&nbsp;"misplaced&nbsp;auxiliary&nbsp;keyword"&nbsp;x)))
<br>
<br>
&nbsp;;&nbsp;set-cons&nbsp;returns&nbsp;the&nbsp;original&nbsp;set&nbsp;y&nbsp;if&nbsp;x&nbsp;is&nbsp;already&nbsp;in&nbsp;y.<br>

&nbsp;&nbsp;(define&nbsp;set-cons<br>

&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(x&nbsp;y)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(memv&nbsp;x&nbsp;y)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cons&nbsp;x&nbsp;y)))))</tt>
<p>
<h4>Exercise <a name="g166"></a>12.3.1</h4>
<a name="./examples:s19"></a>Write a procedure, <tt>union</tt>, that takes an arbitrary number
of sets (lists) as arguments and returns the union of the sets,
using only the <tt>set-of</tt> syntactic form.
For example:

<p>

<p><tt>(union)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;()<br>

(union&nbsp;'(a&nbsp;b&nbsp;c))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(a&nbsp;b&nbsp;c)<br>

(union&nbsp;'(2&nbsp;5&nbsp;4)&nbsp;'(9&nbsp;4&nbsp;3))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(2&nbsp;5&nbsp;9&nbsp;4&nbsp;3)<br>

(union&nbsp;'(1&nbsp;2)&nbsp;'(2&nbsp;4)&nbsp;'(4&nbsp;8))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(1&nbsp;2&nbsp;4&nbsp;8)</tt>
<p>
<h4>Exercise <a name="g167"></a>12.3.2</h4>
<a name="./examples:s20"></a>A single-list version of <a name="./examples:s21"></a><tt>map</tt> can (almost) be defined as follows.

<p>

<p><tt>(define&nbsp;map1<br>

&nbsp;&nbsp;(lambda&nbsp;(f&nbsp;ls)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(set-of&nbsp;(f&nbsp;x)&nbsp;(x&nbsp;in&nbsp;ls))))
<br>
<br>
(map1&nbsp;-&nbsp;'(1&nbsp;2&nbsp;3&nbsp;2))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(-1&nbsp;-3&nbsp;-2)</tt>
<p>Why does this not work?
What could be changed to make it work?

<p>

<h4>Exercise <a name="g168"></a>12.3.3</h4>
<a name="./examples:s22"></a>Devise a different definition of <tt>set-cons</tt> that maintains sets
in some sorted order, making the test for set membership, and hence
<tt>set-cons</tt> itself, potentially more efficient.


<p>

<h3><a name="g169"></a><a name="./examples:h4"></a>Section 12.4. Word Frequency Counting<a name="SECTEXWORDFREQ"></a></h3>



<p>
This program demonstrates several basic programming techniques,
including string and character manipulation, file input/output,
data structure manipulation, and recursion.
The program is
adapted from Chapter&nbsp;6 of <i>The C Programming Language</i>&nbsp;[<a class=citation href="./bibliography.html#g237">19</a>].
One reason for using this particular example is to show how a
<a name="./examples:s23"></a>C program might look when converted almost literally into
Scheme.

<p>
A few differences between the Scheme program and the original C
program are worth noting.
First, the Scheme version employs a different protocol for file
input and output.
Rather than implicitly using the standard input and output ports, it
requires that filenames be passed in, thus demonstrating the opening
and closing of files.
Second, the procedure <tt>get-word</tt> returns one of three values:
a string (the word), a nonalphabetic character, or an eof value.
The original C version returned a flag for letter (to say that a
word was read) or a nonalphabetic character.
Furthermore, the C version passed in a string to fill and a limit
on the number of characters in the string; the Scheme version builds
a new string of whatever length is required (the characters in the
word are held in a list until the end of the word has been found,
then converted into a string with <tt>list-&gt;string</tt>).
Finally, <tt>char-type</tt> uses the primitive Scheme character predicates
<tt>char-alphabetic?</tt> and <tt>char-numeric?</tt> to determine whether a
character is a letter or digit.

<p>
The main program, <a name="./examples:s24"></a><tt>frequency</tt>,
takes an input filename and an
output filename as arguments, e.g., <tt>(frequency&nbsp;"pickle"&nbsp;"freq.out")</tt>
prints the frequency count for each word in the file "pickle" to
the file "freq.out."
As <tt>frequency</tt> reads words from the input file, it inserts them
into a binary tree structure (using a binary sorting algorithm).
Duplicate entries are recorded by incrementing the count associated
with each word.
Once end of file is reached, the program traverses the tree, printing
each word with its count.

<p>
Assume that the file "pickle" contains the following text.

<p>

<p><tt>Peter&nbsp;Piper&nbsp;picked&nbsp;a&nbsp;peck&nbsp;of&nbsp;pickled&nbsp;peppers;<br>

A&nbsp;peck&nbsp;of&nbsp;pickled&nbsp;peppers&nbsp;Peter&nbsp;Piper&nbsp;picked.<br>

If&nbsp;Peter&nbsp;Piper&nbsp;picked&nbsp;a&nbsp;peck&nbsp;of&nbsp;pickled&nbsp;peppers,<br>

Where's&nbsp;the&nbsp;peck&nbsp;of&nbsp;pickled&nbsp;peppers&nbsp;Peter&nbsp;Piper&nbsp;picked?</tt>
<p>Then, after typing <tt>(frequency&nbsp;"pickle"&nbsp;"freq.out")</tt>, the file
"freq.out" should contain the following.

<p>

<p><tt>1&nbsp;A<br>

1&nbsp;If<br>

4&nbsp;Peter<br>

4&nbsp;Piper<br>

1&nbsp;Where<br>

2&nbsp;a<br>

4&nbsp;of<br>

4&nbsp;peck<br>

4&nbsp;peppers<br>

4&nbsp;picked<br>

4&nbsp;pickled<br>

1&nbsp;s<br>

1&nbsp;the</tt>
<p>The code for the word-counting program is structured as a top-level
program, with the script header recommended in the scripts chapter
of the nonnormative appendices to the Revised<sup>6</sup> Report&nbsp;[<a class=citation href="./bibliography.html#g243">25</a>].
It takes the names of input and output files from the command line.

<p>

<p><tt>
#!&nbsp;/usr/bin/env&nbsp;scheme-script<br>

(import&nbsp;(rnrs))
<br>
<br>
;;;&nbsp;If&nbsp;the&nbsp;next&nbsp;character&nbsp;on&nbsp;p&nbsp;is&nbsp;a&nbsp;letter,&nbsp;get-word&nbsp;reads&nbsp;a&nbsp;word<br>

;;;&nbsp;from&nbsp;p&nbsp;and&nbsp;returns&nbsp;it&nbsp;in&nbsp;a&nbsp;string.&nbsp;&nbsp;If&nbsp;the&nbsp;character&nbsp;is&nbsp;not&nbsp;a<br>

;;;&nbsp;letter,&nbsp;get-word&nbsp;returns&nbsp;the&nbsp;character&nbsp;(on&nbsp;eof,&nbsp;the&nbsp;eof-object).<br>

(define&nbsp;get-word<br>

&nbsp;&nbsp;(lambda&nbsp;(p)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([c&nbsp;(get-char&nbsp;p)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(eq?&nbsp;(char-type&nbsp;c)&nbsp;'letter)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(list-&gt;string<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;loop&nbsp;([c&nbsp;c])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cons<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(memq&nbsp;(char-type&nbsp;(lookahead-char&nbsp;p))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'(letter&nbsp;digit))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(loop&nbsp;(get-char&nbsp;p))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'()))))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c))))
<br>
<br>
;;;&nbsp;char-type&nbsp;tests&nbsp;for&nbsp;the&nbsp;eof-object&nbsp;first,&nbsp;since&nbsp;the&nbsp;eof-object<br>

;;;&nbsp;may&nbsp;not&nbsp;be&nbsp;a&nbsp;valid&nbsp;argument&nbsp;to&nbsp;char-alphabetic?&nbsp;or&nbsp;char-numeric?<br>

;;;&nbsp;It&nbsp;returns&nbsp;the&nbsp;eof-object,&nbsp;the&nbsp;symbol&nbsp;letter,&nbsp;the&nbsp;symbol&nbsp;digit,<br>

;;;&nbsp;or&nbsp;the&nbsp;argument&nbsp;itself&nbsp;if&nbsp;it&nbsp;is&nbsp;not&nbsp;a&nbsp;letter&nbsp;or&nbsp;digit.<br>

(define&nbsp;char-type<br>

&nbsp;&nbsp;(lambda&nbsp;(c)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(cond<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(eof-object?&nbsp;c)&nbsp;c]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(char-alphabetic?&nbsp;c)&nbsp;'letter]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(char-numeric?&nbsp;c)&nbsp;'digit]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[else&nbsp;c])))
<br>
<br>
;;;&nbsp;Tree&nbsp;nodes&nbsp;are&nbsp;represented&nbsp;as&nbsp;a&nbsp;record&nbsp;type&nbsp;with&nbsp;four&nbsp;fields:&nbsp;word,<br>

;;;&nbsp;left,&nbsp;right,&nbsp;and&nbsp;count.&nbsp;&nbsp;Only&nbsp;one&nbsp;field,&nbsp;word,&nbsp;is&nbsp;initialized&nbsp;by&nbsp;an<br>

;;;&nbsp;argument&nbsp;to&nbsp;the&nbsp;constructor&nbsp;procedure&nbsp;make-tnode.&nbsp;&nbsp;The&nbsp;remaining<br>

;;;&nbsp;fields&nbsp;are&nbsp;initialized&nbsp;by&nbsp;the&nbsp;constructor&nbsp;and&nbsp;changed&nbsp;by&nbsp;subsequent<br>

;;;&nbsp;operations.<br>

(define-record-type&nbsp;tnode<br>

&nbsp;&nbsp;(fields&nbsp;(immutable&nbsp;word)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(mutable&nbsp;left)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(mutable&nbsp;right)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(mutable&nbsp;count))<br>

&nbsp;&nbsp;(protocol<br>

&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(new)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(word)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(new&nbsp;word&nbsp;'()&nbsp;'()&nbsp;1)))))
<br>
<br>
;;;&nbsp;If&nbsp;the&nbsp;word&nbsp;already&nbsp;exists&nbsp;in&nbsp;the&nbsp;tree,&nbsp;tree&nbsp;increments&nbsp;its<br>

;;;&nbsp;count.&nbsp;&nbsp;Otherwise,&nbsp;a&nbsp;new&nbsp;tree&nbsp;node&nbsp;is&nbsp;created&nbsp;and&nbsp;put&nbsp;into&nbsp;the<br>

;;;&nbsp;tree.&nbsp;&nbsp;In&nbsp;any&nbsp;case,&nbsp;the&nbsp;new&nbsp;or&nbsp;modified&nbsp;tree&nbsp;is&nbsp;returned.<br>

(define&nbsp;tree<br>

&nbsp;&nbsp;(lambda&nbsp;(node&nbsp;word)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(cond<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(null?&nbsp;node)&nbsp;(make-tnode&nbsp;word)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(string=?&nbsp;word&nbsp;(tnode-word&nbsp;node))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(tnode-count-set!&nbsp;node&nbsp;(+&nbsp;(tnode-count&nbsp;node)&nbsp;1))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;node]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(string&lt;?&nbsp;word&nbsp;(tnode-word&nbsp;node))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(tnode-left-set!&nbsp;node&nbsp;(tree&nbsp;(tnode-left&nbsp;node)&nbsp;word))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;node]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[else<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(tnode-right-set!&nbsp;node&nbsp;(tree&nbsp;(tnode-right&nbsp;node)&nbsp;word))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;node])))
<br>
<br>
;;;&nbsp;tree-print&nbsp;prints&nbsp;the&nbsp;tree&nbsp;in&nbsp;"in-order,"&nbsp;i.e.,&nbsp;left&nbsp;subtree,<br>

;;;&nbsp;then&nbsp;node,&nbsp;then&nbsp;right&nbsp;subtree.&nbsp;&nbsp;For&nbsp;each&nbsp;word,&nbsp;the&nbsp;count&nbsp;and&nbsp;the<br>

;;;&nbsp;word&nbsp;are&nbsp;printed&nbsp;on&nbsp;a&nbsp;single&nbsp;line.<br>

(define&nbsp;tree-print<br>

&nbsp;&nbsp;(lambda&nbsp;(node&nbsp;p)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(unless&nbsp;(null?&nbsp;node)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(tree-print&nbsp;(tnode-left&nbsp;node)&nbsp;p)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(put-datum&nbsp;p&nbsp;(tnode-count&nbsp;node))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(put-char&nbsp;p&nbsp;#\space)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(put-string&nbsp;p&nbsp;(tnode-word&nbsp;node))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(newline&nbsp;p)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(tree-print&nbsp;(tnode-right&nbsp;node)&nbsp;p))))
<br>
<br>
;;;&nbsp;frequency&nbsp;is&nbsp;the&nbsp;driver&nbsp;routine.&nbsp;&nbsp;It&nbsp;opens&nbsp;the&nbsp;files,&nbsp;reads&nbsp;the<br>

;;;&nbsp;words,&nbsp;and&nbsp;enters&nbsp;them&nbsp;into&nbsp;the&nbsp;tree.&nbsp;&nbsp;When&nbsp;the&nbsp;input&nbsp;port<br>

;;;&nbsp;reaches&nbsp;end-of-file,&nbsp;it&nbsp;prints&nbsp;the&nbsp;tree&nbsp;and&nbsp;closes&nbsp;the&nbsp;ports.<br>

(define&nbsp;frequency<br>

&nbsp;&nbsp;(lambda&nbsp;(infn&nbsp;outfn)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([ip&nbsp;(open-file-input-port&nbsp;infn&nbsp;(file-options)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(buffer-mode&nbsp;block)&nbsp;(native-transcoder))]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[op&nbsp;(open-file-output-port&nbsp;outfn&nbsp;(file-options)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(buffer-mode&nbsp;block)&nbsp;(native-transcoder))])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;loop&nbsp;([root&nbsp;'()])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([w&nbsp;(get-word&nbsp;ip)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cond<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(eof-object?&nbsp;w)&nbsp;(tree-print&nbsp;root&nbsp;op)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(string?&nbsp;w)&nbsp;(loop&nbsp;(tree&nbsp;root&nbsp;w))]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[else&nbsp;(loop&nbsp;root)])))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(close-port&nbsp;ip)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(close-port&nbsp;op))))
<br>
<br>
(unless&nbsp;(=&nbsp;(length&nbsp;(command-line))&nbsp;3)<br>

&nbsp;&nbsp;(put-string&nbsp;(current-error-port)&nbsp;"usage:&nbsp;")<br>

&nbsp;&nbsp;(put-string&nbsp;(current-error-port)&nbsp;(car&nbsp;(command-line)))<br>

&nbsp;&nbsp;(put-string&nbsp;(current-error-port)&nbsp;"&nbsp;input-filename&nbsp;output-filename\n")<br>

&nbsp;&nbsp;(exit&nbsp;#f))
<br>
<br>
(frequency&nbsp;(cadr&nbsp;(command-line))&nbsp;(caddr&nbsp;(command-line)))</tt>
<p>
<h4>Exercise <a name="g170"></a>12.4.1</h4>
<a name="./examples:s25"></a>In the output file shown earlier, the capitalized words appeared before
the others in the output file, and the capital <tt>A</tt> was not recognized
as the same word as the lower-case <tt>a</tt>.
Modify <tt>tree</tt> to use the case-insensitive versions of the string
comparisons so that this does not happen.

<p>

<h4>Exercise <a name="g171"></a>12.4.2</h4>
<a name="./examples:s26"></a>The "word" <tt>s</tt> appears in the file "freq.out," although it
is really just a part of the contraction <tt>Where's</tt>.
Adjust <tt>get-word</tt> to allow embedded single quote marks.

<p>

<h4>Exercise <a name="g172"></a>12.4.3</h4>
<a name="./examples:s27"></a>Modify this program to "weed out" certain common words such as <tt>a</tt>,
<tt>an</tt>, <tt>the</tt>, <tt>is</tt>, <tt>of</tt>, etc., in order to reduce the
amount of output for long input files.
Try to devise other ways to cut down on useless output.

<p>

<h4>Exercise <a name="g173"></a>12.4.4</h4>
<a name="./examples:s28"></a><tt>get-word</tt> buffers characters in a list, allocating a new pair
(with <tt>cons</tt>) for each character.
Make it more efficient by using a string to buffer the characters.
Devise a way to allow the string to grow if necessary.
[<i>Hint</i>: Use <tt>string-append</tt> or a string output port.]

<p>

<h4>Exercise <a name="g174"></a>12.4.5</h4>
<a name="./examples:s29"></a>The <tt>tree</tt> implementation works by creating trees and later filling
in their <tt>left</tt> and <tt>right</tt> fields.
This requires many unnecessary assignments.
Rewrite the <tt>tree</tt> procedure to avoid <tt>tree-left-set!</tt> and
<tt>tree-right-set!</tt> entirely.

<p>

<h4>Exercise <a name="g175"></a>12.4.6</h4>
<a name="./examples:s30"></a>Recode the program to use a hashtable (Section&nbsp;<a href="./objects.html#g119">6.13</a>)
in place of a binary tree, and
compare the running times of the new and old programs on large input files.
Are hashtables always faster or always slower?
Is there a break-even point?
Does the break-even point depend on the size of the file or on some
other characteristic of the file?


<p>

<h3><a name="g176"></a><a name="./examples:h5"></a>Section 12.5. Scheme Printer<a name="SECTEXPRINTER"></a></h3>



<p>
Printing Scheme objects may seem like a complicated process, but
in fact a rudimentary printer is straightforward, as this
example demonstrates.
<a name="./examples:s31"></a><tt>put-datum</tt>,
<a name="./examples:s32"></a><tt>write</tt>,
and <a name="./examples:s33"></a><tt>display</tt> are all implemented by the same code.
Sophisticated printers often support various printer
controls and handle printing of cyclic objects, but the one given
here is completely basic.

<p>
The main driver for the program is a procedure <tt>wr</tt>, which takes
an object to print <tt>x</tt>, a flag <tt>d?</tt>, and a port <tt>p</tt>.
The flag <tt>d?</tt> (for display) is <tt>#t</tt> if the code is to
<i>display</i> the object, <tt>#f</tt> otherwise.
The <tt>d?</tt> flag is important only for characters and strings.
Recall from Section&nbsp;<a href="./io.html#g129">7.8</a> that <tt>display</tt> prints strings
without the enclosing quote marks and characters without the
<tt>#\</tt> syntax.

<p>
The entry points for <tt>write</tt> and <tt>display</tt> handle the optionality of
the second (port) argument, passing the value of
<tt>current-output-port</tt> when no port argument is provided.

<p>
Procedures, ports, and the end-of-file object are printed as
<tt>#&lt;procedure&gt;</tt>, <tt>#&lt;port&gt;</tt>, and <tt>#&lt;eof&gt;</tt>.
Unrecognized types of values are printed as <tt>#&lt;unknown&gt;</tt>.
So, for example, a hashtable, enumeration set, and object of
some implementation-specific type will all print as <tt>#&lt;unknown&gt;</tt>.

<p>

<p><tt>
(library&nbsp;(tspl&nbsp;printer)<br>

&nbsp;&nbsp;(export&nbsp;put-datum&nbsp;write&nbsp;display)<br>

&nbsp;&nbsp;(import&nbsp;(except&nbsp;(rnrs)&nbsp;put-datum&nbsp;write&nbsp;display))
<br>
<br>
&nbsp;;&nbsp;define&nbsp;these&nbsp;here&nbsp;to&nbsp;avoid&nbsp;confusing&nbsp;paren-balancers<br>

&nbsp;&nbsp;(define&nbsp;lparen&nbsp;#\()<br>

&nbsp;&nbsp;(define&nbsp;rparen&nbsp;#\))
<br>
<br>
&nbsp;;&nbsp;wr&nbsp;is&nbsp;the&nbsp;driver,&nbsp;dispatching&nbsp;on&nbsp;the&nbsp;type&nbsp;of&nbsp;x<br>

&nbsp;&nbsp;(define&nbsp;wr<br>

&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(x&nbsp;d?&nbsp;p)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cond<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(symbol?&nbsp;x)&nbsp;(put-string&nbsp;p&nbsp;(symbol-&gt;string&nbsp;x))]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(pair?&nbsp;x)&nbsp;(wrpair&nbsp;x&nbsp;d?&nbsp;p)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(number?&nbsp;x)&nbsp;(put-string&nbsp;p&nbsp;(number-&gt;string&nbsp;x))]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(null?&nbsp;x)&nbsp;(put-string&nbsp;p&nbsp;"()")]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(boolean?&nbsp;x)&nbsp;(put-string&nbsp;p&nbsp;(if&nbsp;x&nbsp;"#t"&nbsp;"#f"))]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(char?&nbsp;x)&nbsp;(if&nbsp;d?&nbsp;(put-char&nbsp;p&nbsp;x)&nbsp;(wrchar&nbsp;x&nbsp;p))]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(string?&nbsp;x)&nbsp;(if&nbsp;d?&nbsp;(put-string&nbsp;p&nbsp;x)&nbsp;(wrstring&nbsp;x&nbsp;p))]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(vector?&nbsp;x)&nbsp;(wrvector&nbsp;x&nbsp;d?&nbsp;p)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(bytevector?&nbsp;x)&nbsp;(wrbytevector&nbsp;x&nbsp;d?&nbsp;p)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(eof-object?&nbsp;x)&nbsp;(put-string&nbsp;p&nbsp;"#&lt;eof&gt;")]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(port?&nbsp;x)&nbsp;(put-string&nbsp;p&nbsp;"#&lt;port&gt;")]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(procedure?&nbsp;x)&nbsp;(put-string&nbsp;p&nbsp;"#&lt;procedure&gt;")]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[else&nbsp;(put-string&nbsp;p&nbsp;"#&lt;unknown&gt;")])))
<br>
<br>
&nbsp;;&nbsp;wrpair&nbsp;handles&nbsp;pairs&nbsp;and&nbsp;nonempty&nbsp;lists<br>

&nbsp;&nbsp;(define&nbsp;wrpair<br>

&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(x&nbsp;d?&nbsp;p)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(put-char&nbsp;p&nbsp;lparen)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;loop&nbsp;([x&nbsp;x])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(wr&nbsp;(car&nbsp;x)&nbsp;d?&nbsp;p)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cond<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(pair?&nbsp;(cdr&nbsp;x))&nbsp;(put-char&nbsp;p&nbsp;#\space)&nbsp;(loop&nbsp;(cdr&nbsp;x))]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(null?&nbsp;(cdr&nbsp;x))]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[else&nbsp;(put-string&nbsp;p&nbsp;"&nbsp;.&nbsp;")&nbsp;(wr&nbsp;(cdr&nbsp;x)&nbsp;d?&nbsp;p)]))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(put-char&nbsp;p&nbsp;rparen)))
<br>
<br>
&nbsp;;&nbsp;wrchar&nbsp;handles&nbsp;characters.&nbsp;&nbsp;Used&nbsp;only&nbsp;when&nbsp;d?&nbsp;is&nbsp;#f.<br>

&nbsp;&nbsp;(define&nbsp;wrchar<br>

&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(x&nbsp;p)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(put-string&nbsp;p&nbsp;"#\\")<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cond<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(assq&nbsp;x&nbsp;'((#\alarm&nbsp;.&nbsp;"alarm")&nbsp;(#\backspace&nbsp;.&nbsp;"backspace")<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(#\delete&nbsp;.&nbsp;"delete")&nbsp;(#\esc&nbsp;.&nbsp;"esc")<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(#\newline&nbsp;.&nbsp;"newline")&nbsp;(#\nul&nbsp;.&nbsp;"nul")<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(#\page&nbsp;.&nbsp;"page")&nbsp;(#\return&nbsp;.&nbsp;"return")<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(#\space&nbsp;.&nbsp;"space")&nbsp;(#\tab&nbsp;.&nbsp;"tab")<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(#\vtab&nbsp;.&nbsp;"vtab")))&nbsp;=&gt;<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(a)&nbsp;(put-string&nbsp;p&nbsp;(cdr&nbsp;a)))]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[else&nbsp;(put-char&nbsp;p&nbsp;x)])))
<br>
<br>
&nbsp;;&nbsp;wrstring&nbsp;handles&nbsp;strings.&nbsp;&nbsp;Used&nbsp;only&nbsp;when&nbsp;d?&nbsp;is&nbsp;#f.<br>

&nbsp;&nbsp;(define&nbsp;wrstring<br>

&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(x&nbsp;p)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(put-char&nbsp;p&nbsp;#\")<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([n&nbsp;(string-length&nbsp;x)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(do&nbsp;([i&nbsp;0&nbsp;(+&nbsp;i&nbsp;1)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((=&nbsp;i&nbsp;n))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([c&nbsp;(string-ref&nbsp;x&nbsp;i)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(case&nbsp;c<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(#\alarm)&nbsp;(put-string&nbsp;p&nbsp;"\\a")]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(#\backspace)&nbsp;(put-string&nbsp;p&nbsp;"\\b")]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(#\newline)&nbsp;(put-string&nbsp;p&nbsp;"\\n")]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(#\page)&nbsp;(put-string&nbsp;p&nbsp;"\\f")]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(#\return)&nbsp;(put-string&nbsp;p&nbsp;"\\r")]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(#\tab)&nbsp;(put-string&nbsp;p&nbsp;"\\t")]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(#\vtab)&nbsp;(put-string&nbsp;p&nbsp;"\\v")]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(#\")&nbsp;(put-string&nbsp;p&nbsp;"\\\"")]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(#\\)&nbsp;(put-string&nbsp;p&nbsp;"\\\\")]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[else&nbsp;(put-char&nbsp;p&nbsp;c)]))))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(put-char&nbsp;p&nbsp;#\")))
<br>
<br>
&nbsp;&nbsp;(define&nbsp;wrvector<br>

&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(x&nbsp;d?&nbsp;p)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(put-char&nbsp;p&nbsp;#\#)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([n&nbsp;(vector-length&nbsp;x)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(do&nbsp;([i&nbsp;0&nbsp;(+&nbsp;i&nbsp;1)]&nbsp;[sep&nbsp;lparen&nbsp;#\space])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((=&nbsp;i&nbsp;n))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(put-char&nbsp;p&nbsp;sep)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(wr&nbsp;(vector-ref&nbsp;x&nbsp;i)&nbsp;d?&nbsp;p)))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(put-char&nbsp;p&nbsp;rparen)))
<br>
<br>
&nbsp;&nbsp;(define&nbsp;wrbytevector<br>

&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(x&nbsp;d?&nbsp;p)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(put-string&nbsp;p&nbsp;"#vu8")<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([n&nbsp;(bytevector-length&nbsp;x)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(do&nbsp;([i&nbsp;0&nbsp;(+&nbsp;i&nbsp;1)]&nbsp;[sep&nbsp;lparen&nbsp;#\space])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((=&nbsp;i&nbsp;n))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(put-char&nbsp;p&nbsp;sep)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(wr&nbsp;(bytevector-u8-ref&nbsp;x&nbsp;i)&nbsp;d?&nbsp;p)))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(put-char&nbsp;p&nbsp;rparen)))
<br>
<br>
&nbsp;;&nbsp;check-and-wr&nbsp;is&nbsp;called&nbsp;when&nbsp;the&nbsp;port&nbsp;is&nbsp;supplied<br>

&nbsp;&nbsp;(define&nbsp;check-and-wr<br>

&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(who&nbsp;x&nbsp;d?&nbsp;p)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(unless&nbsp;(and&nbsp;(output-port?&nbsp;p)&nbsp;(textual-port?&nbsp;p))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(assertion-violation&nbsp;who&nbsp;"invalid&nbsp;argument"&nbsp;p))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(wr&nbsp;x&nbsp;d?&nbsp;p)))
<br>
<br>
&nbsp;;&nbsp;put-datum&nbsp;calls&nbsp;wr&nbsp;with&nbsp;d?&nbsp;set&nbsp;to&nbsp;#f<br>

&nbsp;&nbsp;(define&nbsp;put-datum<br>

&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(p&nbsp;x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(check-and-wr&nbsp;'put-datum&nbsp;x&nbsp;#f&nbsp;p)))
<br>
<br>
&nbsp;;&nbsp;write&nbsp;calls&nbsp;wr&nbsp;with&nbsp;d?&nbsp;set&nbsp;to&nbsp;#f<br>

&nbsp;&nbsp;(define&nbsp;write<br>

&nbsp;&nbsp;&nbsp;&nbsp;(case-lambda<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(x)&nbsp;(wr&nbsp;x&nbsp;#f&nbsp;(current-output-port))]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(x&nbsp;p)&nbsp;(check-and-wr&nbsp;'write&nbsp;x&nbsp;#f&nbsp;p)]))
<br>
<br>
&nbsp;;&nbsp;display&nbsp;calls&nbsp;wr&nbsp;with&nbsp;d?&nbsp;set&nbsp;to&nbsp;#t<br>

&nbsp;&nbsp;(define&nbsp;display<br>

&nbsp;&nbsp;&nbsp;&nbsp;(case-lambda<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(x)&nbsp;(wr&nbsp;x&nbsp;#t&nbsp;(current-output-port))]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(x&nbsp;p)&nbsp;(check-and-wr&nbsp;'display&nbsp;x&nbsp;#t&nbsp;p)])))</tt>
<p>
<h4>Exercise <a name="g177"></a>12.5.1</h4>
<a name="./examples:s34"></a>Numbers are printed with the help of <tt>number-&gt;string</tt>.
Correct printing of all Scheme numeric types, especially inexact
numbers, is a complicated task.
Handling exact integers and ratios is fairly
straightforward, however.
Modify the code to print exact integers and ratios numbers directly
(without <tt>number-&gt;string</tt>), but continue to use <tt>number-&gt;string</tt>
for inexact and complex numbers.

<p>

<h4>Exercise <a name="g178"></a>12.5.2</h4>
<a name="./examples:s35"></a><a name="EXOBJTOSTR"></a>Modify <tt>wr</tt> and its helpers to direct their output to an
internal buffer rather than to a port.
Use the modified versions to implement a procedure <tt>object-&gt;string</tt>
that, like <tt>number-&gt;string</tt>, returns a string containing a printed
representation of its input.
For example:

<p>

<p><tt>(object-&gt;string&nbsp;'(a&nbsp;b&nbsp;c))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;"(a&nbsp;b&nbsp;c)"<br>

(object-&gt;string&nbsp;"hello")&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;"\"hello\""</tt>
<p>You may be surprised just how easy this change is to make.

<p>

<h4>Exercise <a name="g179"></a>12.5.3</h4>
<a name="./examples:s36"></a>Some symbols are not printed properly by <tt>wr</tt>, including those that
start with digits or contain whitespace.
Modify <tt>wr</tt> to call a <tt>wrsymbol</tt> helper that uses hex scalar
escapes as necessary to handle such symbols.
A hex scalar escape takes the form <tt>#\x<i>n</i>;</tt>, where <tt><i>n</i></tt>
is the Unicode scalar value of a character expressed in hexadecimal
notation.
Consult the grammar for symbols on page&nbsp;<a href="./grammar.html#grammar:symbols">458</a> to
determine when hex scalar escapes are necessary.

<p>

<h3><a name="g180"></a><a name="./examples:h6"></a>Section 12.6. Formatted Output<a name="SECTEXPRINTF"></a></h3>



<p>
It is often necessary to print strings containing the printed
representations of Scheme objects, especially numbers.
Doing so with Scheme's standard output routines can be tedious.
For example, the <tt>tree-print</tt> procedure of Section&nbsp;<a href="./examples.html#g169">12.4</a>
requires a sequence of four calls to output routines
to print a simple one-line message:

<p>

<p><tt>(put-datum&nbsp;p&nbsp;(tnode-count&nbsp;node))<br>

(put-char&nbsp;p&nbsp;#\space)<br>

(put-string&nbsp;p&nbsp;(tnode-word&nbsp;node))<br>

(newline&nbsp;p)</tt>
<p>The <a name="./examples:s37"></a>formatted output facility defined in this section allows
these four calls to be replaced by the single call to <tt>fprintf</tt>
below.

<p>

<p><tt>(fprintf&nbsp;p&nbsp;"~s&nbsp;~a~%"&nbsp;(tnode-count&nbsp;node)&nbsp;(tnode-word&nbsp;node))</tt>
<p><a name="./examples:s38"></a><tt>fprintf</tt> expects a port argument, a <i>control string</i>, and
an indefinite number of additional arguments that are inserted into the
output as specified by the control string.
In the example, the value of <tt>(tnode-count&nbsp;node)</tt> is written
first, in place of <tt>~s</tt>.
This is followed by a space and the displayed value of
<tt>(tnode-word&nbsp;node)</tt>, in place of <tt>~a</tt>.
The <tt>~%</tt> is replaced in the output with a newline.

<p>
The procedure <a name="./examples:s39"></a><tt>printf</tt>, also defined in this section, is like
<tt>fprintf</tt> except that no port argument is expected and output
is sent to the current output port.

<p>
<tt>~s</tt>, <tt>~a</tt>, and <tt>~%</tt> are <i>format directives</i>;
<tt>~s</tt> causes the first unused argument after the control string to be
printed to the output via <tt>write</tt>,
<tt>~a</tt> causes the first unused argument to be printed via <tt>display</tt>,
and <tt>~%</tt> simply causes a newline character to be printed.
The simple implementation of <tt>fprintf</tt> below recognizes only one other
format directive, <tt>~~</tt>, which inserts a tilde into the output.
For example,

<p>

<p><tt>(printf&nbsp;"The&nbsp;string&nbsp;~s&nbsp;displays&nbsp;as&nbsp;~~.~%"&nbsp;"~")</tt>
<p>prints

<p>

<p><tt>The&nbsp;string&nbsp;"~"&nbsp;displays&nbsp;as&nbsp;~.</tt>
<p>
<p><tt>
(library&nbsp;(tspl&nbsp;formatted-output)<br>

&nbsp;&nbsp;(export&nbsp;printf&nbsp;fprintf)<br>

&nbsp;&nbsp;(import&nbsp;(rnrs))
<br>
<br>
&nbsp;;&nbsp;dofmt&nbsp;does&nbsp;all&nbsp;of&nbsp;the&nbsp;work.&nbsp;&nbsp;It&nbsp;loops&nbsp;through&nbsp;the&nbsp;control&nbsp;string<br>

&nbsp;;&nbsp;recognizing&nbsp;format&nbsp;directives&nbsp;and&nbsp;printing&nbsp;all&nbsp;other&nbsp;characters<br>

&nbsp;;&nbsp;without&nbsp;interpretation.&nbsp;&nbsp;A&nbsp;tilde&nbsp;at&nbsp;the&nbsp;end&nbsp;of&nbsp;a&nbsp;control&nbsp;string&nbsp;is<br>

&nbsp;;&nbsp;treated&nbsp;as&nbsp;an&nbsp;ordinary&nbsp;character.&nbsp;&nbsp;No&nbsp;checks&nbsp;are&nbsp;made&nbsp;for&nbsp;proper<br>

&nbsp;;&nbsp;inputs.&nbsp;&nbsp;Directives&nbsp;may&nbsp;be&nbsp;given&nbsp;in&nbsp;either&nbsp;lower&nbsp;or&nbsp;upper&nbsp;case.<br>

&nbsp;&nbsp;(define&nbsp;dofmt<br>

&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(p&nbsp;cntl&nbsp;args)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([nmax&nbsp;(-&nbsp;(string-length&nbsp;cntl)&nbsp;1)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;loop&nbsp;([n&nbsp;0]&nbsp;[a&nbsp;args])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(&lt;=&nbsp;n&nbsp;nmax)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([c&nbsp;(string-ref&nbsp;cntl&nbsp;n)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(and&nbsp;(char=?&nbsp;c&nbsp;#\~)&nbsp;(&lt;&nbsp;n&nbsp;nmax))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(case&nbsp;(string-ref&nbsp;cntl&nbsp;(+&nbsp;n&nbsp;1))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(#\a&nbsp;#\A)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(display&nbsp;(car&nbsp;a)&nbsp;p)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(loop&nbsp;(+&nbsp;n&nbsp;2)&nbsp;(cdr&nbsp;a))]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(#\s&nbsp;#\S)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(write&nbsp;(car&nbsp;a)&nbsp;p)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(loop&nbsp;(+&nbsp;n&nbsp;2)&nbsp;(cdr&nbsp;a))]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(#\%)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(newline&nbsp;p)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(loop&nbsp;(+&nbsp;n&nbsp;2)&nbsp;a)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(#\~)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(put-char&nbsp;p&nbsp;#\~)&nbsp;(loop&nbsp;(+&nbsp;n&nbsp;2)&nbsp;a)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[else<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(put-char&nbsp;p&nbsp;c)&nbsp;(loop&nbsp;(+&nbsp;n&nbsp;1)&nbsp;a)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(begin<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(put-char&nbsp;p&nbsp;c)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(loop&nbsp;(+&nbsp;n&nbsp;1)&nbsp;a)))))))))
<br>
<br>
&nbsp;;&nbsp;printf&nbsp;and&nbsp;fprintf&nbsp;differ&nbsp;only&nbsp;in&nbsp;that&nbsp;fprintf&nbsp;passes&nbsp;its<br>

&nbsp;;&nbsp;port&nbsp;argument&nbsp;to&nbsp;dofmt&nbsp;while&nbsp;printf&nbsp;passes&nbsp;the&nbsp;current&nbsp;output<br>

&nbsp;;&nbsp;port.<br>

&nbsp;&nbsp;(define&nbsp;printf<br>

&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(control&nbsp;.&nbsp;args)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(dofmt&nbsp;(current-output-port)&nbsp;control&nbsp;args)))
<br>
<br>
&nbsp;&nbsp;(define&nbsp;fprintf<br>

&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(p&nbsp;control&nbsp;.&nbsp;args)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(dofmt&nbsp;p&nbsp;control&nbsp;args))))</tt>
<p>
<h4>Exercise <a name="g181"></a>12.6.1</h4>
<a name="./examples:s40"></a>Add error checking to the code for invalid port arguments (<tt>fprintf</tt>),
invalid tilde escapes, and extra or missing arguments.

<p>

<h4>Exercise <a name="g182"></a>12.6.2</h4>
<a name="./examples:s41"></a>Using the optional radix argument to <tt>number-&gt;string</tt>,
augment <tt>printf</tt> and <tt>fprintf</tt> with support for the following
new format directives:

<p>

 
 <table>
<tr valign=top><td><i>&nbsp;&nbsp;a</i>.</td><td><tt>~b</tt> or <tt>~B</tt>: print the next unused argument,
which must be a number, in binary;

<p>
<tr valign=top><td><i>&nbsp;&nbsp;b</i>.</td><td><tt>~o</tt> or <tt>~O</tt>: print the next unused argument,
which must be a number, in octal; and

<p>
<tr valign=top><td><i>&nbsp;&nbsp;c</i>.</td><td><tt>~x</tt> or <tt>~X</tt>: print the next unused argument,
which must be a number, in hexadecimal.
</table>

<p>
For example:

<p>

<p><tt>(printf&nbsp;"#x~x&nbsp;#o~o&nbsp;#b~b~%"&nbsp;16&nbsp;8&nbsp;2)</tt>
<p>would print

<p>

<p><tt>#x10&nbsp;#o10&nbsp;#b10</tt>
<p>
<h4>Exercise <a name="g183"></a>12.6.3</h4>
<a name="./examples:s42"></a>Add an "indirect" format directive, <tt>~@</tt>, that treats the next
unused argument, which must be a string, as if it were spliced into
the current format string.
For example:

<p>

<p><tt>(printf&nbsp;"---&nbsp;~@&nbsp;---"&nbsp;"&gt;&nbsp;~s&nbsp;&lt;"&nbsp;'(a&nbsp;b&nbsp;c))</tt>
<p>would print

<p>

<p><tt>---&gt;&nbsp;(a&nbsp;b&nbsp;c)&nbsp;&lt;---</tt>
<p>
<h4>Exercise <a name="g184"></a>12.6.4</h4>
<a name="./examples:s43"></a>Implement <tt>format</tt>, a version of <tt>fprintf</tt> that places its output
into a string instead of writing to a port.
Make use of <tt>object-&gt;string</tt> from Exercise&nbsp;<a href="./examples.html#g178">12.5.2</a>
to support the <tt>~s</tt> and <tt>~a</tt> directives.

<p>

<p><tt>(let&nbsp;([x&nbsp;3]&nbsp;[y&nbsp;4])<br>

&nbsp;&nbsp;(format&nbsp;"~s&nbsp;+&nbsp;~s&nbsp;=&nbsp;~s"&nbsp;x&nbsp;y&nbsp;(+&nbsp;x&nbsp;y)))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;"3&nbsp;+&nbsp;4&nbsp;=&nbsp;7"</tt>
<p>
<h4>Exercise <a name="g185"></a>12.6.5</h4>
<a name="./examples:s44"></a>Instead of using <tt>object-&gt;string</tt>, define <tt>format</tt>
using a string output port.

<p>

<h4>Exercise <a name="g186"></a>12.6.6</h4>
<a name="./examples:s45"></a>Modify <tt>format</tt>, <tt>fprintf</tt>, and <tt>printf</tt> to allow
a field size to be specified after the tilde in the <tt>~a</tt> and
<tt>~s</tt> format directives.
For example, the directive <tt>~10s</tt> would cause the next unused
argument to be inserted into the output left-justified in a field of
size&nbsp;10.
If the object requires more spaces than the amount specified, allow it
to extend beyond the field.

<p>

<p><tt>(let&nbsp;([x&nbsp;'abc]&nbsp;[y&nbsp;'(def)])<br>

&nbsp;&nbsp;(format&nbsp;"(cons&nbsp;'~5s&nbsp;'~5s)&nbsp;=&nbsp;~5s"<br>

&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;y&nbsp;(cons&nbsp;x&nbsp;y)))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;"(cons&nbsp;'abc&nbsp;&nbsp;&nbsp;'(def))&nbsp;=&nbsp;(abc&nbsp;def)"</tt>
<p>[<i>Hint</i>: Use <tt>format</tt> recursively.]

<p>

<h3><a name="g187"></a><a name="./examples:h7"></a>Section 12.7. A Meta-Circular Interpreter for Scheme<a name="SECTEXINTERPRET"></a></h3>



<p>
The program described in this section is a
<a name="./examples:s46"></a><a name="./examples:s47"></a><i>meta-circular</i>
<a name="./examples:s48"></a>interpreter for Scheme, i.e.,
it is an interpreter <i>for</i> Scheme written <i>in</i> Scheme.
The interpreter shows how small Scheme is when the core
structure is considered independently from its syntactic extensions
and primitives.
It also illustrates interpretation techniques that can be applied
equally well to languages other than Scheme.

<p>
The relative simplicity of the interpreter is somewhat misleading.
An interpreter for Scheme written in Scheme can be quite a bit simpler
than one written in most other languages.
Here are a few reasons why this one is simpler.

<p>
<ul>
<li>Tail calls are handled properly only because tail calls
in the interpreter are handled properly by the host implementation.
All that is required is that the interpreter itself be tail-recursive.

<p>
<li>First-class procedures in interpreted code are implemented
by first-class procedures in the interpreter, which in turn are
supported by the host implementation.

<p>
<li>First-class continuations created with <tt>call/cc</tt> are provided by the
host implementation's <tt>call/cc</tt>.

<p>
<li>Primitive procedures such as <tt>cons</tt> and <tt>assq</tt> and services such as
storage management are provided by the host implementation.
</ul>
<p>

<p>
Converting the interpreter to run in a language other than
Scheme may require explicit support for some or all of these
items.

<p>
The interpreter stores lexical bindings in an <a name="./examples:s49"></a><i>environment</i>, which
is simply an <a name="./examples:s50"></a><i>association list</i>
(see page&nbsp;<a href="./objects.html#page:assq">165</a>).
Evaluation of a <tt>lambda</tt> expression results in the creation of a procedure
within the scope of variables holding the environment and the <tt>lambda</tt> body.
Subsequent application of the procedure combines the new bindings (the
actual parameters) with the saved environment.

<p>
The interpreter handles only the <a name="./examples:s51"></a>core syntactic forms described in
Section&nbsp;<a href="./further.html#g50">3.1</a>, and it recognizes bindings for only a handful
of primitive procedures.
It performs no error checking.

<p>

<p><tt>(interpret&nbsp;3)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;3
<br>
<br>
(interpret&nbsp;'(cons&nbsp;3&nbsp;4))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(3&nbsp;.&nbsp;4)
<br>
<br>
(interpret<br>

&nbsp;&nbsp;'((lambda&nbsp;(x&nbsp;.&nbsp;y)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(list&nbsp;x&nbsp;y))<br>

&nbsp;&nbsp;&nbsp;&nbsp;'a&nbsp;'b&nbsp;'c&nbsp;'d))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(a&nbsp;(b&nbsp;c&nbsp;d))
<br>
<br>
(interpret<br>

&nbsp;&nbsp;'(((call/cc&nbsp;(lambda&nbsp;(k)&nbsp;k))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(x)&nbsp;x))<br>

&nbsp;&nbsp;&nbsp;&nbsp;"HEY!"))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;"HEY!"
<br>
<br>
(interpret<br>

&nbsp;&nbsp;'((lambda&nbsp;(memq)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(memq&nbsp;memq&nbsp;'a&nbsp;'(b&nbsp;c&nbsp;a&nbsp;d&nbsp;e)))<br>

&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(memq&nbsp;x&nbsp;ls)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(null?&nbsp;ls)&nbsp;#f<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(eq?&nbsp;(car&nbsp;ls)&nbsp;x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ls<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(memq&nbsp;memq&nbsp;x&nbsp;(cdr&nbsp;ls)))))))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(a&nbsp;d&nbsp;e)
<br>
<br>
(interpret<br>

&nbsp;&nbsp;'((lambda&nbsp;(reverse)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set!&nbsp;reverse<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(ls&nbsp;new)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(null?&nbsp;ls)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(reverse&nbsp;(cdr&nbsp;ls)&nbsp;(cons&nbsp;(car&nbsp;ls)&nbsp;new)))))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(reverse&nbsp;'(a&nbsp;b&nbsp;c&nbsp;d&nbsp;e)&nbsp;'()))<br>

&nbsp;#f))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(e&nbsp;d&nbsp;c&nbsp;b&nbsp;a)</tt>
<p>
<p><tt>
(library&nbsp;(tspl&nbsp;interpreter)<br>

&nbsp;&nbsp;(export&nbsp;interpret)<br>

&nbsp;&nbsp;(import&nbsp;(rnrs)&nbsp;(rnrs&nbsp;mutable-pairs))
<br>
<br>
&nbsp;;&nbsp;primitive-environment&nbsp;contains&nbsp;a&nbsp;small&nbsp;number&nbsp;of&nbsp;primitive<br>

&nbsp;;&nbsp;procedures;&nbsp;it&nbsp;can&nbsp;be&nbsp;extended&nbsp;easily&nbsp;with&nbsp;additional&nbsp;primitives.<br>

&nbsp;&nbsp;(define&nbsp;primitive-environment<br>

&nbsp;&nbsp;&nbsp;&nbsp;`((apply&nbsp;.&nbsp;,apply)&nbsp;(assq&nbsp;.&nbsp;,assq)&nbsp;(call/cc&nbsp;.&nbsp;,call/cc)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(car&nbsp;.&nbsp;,car)&nbsp;(cadr&nbsp;.&nbsp;,cadr)&nbsp;(caddr&nbsp;.&nbsp;,caddr)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cadddr&nbsp;.&nbsp;,cadddr)&nbsp;(cddr&nbsp;.&nbsp;,cddr)&nbsp;(cdr&nbsp;.&nbsp;,cdr)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cons&nbsp;.&nbsp;,cons)&nbsp;(eq?&nbsp;.&nbsp;,eq?)&nbsp;(list&nbsp;.&nbsp;,list)&nbsp;(map&nbsp;.&nbsp;,map)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(memv&nbsp;.&nbsp;,memv)&nbsp;(null?&nbsp;.&nbsp;,null?)&nbsp;(pair?&nbsp;.&nbsp;,pair?)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(read&nbsp;.&nbsp;,read)&nbsp;(set-car!&nbsp;.&nbsp;,set-car!)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set-cdr!&nbsp;.&nbsp;,set-cdr!)&nbsp;(symbol?&nbsp;.&nbsp;,symbol?)))
<br>
<br>
&nbsp;;&nbsp;new-env&nbsp;returns&nbsp;a&nbsp;new&nbsp;environment&nbsp;from&nbsp;a&nbsp;formal&nbsp;parameter<br>

&nbsp;;&nbsp;specification,&nbsp;a&nbsp;list&nbsp;of&nbsp;actual&nbsp;parameters,&nbsp;and&nbsp;an&nbsp;outer<br>

&nbsp;;&nbsp;environment.&nbsp;&nbsp;The&nbsp;symbol?&nbsp;test&nbsp;identifies&nbsp;"improper"<br>

&nbsp;;&nbsp;argument&nbsp;lists.&nbsp;&nbsp;Environments&nbsp;are&nbsp;association&nbsp;lists,<br>

&nbsp;;&nbsp;associating&nbsp;variables&nbsp;with&nbsp;values.<br>

&nbsp;&nbsp;(define&nbsp;new-env<br>

&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(formals&nbsp;actuals&nbsp;env)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cond<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(null?&nbsp;formals)&nbsp;env]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(symbol?&nbsp;formals)&nbsp;(cons&nbsp;(cons&nbsp;formals&nbsp;actuals)&nbsp;env)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[else<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cons<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cons&nbsp;(car&nbsp;formals)&nbsp;(car&nbsp;actuals))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(new-env&nbsp;(cdr&nbsp;formals)&nbsp;(cdr&nbsp;actuals)&nbsp;env))])))
<br>
<br>
&nbsp;;&nbsp;lookup&nbsp;finds&nbsp;the&nbsp;value&nbsp;of&nbsp;the&nbsp;variable&nbsp;var&nbsp;in&nbsp;the&nbsp;environment<br>

&nbsp;;&nbsp;env,&nbsp;using&nbsp;assq.&nbsp;&nbsp;Assumes&nbsp;var&nbsp;is&nbsp;bound&nbsp;in&nbsp;env.<br>

&nbsp;&nbsp;(define&nbsp;lookup<br>

&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(var&nbsp;env)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cdr&nbsp;(assq&nbsp;var&nbsp;env))))
<br>
<br>
&nbsp;;&nbsp;assign&nbsp;is&nbsp;similar&nbsp;to&nbsp;lookup&nbsp;but&nbsp;alters&nbsp;the&nbsp;binding&nbsp;of&nbsp;the<br>

&nbsp;;&nbsp;variable&nbsp;var&nbsp;by&nbsp;changing&nbsp;the&nbsp;cdr&nbsp;of&nbsp;the&nbsp;association&nbsp;pair<br>

&nbsp;&nbsp;(define&nbsp;assign<br>

&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(var&nbsp;val&nbsp;env)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set-cdr!&nbsp;(assq&nbsp;var&nbsp;env)&nbsp;val)))
<br>
<br>
&nbsp;;&nbsp;exec&nbsp;evaluates&nbsp;the&nbsp;expression,&nbsp;recognizing&nbsp;a&nbsp;small&nbsp;set&nbsp;of&nbsp;core&nbsp;forms.<br>

&nbsp;&nbsp;(define&nbsp;exec<br>

&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(expr&nbsp;env)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cond<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(symbol?&nbsp;expr)&nbsp;(lookup&nbsp;expr&nbsp;env)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(pair?&nbsp;expr)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(case&nbsp;(car&nbsp;expr)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(quote)&nbsp;(cadr&nbsp;expr)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(lambda)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;vals<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([env&nbsp;(new-env&nbsp;(cadr&nbsp;expr)&nbsp;vals&nbsp;env)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;loop&nbsp;([exprs&nbsp;(cddr&nbsp;expr)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(null?&nbsp;(cdr&nbsp;exprs))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(exec&nbsp;(car&nbsp;exprs)&nbsp;env)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(begin<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(exec&nbsp;(car&nbsp;exprs)&nbsp;env)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(loop&nbsp;(cdr&nbsp;exprs)))))))]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(if)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(exec&nbsp;(cadr&nbsp;expr)&nbsp;env)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(exec&nbsp;(caddr&nbsp;expr)&nbsp;env)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(exec&nbsp;(cadddr&nbsp;expr)&nbsp;env))]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(set!)&nbsp;(assign&nbsp;(cadr&nbsp;expr)&nbsp;(exec&nbsp;(caddr&nbsp;expr)&nbsp;env)&nbsp;env)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[else<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(apply<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(exec&nbsp;(car&nbsp;expr)&nbsp;env)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(map&nbsp;(lambda&nbsp;(x)&nbsp;(exec&nbsp;x&nbsp;env))&nbsp;(cdr&nbsp;expr)))])]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[else&nbsp;expr])))
<br>
<br>
&nbsp;;&nbsp;interpret&nbsp;starts&nbsp;execution&nbsp;with&nbsp;the&nbsp;primitive&nbsp;environment.<br>

&nbsp;&nbsp;(define&nbsp;interpret<br>

&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(expr)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(exec&nbsp;expr&nbsp;&nbsp;primitive-environment))))</tt>
<p>
<h4>Exercise <a name="g188"></a>12.7.1</h4>
<a name="./examples:s52"></a>As written, the interpreter cannot interpret itself because it does
not support several of the syntactic forms used in its implementation:
<tt>let</tt> (named and unnamed), internal <tt>define</tt>, <tt>case</tt>, <tt>cond</tt>, and
<tt>begin</tt>.
Rewrite the code for the interpreter, using only the syntactic forms
it supports.

<p>

<h4>Exercise <a name="g189"></a>12.7.2</h4>
<a name="./examples:s53"></a>After completing the preceding exercise,
use the interpreter to run a copy of the interpreter, and use the copy to
run another copy of the interpreter.
Repeat this process to see how many levels deep it will go before the
system grinds to a halt.

<p>

<h4>Exercise <a name="g190"></a>12.7.3</h4>
<a name="./examples:s54"></a>At first glance, it might seem that the <tt>lambda</tt> case could be written
more simply as follows.

<p>

<p><tt>[(lambda)<br>

&nbsp;(lambda&nbsp;vals<br>

&nbsp;&nbsp;&nbsp;(let&nbsp;([env&nbsp;(new-env&nbsp;(cadr&nbsp;expr)&nbsp;vals&nbsp;env)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;loop&nbsp;([exprs&nbsp;(cddr&nbsp;expr)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([val&nbsp;(exec&nbsp;(car&nbsp;exprs)&nbsp;env)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(null?&nbsp;(cdr&nbsp;exprs))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(loop&nbsp;(cdr&nbsp;exprs)))))))]</tt>
<p>Why would this be incorrect?
[<i>Hint</i>: What property of Scheme would be violated?]

<p>

<h4>Exercise <a name="g191"></a>12.7.4</h4>
<a name="./examples:s55"></a>Try to make the interpreter more efficient by looking for ways to ask
fewer questions or to allocate less storage space.
[<i>Hint</i>: Before evaluation, convert lexical variable references into
<tt>(access&nbsp;<i>n</i>)</tt>, where <tt><i>n</i></tt> represents the number of values
in the environment association list in front of the value in question.]

<p>

<h4>Exercise <a name="g192"></a>12.7.5</h4>
<a name="./examples:s56"></a>Scheme evaluates arguments to a procedure before applying the procedure
and applies the procedure to the values of these arguments
(<a name="./examples:s57"></a><i>call-by-value</i>).
Modify the interpreter to pass arguments unevaluated and arrange to
evaluate them upon reference (<a name="./examples:s58"></a><i>call-by-name</i>).
[<i>Hint</i>: Use <tt>lambda</tt> to <a name="./examples:s59"></a>delay evaluation.]
You will need to create versions of the primitive procedures (<tt>car</tt>,
<tt>null?</tt>, etc.) that take their arguments unevaluated.

<p>

<h3><a name="g193"></a><a name="./examples:h8"></a>Section 12.8. Defining Abstract Objects<a name="SECTEXOBJECTS"></a></h3>



<p>
This example demonstrates a syntactic extension that facilitates the
definition of simple <a name="./examples:s60"></a>abstract objects (see Section&nbsp;<a href="./start.html#g40">2.9</a>).
This facility has unlimited potential as the basis for a complete
<a name="./examples:s61"></a>object-oriented subsystem in Scheme.

<p>
Abstract objects are similar to basic data structures such as pairs
and vectors.
Rather than being manipulated via access and assignment operators,
however, abstract objects respond to <a name="./examples:s62"></a><i>messages</i>.
The valid messages and the actions to be taken for each message are
defined by code within the object itself rather than by code outside
the object, resulting in more modular and potentially more secure
programming systems.
The data local to an abstract object is accessible only through the
actions performed by the object in response to the messages.

<p>
A particular type of abstract object is defined with <a name="./examples:s63"></a><tt>define-object</tt>,
which has the general form

<p>

<p><tt>(define-object&nbsp;(<i>name</i>&nbsp;<i>var<sub>1</sub></i>&nbsp;...)<br>

&nbsp;&nbsp;((<i>var<sub>2</sub></i>&nbsp;<i>expr</i>)&nbsp;...)<br>

&nbsp;&nbsp;((<i>msg</i>&nbsp;<i>action</i>)&nbsp;...))</tt>
<p>The first set of bindings <tt>((<i>var<sub>2</sub></i>&nbsp;<i>expr</i>)&nbsp;...)</tt> may be
omitted.
<tt>define-object</tt> defines a procedure that is called to create new
abstract objects of the given type.
This procedure is called <tt><i>name</i></tt>, and the arguments to
this procedure become the values of the local variables
<tt><i>var<sub>1</sub></i>&nbsp;...</tt>.
After the procedure is invoked, the variables <tt><i>var<sub>2</sub></i>&nbsp;...</tt> are
bound to the values <tt><i>expr</i>&nbsp;...</tt> in sequence (as with <tt>let*</tt>)
and the messages <tt><i>msg</i>&nbsp;...</tt> are bound to the procedure values
<tt><i>action</i>&nbsp;...</tt> in a mutually recursive fashion (as with <tt>letrec</tt>).
Within these bindings, the new abstract object is created; this object
is the value of the creation procedure.

<p>
The syntactic form <tt>send-message</tt> is used to send messages to
abstract objects.
<tt>(send-message&nbsp;<i>object</i>&nbsp;<i>msg</i>&nbsp;<i>arg</i>&nbsp;...)</tt> sends
<tt><i>object</i></tt> the message <tt><i>msg</i></tt> with arguments <tt><i>arg</i>&nbsp;...</tt>.
When an object receives a message, the <tt><i>arg</i>&nbsp;...</tt> become the
parameters to the action procedure associated with the message, and
the value returned by this procedure is returned by <tt>send-message</tt>.

<p>
The following examples should help to clarify how abstract objects are
defined and used.
The first example is a simple <tt>kons</tt> object that is similar to
Scheme's built-in pair object type, except that to access or assign
its fields requires sending it messages.

<p>

<p><tt>(define-object&nbsp;(kons&nbsp;kar&nbsp;kdr)<br>

&nbsp;&nbsp;((get-car&nbsp;(lambda&nbsp;()&nbsp;kar))<br>

&nbsp;&nbsp;&nbsp;(get-cdr&nbsp;(lambda&nbsp;()&nbsp;kdr))<br>

&nbsp;&nbsp;&nbsp;(set-car!&nbsp;(lambda&nbsp;(x)&nbsp;(set!&nbsp;kar&nbsp;x)))<br>

&nbsp;&nbsp;&nbsp;(set-cdr!&nbsp;(lambda&nbsp;(x)&nbsp;(set!&nbsp;kdr&nbsp;x)))))
<br>
<br>
(define&nbsp;p&nbsp;(kons&nbsp;'a&nbsp;'b))<br>

(send-message&nbsp;p&nbsp;get-car)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;a<br>

(send-message&nbsp;p&nbsp;get-cdr)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;b<br>

(send-message&nbsp;p&nbsp;set-cdr!&nbsp;'c)<br>

(send-message&nbsp;p&nbsp;get-cdr)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;c</tt>
<p>The simple <tt>kons</tt> object does nothing but return or assign one of
the fields as requested.
What makes abstract objects interesting is that they can be used to
restrict access or perform additional services.
The following version of <tt>kons</tt> requires that a password be given
with any request to assign one of the fields.
This password is a parameter to the <tt>kons</tt> procedure.

<p>

<p><tt>(define-object&nbsp;(kons&nbsp;kar&nbsp;kdr&nbsp;pwd)<br>

&nbsp;&nbsp;((get-car&nbsp;(lambda&nbsp;()&nbsp;kar))<br>

&nbsp;&nbsp;&nbsp;(get-cdr&nbsp;(lambda&nbsp;()&nbsp;kar))<br>

&nbsp;&nbsp;&nbsp;(set-car!<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(x&nbsp;p)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(string=?&nbsp;p&nbsp;pwd)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set!&nbsp;kar&nbsp;x))))<br>

&nbsp;&nbsp;&nbsp;(set-cdr!<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(x&nbsp;p)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(string=?&nbsp;p&nbsp;pwd)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set!&nbsp;kar&nbsp;x))))))
<br>
<br>
(define&nbsp;p1&nbsp;(kons&nbsp;'a&nbsp;'b&nbsp;"magnificent"))<br>

(send-message&nbsp;p1&nbsp;set-car!&nbsp;'c&nbsp;"magnificent")<br>

(send-message&nbsp;p1&nbsp;get-car)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;c<br>

(send-message&nbsp;p1&nbsp;set-car!&nbsp;'d&nbsp;"please")<br>

(send-message&nbsp;p1&nbsp;get-car)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;c
<br>
<br>
(define&nbsp;p2&nbsp;(kons&nbsp;'x&nbsp;'y&nbsp;"please"))<br>

(send-message&nbsp;p2&nbsp;set-car!&nbsp;'z&nbsp;"please")<br>

(send-message&nbsp;p2&nbsp;get-car)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;z</tt>
<p>One important ability of an abstract object is that it can keep
statistics on messages sent to it.
The following version of <tt>kons</tt> counts accesses to the two fields.
This version also demonstrates the use of explicitly initialized local
bindings.

<p>

<p><tt>(define-object&nbsp;(kons&nbsp;kar&nbsp;kdr)<br>

&nbsp;&nbsp;((count&nbsp;0))<br>

&nbsp;&nbsp;((get-car<br>

&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set!&nbsp;count&nbsp;(+&nbsp;count&nbsp;1))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;kar))<br>

&nbsp;&nbsp;&nbsp;(get-cdr<br>

&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set!&nbsp;count&nbsp;(+&nbsp;count&nbsp;1))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;kdr))<br>

&nbsp;&nbsp;&nbsp;&nbsp;(accesses<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;()&nbsp;count))))
<br>
<br>
(define&nbsp;p&nbsp;(kons&nbsp;'a&nbsp;'b))<br>

(send-message&nbsp;p&nbsp;get-car)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;a<br>

(send-message&nbsp;p&nbsp;get-cdr)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;b<br>

(send-message&nbsp;p&nbsp;accesses)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;2<br>

(send-message&nbsp;p&nbsp;get-cdr)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;b<br>

(send-message&nbsp;p&nbsp;accesses)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;3</tt>
<p>The implementation of <tt>define-object</tt> is straightforward.
The object definition is transformed into a definition of the object
creation procedure.
This procedure is the value of a <tt>lambda</tt> expression
whose arguments are those specified in the definition.
The body of the <tt>lambda</tt> consists of a <tt>let*</tt> expression
to bind the local variables and a <tt>letrec</tt> expression to bind
the message names to the action procedures.
The body of the <tt>letrec</tt> is another <tt>lambda</tt> expression whose
value represents the new object.
The body of this <tt>lambda</tt> expression compares the messages passed
in with the expected messages using a <tt>case</tt> expression and applies
the corresponding action procedure to the remaining arguments.

<p>
For example, the definition

<p><tt>(define-object&nbsp;(kons&nbsp;kar&nbsp;kdr)<br>

&nbsp;&nbsp;((count&nbsp;0))<br>

&nbsp;&nbsp;((get-car<br>

&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set!&nbsp;count&nbsp;(+&nbsp;count&nbsp;1))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;kar))<br>

&nbsp;&nbsp;&nbsp;(get-cdr<br>

&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set!&nbsp;count&nbsp;(+&nbsp;count&nbsp;1))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;kdr))<br>

&nbsp;&nbsp;&nbsp;(accesses<br>

&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;()&nbsp;count))))</tt>
<p>is transformed into

<p>

<p><tt>(define&nbsp;kons<br>

&nbsp;&nbsp;(lambda&nbsp;(kar&nbsp;kdr)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(let*&nbsp;([count&nbsp;0])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(letrec&nbsp;([get-car<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set!&nbsp;count&nbsp;(+&nbsp;count&nbsp;1))&nbsp;kar)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[get-cdr<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set!&nbsp;count&nbsp;(+&nbsp;count&nbsp;1))&nbsp;kdr)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[accesses&nbsp;(lambda&nbsp;()&nbsp;count)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(msg&nbsp;.&nbsp;args)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(case&nbsp;msg<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(get-car)&nbsp;(apply&nbsp;get-car&nbsp;args)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(get-cdr)&nbsp;(apply&nbsp;get-cdr&nbsp;args)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(accesses)&nbsp;(apply&nbsp;accesses&nbsp;args)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[else&nbsp;(assertion-violation&nbsp;'kons<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"invalid&nbsp;message"<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cons&nbsp;msg&nbsp;args))]))))))</tt>
<p>
<p><tt>
(library&nbsp;(tspl&nbsp;oop)<br>

&nbsp;&nbsp;(export&nbsp;define-object&nbsp;send-message)<br>

&nbsp;&nbsp;(import&nbsp;(rnrs))
<br>
<br>
&nbsp;;&nbsp;define-object&nbsp;creates&nbsp;an&nbsp;object&nbsp;constructor&nbsp;that&nbsp;uses&nbsp;let*&nbsp;to&nbsp;bind<br>

&nbsp;;&nbsp;local&nbsp;fields&nbsp;and&nbsp;letrec&nbsp;to&nbsp;define&nbsp;the&nbsp;exported&nbsp;procedures.&nbsp;&nbsp;An<br>

&nbsp;;&nbsp;object&nbsp;is&nbsp;itself&nbsp;a&nbsp;procedure&nbsp;that&nbsp;accepts&nbsp;messages&nbsp;corresponding<br>

&nbsp;;&nbsp;to&nbsp;the&nbsp;names&nbsp;of&nbsp;the&nbsp;exported&nbsp;procedures.&nbsp;&nbsp;The&nbsp;second&nbsp;pattern&nbsp;is<br>

&nbsp;;&nbsp;used&nbsp;to&nbsp;allow&nbsp;the&nbsp;set&nbsp;of&nbsp;local&nbsp;fields&nbsp;to&nbsp;be&nbsp;omitted.<br>

&nbsp;&nbsp;(define-syntax&nbsp;define-object<br>

&nbsp;&nbsp;&nbsp;&nbsp;(syntax-rules&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;(name&nbsp;.&nbsp;varlist)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((var1&nbsp;val1)&nbsp;...)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((var2&nbsp;val2)&nbsp;...))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(define&nbsp;name<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;varlist<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let*&nbsp;([var1&nbsp;val1]&nbsp;...)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(letrec&nbsp;([var2&nbsp;val2]&nbsp;...)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(msg&nbsp;.&nbsp;args)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(case&nbsp;msg<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(var2)&nbsp;(apply&nbsp;var2&nbsp;args)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[else<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(assertion-violation&nbsp;'name<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"invalid&nbsp;message"<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cons&nbsp;msg&nbsp;args))]))))))]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;(name&nbsp;.&nbsp;varlist)&nbsp;((var2&nbsp;val2)&nbsp;...))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(define-object&nbsp;(name&nbsp;.&nbsp;varlist)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((var2&nbsp;val2)&nbsp;...))]))
<br>
<br>
&nbsp;;&nbsp;send-message&nbsp;abstracts&nbsp;the&nbsp;act&nbsp;of&nbsp;sending&nbsp;a&nbsp;message&nbsp;from&nbsp;the&nbsp;act<br>

&nbsp;;&nbsp;of&nbsp;applying&nbsp;a&nbsp;procedure&nbsp;and&nbsp;allows&nbsp;the&nbsp;message&nbsp;to&nbsp;be&nbsp;unquoted.<br>

&nbsp;&nbsp;(define-syntax&nbsp;send-message<br>

&nbsp;&nbsp;&nbsp;&nbsp;(syntax-rules&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;obj&nbsp;msg&nbsp;arg&nbsp;...)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(obj&nbsp;'msg&nbsp;arg&nbsp;...)])))</tt>
<p>
<h4>Exercise <a name="g194"></a>12.8.1</h4>
<a name="./examples:s64"></a>Use <tt>define-object</tt> to define the <tt>stack</tt> object type from
Section&nbsp;<a href="./start.html#g40">2.9</a>.

<p>

<h4>Exercise <a name="g195"></a>12.8.2</h4>
<a name="./examples:s65"></a>Use <tt>define-object</tt> to define a <tt>queue</tt> object type
with operations similar to those described in
Section&nbsp;<a href="./start.html#g40">2.9</a>.

<p>

<h4>Exercise <a name="g196"></a>12.8.3</h4>
<a name="./examples:s66"></a>It is often useful to describe one object in terms of another.
For example, the second <tt>kons</tt> object type could be described
as the same as the first but with a password argument and different
actions associated with the <tt>set-car!</tt> and <tt>set-cdr!</tt>
messages.
This is called <a name="./examples:s67"></a><i>inheritance</i>; the new type of object is said to
<i>inherit</i> attributes from the first.
Modify <tt>define-object</tt> to support inheritance by allowing
the optional declaration <tt>(inherit&nbsp;object-name)</tt> to appear
after the message/action pairs.
This will require saving some information about each object definition
for possible use in subsequent object definitions.
Conflicting argument names should be disallowed, but other conflicts
should be resolved by using the initialization or action specified in
the new object definition.


<p>

<h4>Exercise <a name="g197"></a>12.8.4</h4>
<a name="./examples:s68"></a>Based on the definition of <tt>method</tt> on page&nbsp;<a href="./syntax.html#defn:method">317</a>,
define a complete object system, but use records rather than vectors to
represent object instances.
If done well, the resulting object system should be more efficient and
easier to use than the system given above.


<p>

<h3><a name="g198"></a><a name="./examples:h9"></a>Section 12.9. Fast Fourier Transform<a name="SECTEXFFT"></a></h3>



<p>
The procedure described in this section uses Scheme's
<a name="./examples:s69"></a>complex arithmetic
to compute the discrete
<a name="./examples:s70"></a><i>Fourier transform</i>
(DFT) of a sequence of values&nbsp;[<a class=citation href="./bibliography.html#g222">4</a>].
Discrete Fourier transforms are used to analyze and process sampled
signal sequences in a wide variety of digital electronics applications
such as pattern recognition, bandwidth compression, radar target
detection, and weather surveillance.

<p>
The DFT of a sequence of <i>N</i> input values,
<p>
{<i>x</i>(<i>n</i>)}<sub><i>n</i>=0</sub><sup><i>N</i>-1</sup>,<p>

is the sequence of <i>N</i> output values,
<p>
{<i>X</i>(<i>m</i>)}<sub><i>m</i>=0</sub><sup><i>N</i>-1</sup>,<p>

each defined by the equation
<p>
<img src="math/tspl/32.gif" alt="<graphic>"><p>

It is convenient to abstract away the constant amount (for given <i>N</i>)
<p>
<img src="math/tspl/33.gif" alt="<graphic>"><p>

in order to obtain the more concise but equivalent equation
<p>
<img src="math/tspl/34.gif" alt="<graphic>"><p>


<p>
A straightforward computation of the <i>N</i> output values, each as a sum
of <i>N</i> intermediate values, requires on the order of <i>N</i><sup>2</sup> operations.
A <i>fast</i> Fourier transform (FFT), applicable when <i>N</i> is a power
of 2, requires only on the order of <i>N</i>log<sub>2</sub><i>N</i> operations.
Although usually presented as a rather complicated iterative
algorithm, the fast Fourier transform
is most concisely and elegantly expressed as a recursive
algorithm.

<p>
The recursive algorithm, which is due to Sam&nbsp;Daniel&nbsp;[<a class=citation href="./bibliography.html#g225">7</a>],
can be derived by manipulating the preceding summation as follows.
We first split the summation into two summations and
recombine them into one summation from 0 to <i>N</i>/2 - 1.
<p>
<img src="math/tspl/35.gif" alt="<graphic>"><p>

We then pull out the common factor <img src="math/tspl/36.gif" alt="<graphic>">.
<p>
<img src="math/tspl/37.gif" alt="<graphic>"><p>

We can reduce <img src="math/tspl/38.gif" alt="<graphic>"> to 1 when <i>m</i> is even and -1 when <i>m</i> is
odd, since
<p>
<img src="math/tspl/39.gif" alt="<graphic>"><p>

This allows us to specialize the summation for the even and odd cases of
<i>m</i> = 2<i>k</i> and <i>m</i> = 2<i>k</i> + 1, 0 &le; <i>k</i> &le; <i>N</i>/2 - 1.
<p>
<img src="math/tspl/40.gif" alt="<graphic>"><p>

The resulting summations are DFTs of the
<i>N</i>/2-element sequences
<p>
{<i>x</i>(<i>n</i>) + <i>x</i>(<i>n</i> + <i>N</i>/2)}<sub><i>n</i>=0</sub><sup><i>N</i>/2-1</sup><p>

and
<p>
<img src="math/tspl/41.gif" alt="<graphic>"><p>

Thus, the DFT of an N-element sequence
can be computed recursively by interlacing the
DFTs of two <i>N</i>/2-element sequences.
If we select a base case of two elements, we can describe a recursive
fast Fourier transformation (RFFT) algorithm as follows.
For <i>N</i> = 2,
<p>
<img src="math/tspl/42.gif" alt="<graphic>"><p>

since <img src="math/tspl/43.gif" alt="<graphic>">.
For <i>N</i> &gt; 2,
<p>
<img src="math/tspl/44.gif" alt="<graphic>"><p>

with the attendant interlacing of even and odd components.

<p>

<p>
<img src="math/tspl/45.gif" alt="<graphic>"><p>



<p>
The diagram above is adapted from one by
Sam&nbsp;Daniel&nbsp;[<a class=citation href="./bibliography.html#g225">7</a>]
and shows the computational structure of the RFFT algorithm.
The first stage computes pairwise sums and differences
of the first and second halves of the input; this stage is labeled
the <i>butterfly</i> stage.
The second stage recurs on the resulting subsequences.
The third stage interlaces the output of the
two recursive calls to RFFT, thus yielding the properly ordered
sequence {<i>X</i>(<i>m</i>)}<sub><i>m</i>=0</sub><sup><i>N</i>-1</sup>.

<p>
The procedure <tt>dft</tt> accepts a sequence
(list) of values, <tt>x</tt>, the length of which
is assumed to be a power of 2.
<tt>dft</tt> precomputes a sequence of powers
of <img src="math/tspl/46.gif" alt="<graphic>">, <img src="math/tspl/47.gif" alt="<graphic>">, and calls <tt>rfft</tt> to
initiate the recursion.
<tt>rfft</tt> follows the algorithm outlined above.

<p>

<p><tt>
(define&nbsp;(dft&nbsp;x)<br>

&nbsp;&nbsp;(define&nbsp;(w-powers&nbsp;n)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([pi&nbsp;(*&nbsp;(acos&nbsp;0.0)&nbsp;2)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([delta&nbsp;(/&nbsp;(*&nbsp;-2.0i&nbsp;pi)&nbsp;n)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;f&nbsp;([n&nbsp;n]&nbsp;[x&nbsp;0.0])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(=&nbsp;n&nbsp;0)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'()<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cons&nbsp;(exp&nbsp;x)&nbsp;(f&nbsp;(-&nbsp;n&nbsp;2)&nbsp;(+&nbsp;x&nbsp;delta))))))))<br>

&nbsp;&nbsp;(define&nbsp;(evens&nbsp;w)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(null?&nbsp;w)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'()<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cons&nbsp;(car&nbsp;w)&nbsp;(evens&nbsp;(cddr&nbsp;w)))))<br>

&nbsp;&nbsp;(define&nbsp;(interlace&nbsp;x&nbsp;y)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(null?&nbsp;x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'()<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cons&nbsp;(car&nbsp;x)&nbsp;(cons&nbsp;(car&nbsp;y)&nbsp;(interlace&nbsp;(cdr&nbsp;x)&nbsp;(cdr&nbsp;y))))))<br>

&nbsp;&nbsp;(define&nbsp;(split&nbsp;ls)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;split&nbsp;([fast&nbsp;ls]&nbsp;[slow&nbsp;ls])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(null?&nbsp;fast)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(values&nbsp;'()&nbsp;slow)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let-values&nbsp;([(front&nbsp;back)&nbsp;(split&nbsp;(cddr&nbsp;fast)&nbsp;(cdr&nbsp;slow))])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(values&nbsp;(cons&nbsp;(car&nbsp;slow)&nbsp;front)&nbsp;back)))))<br>

&nbsp;&nbsp;(define&nbsp;(butterfly&nbsp;x&nbsp;w)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(let-values&nbsp;([(front&nbsp;back)&nbsp;(split&nbsp;x)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(values<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(map&nbsp;+&nbsp;front&nbsp;back)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(map&nbsp;*&nbsp;(map&nbsp;-&nbsp;front&nbsp;back)&nbsp;w))))<br>

&nbsp;&nbsp;(define&nbsp;(rfft&nbsp;x&nbsp;w)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(null?&nbsp;(cddr&nbsp;x))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([x0&nbsp;(car&nbsp;x)]&nbsp;[x1&nbsp;(cadr&nbsp;x)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(list&nbsp;(+&nbsp;x0&nbsp;x1)&nbsp;(-&nbsp;x0&nbsp;x1)))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let-values&nbsp;([(front&nbsp;back)&nbsp;(butterfly&nbsp;x&nbsp;w)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([w&nbsp;(evens&nbsp;w)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(interlace&nbsp;(rfft&nbsp;front&nbsp;w)&nbsp;(rfft&nbsp;back&nbsp;w))))))<br>

&nbsp;&nbsp;(rfft&nbsp;x&nbsp;(w-powers&nbsp;(length&nbsp;x))))</tt>
<p>
<h4>Exercise <a name="g199"></a>12.9.1</h4>
<a name="./examples:s71"></a>Alter the algorithm to employ a base case of four points.
What simplifications can be made to avoid multiplying any of the
base case outputs by elements of <tt>w</tt>?

<p>

<h4>Exercise <a name="g200"></a>12.9.2</h4>
<a name="./examples:s72"></a>Recode <tt>dft</tt> to accept a vector rather than a list as input, and
have it produce a vector as output.
Use lists internally if necessary, but do not simply convert the input to a
list on entry and the output to a vector on exit.

<p>

<h4>Exercise <a name="g201"></a>12.9.3</h4>
<a name="./examples:s73"></a>Rather than recomputing the powers of <tt>w</tt> on each step for a new
number of points, the code simply uses the even-numbered elements of
the preceding list of powers.
Show that doing so yields the proper list of powers.
That is, show that <tt>(evens&nbsp;(w-powers&nbsp;n))</tt> is equal to
<tt>(w-powers&nbsp;(/&nbsp;n&nbsp;2))</tt>.

<p>

<h4>Exercise <a name="g202"></a>12.9.4</h4>
<a name="./examples:s74"></a>The recursion step creates several intermediate lists that are
immediately discarded.
Recode the recursion step to avoid any unnecessary allocation.

<p>

<h4>Exercise <a name="g203"></a>12.9.5</h4>
<a name="./examples:s75"></a>Each element of a sequence of input values may be regenerated from
the discrete Fourier transform of the sequence via the equation
<p>
<img src="math/tspl/48.gif" alt="<graphic>"><p>

Noting the similarity between this equation and the original equation
defining <i>X</i>(<i>m</i>), create a modified version of <tt>dft</tt>,
<tt>inverse-dft</tt>, that performs the inverse transformation.
Verify that <tt>(inverse-dft&nbsp;(dft&nbsp;<i>seq</i>))</tt> returns
<tt><i>seq</i></tt> for several input sequences <tt><i>seq</i></tt>.

<p>

<h3><a name="g204"></a><a name="./examples:h10"></a>Section 12.10. A Unification Algorithm<a name="SECTEXUNIFY"></a></h3>



<p>
<i>Unification</i>&nbsp;[<a class=citation href="./bibliography.html#g241">23</a>] is a pattern-matching technique
used in automated theorem proving, type-inference systems, computer
algebra, and logic programming, e.g., Prolog&nbsp;[<a class=citation href="./bibliography.html#g224">6</a>].

<p>
A <a name="./examples:s76"></a>unification algorithm attempts to make two symbolic expressions
equal by computing a unifying substitution for the expressions.
A <i>substitution</i> is a function that replaces variables with other
expressions.
A substitution must treat all occurrences of a variable the same way,
e.g., if it replaces one occurrence of the variable <i>x</i> by <i>a</i>, it must
replace all occurrences of <i>x</i> by <i>a</i>.
A unifying substitution, or <i>unifier</i>, for two expressions <i>e</i><sub>1</sub> and
<i>e</i><sub>2</sub> is a substitution, <img src="math/tspl/22.gif" alt="<graphic>">, such that <img src="math/tspl/49.gif" alt="<graphic>">.

<p>
For example, the two expressions <i>f</i>(<i>x</i>) and <i>f</i>(<i>y</i>) can be unified by
substituting <i>x</i> for <i>y</i> (or <i>y</i> for <i>x</i>).
In this case, the unifier <img src="math/tspl/22.gif" alt="<graphic>"> could be described as the function
that replaces <i>y</i> with <i>x</i> and leaves other variables unchanged.
On the other hand, the two expressions <i>x</i> + 1 and <i>y</i> + 2 cannot be
unified.
It might appear that substituting 3 for <i>x</i> and 2 for <i>y</i> would
make both expressions equal to 4 and hence equal to each other.
The symbolic expressions, 3 + 1 and 2 + 2, however, still differ.

<p>
Two expressions may have more than one unifier.
For example, the expressions <i>f</i>(<i>x</i>,<i>y</i>) and <i>f</i>(1,<i>y</i>) can be unified to
<i>f</i>(1,<i>y</i>) with the substitution of 1 for <i>x</i>.
They may also be unified to <i>f</i>(1,5) with the substitution of 1 for
<i>x</i> and 5 for <i>y</i>.
The first substitution is preferable, since it does not commit to
the unnecessary replacement of <i>y</i>.
Unification algorithms typically produce the <i>most general unifier</i>,
or <i>mgu</i>, for two expressions.
The mgu for two expressions makes no unnecessary substitutions; all
other unifiers for the expressions are special cases of the mgu.
In the example above, the first substitution is the mgu and the second
is a special case.

<p>
For the purposes of this program, a symbolic expression can be a variable,
a constant, or a function application.
Variables are represented by Scheme symbols, e.g., <tt>x</tt>;
a function application is represented by a list with the function name in
the first position and its arguments in the remaining positions, e.g.,
<tt>(f&nbsp;x)</tt>; and
constants are represented by zero-argument functions, e.g., <tt>(a)</tt>.

<p>
The algorithm presented here finds the mgu for two terms, if it exists,
using a <a name="./examples:s77"></a>continuation-passing style, or
CPS (see Section&nbsp;<a href="./further.html#g75">3.4</a>),
approach to recursion on subterms.
The procedure <a name="./examples:s78"></a><tt>unify</tt> takes two terms and passes
them to a help procedure, <tt>uni</tt>, along with an initial (identity)
substitution, a success continuation, and a failure continuation.
The success continuation returns the result of applying its argument,
a substitution, to one of the terms, i.e., the unified result.
The failure continuation simply returns its argument, a message.
Because control passes by explicit continuation within <tt>unify</tt>
(always with tail calls), a return from the success or failure
continuation is a return from <tt>unify</tt> itself.

<p>
Substitutions are procedures.
Whenever a variable is to be replaced by another term, a new
substitution is formed from the variable, the term, and
the existing substitution.
Given a term as an argument, the new substitution replaces
occurrences of its saved variable with its saved term in the
result of invoking the saved substitution on the argument expression.
Intuitively, a substitution is a chain of procedures, one for each
variable in the substitution.
The chain is terminated by the initial, identity substitution.

<p>

<p><tt>(unify&nbsp;'x&nbsp;'y)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;y<br>

(unify&nbsp;'(f&nbsp;x&nbsp;y)&nbsp;'(g&nbsp;x&nbsp;y))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;"clash"<br>

(unify&nbsp;'(f&nbsp;x&nbsp;(h))&nbsp;'(f&nbsp;(h)&nbsp;y))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(f&nbsp;(h)&nbsp;(h))<br>

(unify&nbsp;'(f&nbsp;(g&nbsp;x)&nbsp;y)&nbsp;'(f&nbsp;y&nbsp;x))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;"cycle"<br>

(unify&nbsp;'(f&nbsp;(g&nbsp;x)&nbsp;y)&nbsp;'(f&nbsp;y&nbsp;(g&nbsp;x)))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(f&nbsp;(g&nbsp;x)&nbsp;(g&nbsp;x))<br>

(unify&nbsp;'(f&nbsp;(g&nbsp;x)&nbsp;y)&nbsp;'(f&nbsp;y&nbsp;z))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(f&nbsp;(g&nbsp;x)&nbsp;(g&nbsp;x))</tt>
<p>
<p><tt>
(library&nbsp;(tspl&nbsp;unification)<br>

&nbsp;&nbsp;(export&nbsp;unify)<br>

&nbsp;&nbsp;(import&nbsp;(rnrs))
<br>
<br>
&nbsp;;&nbsp;occurs?&nbsp;returns&nbsp;true&nbsp;if&nbsp;and&nbsp;only&nbsp;if&nbsp;u&nbsp;occurs&nbsp;in&nbsp;v<br>

&nbsp;&nbsp;(define&nbsp;occurs?<br>

&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(u&nbsp;v)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(and&nbsp;(pair?&nbsp;v)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;f&nbsp;([l&nbsp;(cdr&nbsp;v)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(and&nbsp;(pair?&nbsp;l)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(or&nbsp;(eq?&nbsp;u&nbsp;(car&nbsp;l))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(occurs?&nbsp;u&nbsp;(car&nbsp;l))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(f&nbsp;(cdr&nbsp;l))))))))
<br>
<br>
&nbsp;;&nbsp;sigma&nbsp;returns&nbsp;a&nbsp;new&nbsp;substitution&nbsp;procedure&nbsp;extending&nbsp;s&nbsp;by<br>

&nbsp;;&nbsp;the&nbsp;substitution&nbsp;of&nbsp;u&nbsp;with&nbsp;v<br>

&nbsp;&nbsp;(define&nbsp;sigma<br>

&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(u&nbsp;v&nbsp;s)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;f&nbsp;([x&nbsp;(s&nbsp;x)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(symbol?&nbsp;x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(eq?&nbsp;x&nbsp;u)&nbsp;v&nbsp;x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cons&nbsp;(car&nbsp;x)&nbsp;(map&nbsp;f&nbsp;(cdr&nbsp;x))))))))
<br>
<br>
&nbsp;;&nbsp;try-subst&nbsp;tries&nbsp;to&nbsp;substitute&nbsp;u&nbsp;for&nbsp;v&nbsp;but&nbsp;may&nbsp;require&nbsp;a<br>

&nbsp;;&nbsp;full&nbsp;unification&nbsp;if&nbsp;(s&nbsp;u)&nbsp;is&nbsp;not&nbsp;a&nbsp;variable,&nbsp;and&nbsp;it&nbsp;may<br>

&nbsp;;&nbsp;fail&nbsp;if&nbsp;it&nbsp;sees&nbsp;that&nbsp;u&nbsp;occurs&nbsp;in&nbsp;v.<br>

&nbsp;&nbsp;(define&nbsp;try-subst<br>

&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(u&nbsp;v&nbsp;s&nbsp;ks&nbsp;kf)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([u&nbsp;(s&nbsp;u)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(not&nbsp;(symbol?&nbsp;u))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(uni&nbsp;u&nbsp;v&nbsp;s&nbsp;ks&nbsp;kf)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([v&nbsp;(s&nbsp;v)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cond<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(eq?&nbsp;u&nbsp;v)&nbsp;(ks&nbsp;s)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(occurs?&nbsp;u&nbsp;v)&nbsp;(kf&nbsp;"cycle")]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[else&nbsp;(ks&nbsp;(sigma&nbsp;u&nbsp;v&nbsp;s))]))))))
<br>
<br>
&nbsp;;&nbsp;uni&nbsp;attempts&nbsp;to&nbsp;unify&nbsp;u&nbsp;and&nbsp;v&nbsp;with&nbsp;a&nbsp;continuation-passing<br>

&nbsp;;&nbsp;style&nbsp;that&nbsp;returns&nbsp;a&nbsp;substitution&nbsp;to&nbsp;the&nbsp;success&nbsp;argument<br>

&nbsp;;&nbsp;ks&nbsp;or&nbsp;an&nbsp;error&nbsp;message&nbsp;to&nbsp;the&nbsp;failure&nbsp;argument&nbsp;kf.&nbsp;&nbsp;The<br>

&nbsp;;&nbsp;substitution&nbsp;itself&nbsp;is&nbsp;represented&nbsp;by&nbsp;a&nbsp;procedure&nbsp;from<br>

&nbsp;;&nbsp;variables&nbsp;to&nbsp;terms.<br>

&nbsp;&nbsp;(define&nbsp;uni<br>

&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(u&nbsp;v&nbsp;s&nbsp;ks&nbsp;kf)<br>

<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cond<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(symbol?&nbsp;u)&nbsp;(try-subst&nbsp;u&nbsp;v&nbsp;s&nbsp;ks&nbsp;kf)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(symbol?&nbsp;v)&nbsp;(try-subst&nbsp;v&nbsp;u&nbsp;s&nbsp;ks&nbsp;kf)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(and&nbsp;(eq?&nbsp;(car&nbsp;u)&nbsp;(car&nbsp;v))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(=&nbsp;(length&nbsp;u)&nbsp;(length&nbsp;v)))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;f&nbsp;([u&nbsp;(cdr&nbsp;u)]&nbsp;[v&nbsp;(cdr&nbsp;v)]&nbsp;[s&nbsp;s])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(null?&nbsp;u)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(ks&nbsp;s)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(uni&nbsp;(car&nbsp;u)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(car&nbsp;v)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(s)&nbsp;(f&nbsp;(cdr&nbsp;u)&nbsp;(cdr&nbsp;v)&nbsp;s))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;kf)))]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[else&nbsp;(kf&nbsp;"clash")])))
<br>
<br>
&nbsp;;&nbsp;unify&nbsp;shows&nbsp;one&nbsp;possible&nbsp;interface&nbsp;to&nbsp;uni,&nbsp;where&nbsp;the&nbsp;initial<br>

&nbsp;;&nbsp;substitution&nbsp;is&nbsp;the&nbsp;identity&nbsp;procedure,&nbsp;the&nbsp;initial&nbsp;success<br>

&nbsp;;&nbsp;continuation&nbsp;returns&nbsp;the&nbsp;unified&nbsp;term,&nbsp;and&nbsp;the&nbsp;initial&nbsp;failure<br>

&nbsp;;&nbsp;continuation&nbsp;returns&nbsp;the&nbsp;error&nbsp;message.<br>

&nbsp;&nbsp;(define&nbsp;unify<br>

&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(u&nbsp;v)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(uni&nbsp;u<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(x)&nbsp;x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(s)&nbsp;(s&nbsp;u))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(msg)&nbsp;msg)))))</tt>
<p>
<h4>Exercise <a name="g205"></a>12.10.1</h4>
<a name="./examples:s79"></a>Modify <tt>unify</tt> so that it returns its substitution rather
than the unified term.
Apply this substitution to both input terms to verify that it
returns the same result for each.

<p>

<h4>Exercise <a name="g206"></a>12.10.2</h4>
<a name="./examples:s80"></a>As mentioned above, substitutions on a term are performed
sequentially, requiring one entire pass through the input expression
for each substituted variable.
Represent the substitution differently so that only one pass
through the expression need be made.
Make sure that substitutions are performed not only on the input
expression but also on any expressions you insert during substitution.

<p>

<h4>Exercise <a name="g207"></a>12.10.3</h4>
<a name="./examples:s81"></a>Extend the continuation-passing style unification algorithm into
an entire continuation-passing style logic programming system.



<p>

<h3><a name="g208"></a><a name="./examples:h11"></a>Section 12.11. Multitasking with Engines<a name="SECTEXENGINES"></a></h3>



<p>
<a name="./examples:s82"></a>Engines are a high-level process abstraction supporting
<a name="./examples:s83"></a><i>timed
preemption</i>&nbsp;[<a class=citation href="./bibliography.html#g228">10</a>,<a class=citation href="./bibliography.html#g233">15</a>].
Engines may be used to simulate <a name="./examples:s84"></a>multiprocessing,
implement <a name="./examples:s85"></a><a name="./examples:s86"></a>light-weight threads,
implement operating
system kernels, and perform <a name="./examples:s87"></a>nondeterministic computations.
The engine implementation is one of the more interesting applications
of <a name="./examples:s88"></a>continuations in Scheme.

<p>
An engine is created by passing a thunk (procedure of no arguments)
to the procedure <tt>make-engine</tt>.
The body of the thunk is the computation to be performed by the engine.
An engine itself is a procedure of three arguments:

<p>
<ol>
<a name="g209"></a><li><a name="./examples:s89"></a><tt><i>ticks</i></tt>,
a positive integer that specifies the amount of <i>fuel</i> to be given
to the engine.
An engine executes until this fuel runs out or until its computation
finishes.

<p>
<a name="g210"></a><li><a name="./examples:s90"></a><tt><i>complete</i></tt>,
a procedure of two arguments that
specifies what to do if the computation finishes.
Its arguments will be the amount of fuel left over and the
result of the computation.

<p>
<a name="g211"></a><li><a name="./examples:s91"></a><tt><i>expire</i></tt>,
a procedure of one argument that specifies what to do if the fuel runs
out before the computation finishes.
Its argument will be a new engine capable of continuing the computation
from the point of interruption.
</ol>
<p>

<p>
When an engine is applied to its arguments, it sets up a timer
to fire in <tt><i>ticks</i></tt> time units.
If the engine computation completes before the timer goes off, the
system invokes <tt><i>complete</i></tt>, passing it the
number of <tt><i>ticks</i></tt> left over
and the value of the computation.
If, on the other hand, the timer goes off before the engine computation
completes, the system creates a new engine from the continuation of
the interrupted computation and passes this engine to <tt><i>expire</i></tt>.
<tt><i>complete</i></tt> and <tt><i>expire</i></tt> are invoked in the continuation
of the engine invocation.

<p>
The following example creates an engine from a trivial computation,
3, and gives the engine 10 ticks.

<p>

<p><tt>(define&nbsp;eng<br>

&nbsp;&nbsp;(make-engine<br>

&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;()&nbsp;3)))
<br>
<br>
(eng&nbsp;10<br>

&nbsp;&nbsp;(lambda&nbsp;(ticks&nbsp;value)&nbsp;value)<br>

&nbsp;&nbsp;(lambda&nbsp;(x)&nbsp;x))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;3</tt>
<p>It is often useful to pass <tt>list</tt> as the <tt><i>complete</i></tt> procedure
to an engine, causing the engine to return a list of the
ticks remaining and the value if the computation completes.

<p>

<p><tt>(eng&nbsp;10<br>

&nbsp;&nbsp;list<br>

&nbsp;&nbsp;(lambda&nbsp;(x)&nbsp;x))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(9&nbsp;3)</tt>
<p>In the example above, the value was 3 and there were 9 ticks left over,
i.e., it took only one unit of fuel to evaluate 3.
(The fuel amounts given here are for illustration only.
The actual amount may differ.)

<p>
Typically, the engine computation does not finish in one try.
<a name="./examples:s92"></a>The following example displays the use of an engine to
compute the 10th Fibonacci number (see Section&nbsp;<a href="./further.html#g55">3.2</a>)
in steps.

<p>

<p><tt>(define&nbsp;fibonacci<br>

&nbsp;&nbsp;(lambda&nbsp;(n)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(&lt;&nbsp;n&nbsp;2)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(+&nbsp;(fibonacci&nbsp;(-&nbsp;n&nbsp;1))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(fibonacci&nbsp;(-&nbsp;n&nbsp;2))))))
<br>
<br>
(define&nbsp;eng<br>

&nbsp;&nbsp;(make-engine<br>

&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(fibonacci&nbsp;10))))
<br>
<br>
(eng&nbsp;50<br>

&nbsp;&nbsp;list<br>

&nbsp;&nbsp;(lambda&nbsp;(new-eng)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(set!&nbsp;eng&nbsp;new-eng)<br>

&nbsp;&nbsp;&nbsp;&nbsp;"expired"))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;"expired"
<br>
<br>
(eng&nbsp;50<br>

&nbsp;&nbsp;list<br>

&nbsp;&nbsp;(lambda&nbsp;(new-eng)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(set!&nbsp;eng&nbsp;new-eng)<br>

&nbsp;&nbsp;&nbsp;&nbsp;"expired"))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;"expired"
<br>
<br>
(eng&nbsp;50<br>

&nbsp;&nbsp;list<br>

&nbsp;&nbsp;(lambda&nbsp;(new-eng)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(set!&nbsp;eng&nbsp;new-eng)<br>

&nbsp;&nbsp;&nbsp;&nbsp;"expired"))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;"expired"
<br>
<br>
(eng&nbsp;50<br>

&nbsp;&nbsp;list<br>

&nbsp;&nbsp;(lambda&nbsp;(new-eng)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(set!&nbsp;eng&nbsp;new-eng)<br>

&nbsp;&nbsp;&nbsp;&nbsp;"expired"))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(22&nbsp;55)</tt>
<p>Each time the engine's fuel ran out, the <tt><i>expire</i></tt> procedure assigned
<tt>eng</tt> to the new engine.
The entire computation required four allotments of 50 ticks to complete; of the
last 50 it used all but 23.
Thus, the total amount of fuel used was 177 ticks.
This leads us to the following procedure, <tt>mileage</tt>, which
uses engines to "time" a computation.

<p>

<p><tt>(define&nbsp;mileage<br>

&nbsp;&nbsp;(lambda&nbsp;(thunk)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;loop&nbsp;([eng&nbsp;(make-engine&nbsp;thunk)]&nbsp;[total-ticks&nbsp;0])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(eng&nbsp;50<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(ticks&nbsp;value)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(+&nbsp;total-ticks&nbsp;(-&nbsp;50&nbsp;ticks)))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(new-eng)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(loop&nbsp;new-eng&nbsp;(+&nbsp;total-ticks&nbsp;50)))))))
<br>
<br>
(mileage&nbsp;(lambda&nbsp;()&nbsp;(fibonacci&nbsp;10)))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;178</tt>
<p>The choice of 50 for the number of ticks to use each time is
arbitrary, of course.
It might make more sense to pass a much larger number, say 10000,
in order to reduce the number of times the computation is interrupted.

<p>
The next procedure, <a name="./examples:s93"></a><tt>round-robin</tt>, could be the basis for a simple
time-sharing <a name="./examples:s94"></a>operating system.
<tt>round-robin</tt> maintains a queue of processes (a list of engines)
and cycles through the queue in a <i>round-robin</i> fashion, allowing each
process to run for a set amount of time.
<tt>round-robin</tt> returns a list of the values returned by the engine
computations in the order that the computations complete.

<p>

<p><tt>(define&nbsp;round-robin<br>

&nbsp;&nbsp;(lambda&nbsp;(engs)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(null?&nbsp;engs)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'()<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((car&nbsp;engs)&nbsp;1<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(ticks&nbsp;value)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cons&nbsp;value&nbsp;(round-robin&nbsp;(cdr&nbsp;engs))))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(eng)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(round-robin<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(append&nbsp;(cdr&nbsp;engs)&nbsp;(list&nbsp;eng))))))))</tt>
<p>Assuming the amount of computation corresponding to one tick is constant,
the effect of <tt>round-robin</tt> is to return a list of the values sorted
from the quickest to complete to the slowest to complete.
Thus, when we call <tt>round-robin</tt> on a list of engines, each computing
one of the Fibonacci numbers, the output list is sorted with the earlier
Fibonacci numbers first, regardless of the order of the input list.

<p>

<p><tt>(round-robin<br>

&nbsp;&nbsp;(map&nbsp;(lambda&nbsp;(x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(make-engine<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(fibonacci&nbsp;x))))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'(4&nbsp;5&nbsp;2&nbsp;8&nbsp;3&nbsp;7&nbsp;6&nbsp;2)))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(1&nbsp;1&nbsp;2&nbsp;3&nbsp;5&nbsp;8&nbsp;13&nbsp;21)</tt>
<p>More interesting things could happen if the amount of fuel varied
each time through the loop.
<a name="./examples:s95"></a>In this case, the computation would
be nondeterministic, i.e., the results would vary from call to call.

<p>
The following syntactic form, <a name="./examples:s96"></a><tt>por</tt> (parallel-or), returns the
first of its expressions to complete with a true value.
<tt>por</tt> is implemented with the procedure <tt>first-true</tt>, which is
similar to <tt>round-robin</tt> but quits when any of the engines
completes with a true value.
If all of the engines complete, but none with a true value,
<tt>first-true</tt> (and hence <tt>por</tt>) returns <tt>#f</tt>.

<p>

<p><tt>(define-syntax&nbsp;por<br>

&nbsp;&nbsp;(syntax-rules&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;x&nbsp;...)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(first-true<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(list&nbsp;(make-engine&nbsp;(lambda&nbsp;()&nbsp;x))&nbsp;...))]))
<br>
<br>
(define&nbsp;first-true<br>

&nbsp;&nbsp;(lambda&nbsp;(engs)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(null?&nbsp;engs)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#f<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((car&nbsp;engs)&nbsp;1<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(ticks&nbsp;value)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(or&nbsp;value&nbsp;(first-true&nbsp;(cdr&nbsp;engs))))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(eng)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(first-true<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(append&nbsp;(cdr&nbsp;engs)&nbsp;(list&nbsp;eng))))))))</tt>
<p>Even if one of the expressions is an infinite loop,
<tt>por</tt> can still finish (as long as one of the other expressions
completes and returns a true value).

<p>

<p><tt>(por&nbsp;1&nbsp;2)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;1<br>

(por&nbsp;((lambda&nbsp;(x)&nbsp;(x&nbsp;x))&nbsp;(lambda&nbsp;(x)&nbsp;(x&nbsp;x)))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(fibonacci&nbsp;10))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;55</tt>
<p>The first subexpression of the second <tt>por</tt> expression is
nonterminating, so the answer is the value of the second
subexpression.

<p>
Let's turn to the implementation of engines.
Any preemptive multitasking primitive must have the ability to
interrupt a running process after a given amount of computation.
This ability is provided by a primitive <a name="./examples:s97"></a>timer
interrupt mechanism in some Scheme implementations.
We will construct a suitable one here.

<p>
Our timer system defines three procedures: <tt>start-timer</tt>, <tt>stop-timer</tt>,
and <tt>decrement-timer</tt>, which can be described operationally as
follows.

<p>
<ul>
<li><tt>(start-timer&nbsp;<i>ticks</i>&nbsp;<i>handler</i>)</tt>
sets the timer
to <tt><i>ticks</i></tt> and installs <tt><i>handler</i></tt> as the procedure to be
invoked (without arguments) when the timer expires, i.e., reaches zero.

<p>
<li><tt>(stop-timer)</tt>
resets the timer and returns the number of ticks remaining.

<p>
<li><tt>(decrement-timer)</tt>
decrements the timer by one tick if the timer is on, i.e., if it is
not zero.
When the timer reaches zero, <tt>decrement-timer</tt> invokes the saved
handler.
If the timer has already reached zero, <tt>decrement-timer</tt> returns
without changing the timer.
</ul>
<p>

<p>
Code to implement these procedures is given along with the engine
implementation below.

<p>
Using the timer system requires inserting calls to <tt>decrement-timer</tt> in
appropriate places.
Consuming a timer tick on entry to a procedure usually provides a sufficient
level of granularity.
This can be accomplished by using <tt>timed-lambda</tt> as defined below
in place of <tt>lambda</tt>.
<tt>timed-lambda</tt> simply invokes <tt>decrement-timer</tt> before executing the
expressions in its body.

<p>

<p><tt>(define-syntax&nbsp;timed-lambda<br>

&nbsp;&nbsp;(syntax-rules&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;formals&nbsp;exp1&nbsp;exp2&nbsp;...)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;formals&nbsp;(decrement-timer)&nbsp;exp1&nbsp;exp2&nbsp;...)]))</tt>
<p>It may be useful to redefine named <tt>let</tt> and <tt>do</tt> to use <tt>timed-lambda</tt>
as well, so that recursions expressed with these constructs are
timed.
If you use this mechanism, do not forget to use the timed versions of
<tt>lambda</tt> and other forms in code run within an engine, or no
ticks will be consumed.

<p>
Now that we have a suitable timer, we can implement engines in terms of
the timer and continuations.
We use <a name="./examples:s98"></a><tt>call/cc</tt> in two places in the engine
implementation: (1) to obtain the continuation of the computation that invokes
the engine so that we can return to that continuation when the engine
computation completes or the timer expires, and (2) to obtain the continuation
of the engine computation when the timer expires so that we can return
to this computation if the newly created engine is subsequently run.

<p>
The state of the engine system is contained in two variables local to
the engine system: <tt>do-complete</tt> and <tt>do-expire</tt>.
When an engine is started, the engine assigns to <tt>do-complete</tt> and
<tt>do-expire</tt> procedures
that, when invoked, return to the continuation of the engine's caller
to invoke <tt><i>complete</i></tt> or <tt><i>expire</i></tt>.
The engine starts (or restarts) the computation by invoking
the procedure passed as an argument to <tt>make-engine</tt> with the specified
number of ticks.
The ticks and the local procedure <tt>timer-handler</tt> are then used to
start the timer.

<p>
Suppose that the timer expires before the engine computation completes.
The procedure <tt>timer-handler</tt> is then invoked.
It initiates a call to <tt>start-timer</tt> but obtains the ticks by calling
<tt>call/cc</tt> with <tt>do-expire</tt>.
Consequently, <tt>do-expire</tt> is
called with a continuation that, if invoked,
will restart the timer and continue the interrupted computation.
<tt>do-expire</tt> creates a new engine from this continuation and
arranges for the engine's <tt><i>expire</i></tt> procedure to be invoked with the new
engine in the correct continuation.

<p>
If, on the other hand, the engine computation completes before
the timer expires, the timer is stopped and the number of ticks remaining
is passed along with the value to <tt>do-complete</tt>;
<tt>do-complete</tt> arranges for the engine's <tt><i>complete</i></tt> procedure
to be invoked with the ticks and value in the correct continuation.

<p>
Let's discuss a couple of subtle aspects to this code.
The first concerns the method used to start the timer when an engine
is invoked.
The code would apparently be simplified by letting <tt>new-engine</tt> start
the timer before it initiates or resumes the engine computation, instead
of passing the ticks to the computation and letting it start the timer.
Starting the timer within the computation, however, prevents ticks from
being consumed prematurely.
If the engine system itself consumes fuel, then an engine provided with a
small amount of fuel may not progress toward completion.
(It may, in fact, make negative progress.)
If the software timer described above is used, this problem is actually
avoided by compiling the engine-making code with the untimed version of
<tt>lambda</tt>.

<p>
The second subtlety concerns the procedures created by <tt>do-complete</tt> and
<tt>do-expire</tt> and subsequently applied by the continuation of the
<a name="./examples:s99"></a><a name="./examples:s100"></a><tt>call/cc</tt> application.
It may appear that <tt>do-complete</tt> could first invoke the engine's
<tt><i>complete</i></tt> procedure, then pass the result to the continuation
(and similarly for <tt>do-expire</tt>) as follows.

<p>

<p><tt>(escape&nbsp;(complete&nbsp;value&nbsp;ticks))</tt>
<p>This would result in improper treatment of tail recursion, however.
The problem is that the current continuation would not be replaced with the
continuation stored in <tt>escape</tt> until the call to the <tt>complete</tt>
procedure returns.
Consequently, both the continuation of the running engine and the continuation
of the engine invocation could be retained for an indefinite period of time,
when in fact the actual engine invocation may appear to be tail-recursive.
This is especially inappropriate because the engine interface encourages use of
continuation-passing style and hence tail recursion.
The round-robin scheduler and <tt>first-true</tt> provide good examples of this,
since the <tt><i>expire</i></tt> procedure in each invokes engines tail-recursively.

<p>
We maintain proper treatment of tail recursion by arranging for
<tt>do-complete</tt> and <tt>do-expire</tt> to escape from
the continuation of the running engine before invoking the <tt>complete</tt> or
<tt>expire</tt> procedures.
Since the continuation of the engine invocation is a procedure application,
passing it a procedure of no arguments results in application of the procedure
in the continuation of the engine invocation.

<p>

<p><tt>
(library&nbsp;(tspl&nbsp;timer)<br>

&nbsp;&nbsp;(export&nbsp;start-timer&nbsp;stop-timer&nbsp;decrement-timer)<br>

&nbsp;&nbsp;(import&nbsp;(rnrs))
<br>
<br>
&nbsp;&nbsp;(define&nbsp;clock&nbsp;0)<br>

&nbsp;&nbsp;(define&nbsp;handler&nbsp;#f)
<br>
<br>
&nbsp;&nbsp;(define&nbsp;start-timer<br>

&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(ticks&nbsp;new-handler)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set!&nbsp;handler&nbsp;new-handler)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set!&nbsp;clock&nbsp;ticks)))
<br>
<br>
&nbsp;&nbsp;(define&nbsp;stop-timer<br>

&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([time-left&nbsp;clock])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set!&nbsp;clock&nbsp;0)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;time-left)))
<br>
<br>
&nbsp;&nbsp;(define&nbsp;decrement-timer<br>

&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(when&nbsp;(&gt;&nbsp;clock&nbsp;0)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set!&nbsp;clock&nbsp;(-&nbsp;clock&nbsp;1))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(when&nbsp;(=&nbsp;clock&nbsp;0)&nbsp;(handler)))))
<br>
<br>
&nbsp;&nbsp;(define-syntax&nbsp;timed-lambda<br>

&nbsp;&nbsp;&nbsp;&nbsp;(syntax-rules&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;formals&nbsp;exp1&nbsp;exp2&nbsp;...)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;formals&nbsp;(decrement-timer)&nbsp;exp1&nbsp;exp2&nbsp;...)])))
<br>
<br>
(library&nbsp;(tspl&nbsp;engines)<br>

&nbsp;&nbsp;(export&nbsp;make-engine&nbsp;timed-lambda)<br>

&nbsp;&nbsp;(import&nbsp;(rnrs)&nbsp;(tspl&nbsp;timer))
<br>
<br>
&nbsp;&nbsp;(define&nbsp;make-engine<br>

&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([do-complete&nbsp;#f]&nbsp;[do-expire&nbsp;#f])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(define&nbsp;timer-handler<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(start-timer&nbsp;(call/cc&nbsp;do-expire)&nbsp;timer-handler)))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(define&nbsp;new-engine<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(resume)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(ticks&nbsp;complete&nbsp;expire)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((call/cc<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(escape)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set!&nbsp;do-complete<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(ticks&nbsp;value)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(escape&nbsp;(lambda&nbsp;()&nbsp;(complete&nbsp;ticks&nbsp;value)))))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set!&nbsp;do-expire<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(resume)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(escape&nbsp;(lambda&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(expire&nbsp;(new-engine&nbsp;resume))))))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(resume&nbsp;ticks)))))))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(proc)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(new-engine<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(ticks)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(start-timer&nbsp;ticks&nbsp;timer-handler)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([value&nbsp;(proc)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([ticks&nbsp;(stop-timer)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(do-complete&nbsp;ticks&nbsp;value))))))))
<br>
<br>
&nbsp;&nbsp;(define-syntax&nbsp;timed-lambda<br>

&nbsp;&nbsp;&nbsp;&nbsp;(syntax-rules&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;formals&nbsp;exp1&nbsp;exp2&nbsp;...)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;formals&nbsp;(decrement-timer)&nbsp;exp1&nbsp;exp2&nbsp;...)])))</tt>
<p>
<h4>Exercise <a name="g212"></a>12.11.1</h4>
<a name="./examples:s101"></a>If your Scheme implementation allows definition and import of libraries
in the interactive top level, try defining the libraries above, then
type

<p>

<p><tt>(import&nbsp;(rename&nbsp;(tspl&nbsp;engines)&nbsp;(timed-lambda&nbsp;lambda)))</tt>
<p>to define <tt>make-engine</tt> and redefine <tt>lambda</tt>.
Then try out the examples given earlier in this section.

<p>

<h4>Exercise <a name="g213"></a>12.11.2</h4>
<a name="./examples:s102"></a>It may appear that the nested <tt>let</tt> expressions in the body of
<tt>make-engine</tt>:

<p>

<p><tt>(let&nbsp;([value&nbsp;(proc)])<br>

&nbsp;&nbsp;(let&nbsp;([ticks&nbsp;(stop-timer)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;(do-complete&nbsp;ticks&nbsp;value)))</tt>
<p>could be replaced with the following.

<p>

<p><tt>(let&nbsp;([value&nbsp;(proc)]&nbsp;[ticks&nbsp;(stop-timer)])<br>

&nbsp;&nbsp;(do-complete&nbsp;value&nbsp;ticks))</tt>
<p>Why is this not correct?

<p>

<h4>Exercise <a name="g214"></a>12.11.3</h4>
<a name="./examples:s103"></a>It would also be incorrect to replace the
nested <tt>let</tt> expressions discussed in the preceding exercise
with the following.

<p>

<p><tt>(let&nbsp;([value&nbsp;(proc)])<br>

&nbsp;&nbsp;(do-complete&nbsp;value&nbsp;(stop-timer)))</tt>
<p>Why?

<p>

<h4>Exercise <a name="g215"></a>12.11.4</h4>
<a name="./examples:s104"></a>Modify the engine implementation to provide a procedure,
<tt>engine-return</tt>, that returns immediately from an engine.

<p>

<h4>Exercise <a name="g216"></a>12.11.5</h4>
<a name="./examples:s105"></a>Implement the kernel of a small <a name="./examples:s106"></a>operating
system using engines for processes.
Processes should request services (such as reading input from the user)
by evaluating an expression of the form <tt>(trap&nbsp;'request)</tt>.
Use <tt>call/cc</tt> and <tt>engine-return</tt> from the preceding
exercise to implement <tt>trap</tt>.

<p>

<h4>Exercise <a name="g217"></a>12.11.6</h4>
<a name="./examples:s107"></a>Write the same operating-system kernel without using engines, building
instead from continuations and timer interrupts.

<p>

<h4>Exercise <a name="g218"></a>12.11.7</h4>
<a name="./examples:s108"></a>This implementation of engines does not allow one engine to call
another, i.e., nested engines&nbsp;[<a class=citation href="./bibliography.html#g228">10</a>].
Modify the implementation to allow <a name="./examples:s109"></a>nested
engines.

<p>




<hr class=copyright align=left>
<p>
R. Kent Dybvig / <it>The Scheme Programming Language, Fourth Edition</it><br>
Copyright &copy; 2009 <a class=plain href="http://mitpress.mit.edu/catalog/item/default.asp?ttype=2&tid=11984">The MIT Press</a>.  Electronically reproduced by permission.<br>
Illustrations &copy; 2009 <a class=plain href="http://hebert.kitp.ucsb.edu/">Jean-Pierre H&eacute;bert</a><br>
ISBN 978-0-262-51298-5 / LOC QA76.73.S34D93<br>
<a class=plain href="http://mitpress.mit.edu/catalog/item/default.asp?ttype=2&tid=11984">to order this book</a> / <a class=plain href="canned/about.html">about this book</a>
</p>
<p><a class=plain href="http://www.scheme.com">http://www.scheme.com</a></p>
</body>
</html>
