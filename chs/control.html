<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
  "http://www.w3.org/TR/html4/loose.dtd"><!-- DO NOT EDIT THIS FILE-->
<!-- Edit the .tex version instead-->

<html>
<head>
<title>Control Operations</title>
<link href="tspl.css" rel="stylesheet" type="text/css">
</head>
<body>
<a name="g96"></a>
<a name="./control:h0"></a>

<div style="font-size: 12px; width: 500px; height: 500px; border: solid thin">
<img style="padding: 20px 10px 20px 20px" src="canned/ch5.png"><img src="canned/jph.png">
</div>
<h1>Chapter 5. Control Operations<a name="CHPTCONTROL"></a></h1>





<p>
This chapter introduces the syntactic forms and procedures that
serve as <a name="./control:s0"></a>control structures for Scheme programs,
The first section covers the most basic control structure, procedure
application, and the remaining sections cover sequencing, conditional
evaluation, recursion, mapping, continuations, delayed evaluation,
multiple values, and evaluation of programs constructed at run time.

<p>

<h3><a name="g97"></a><a name="./control:h1"></a>Section 5.1. Procedure Application<a name="SECTAPPLICATION"></a></h3>



<p>
<a name="./control:s1"></a><span class=formdef><b>syntax</b>: <tt>(<i>expr<sub>0</sub></i>&nbsp;<i>expr<sub>1</sub></i>&nbsp;...)</tt></span>
<br>
<b>returns: </b>values of applying the value of <tt><i>expr<sub>0</sub></i></tt> to the values of <tt><i>expr<sub>1</sub></i>&nbsp;...</tt>

<p>Procedure application is the most basic Scheme control structure.
Any structured form without a syntax keyword in the first position is a
procedure application.
The expressions <tt><i>expr<sub>0</sub></i></tt> and <tt><i>expr<sub>1</sub></i>&nbsp;...</tt> are evaluated; each
should evaluate to a single value.
After each of these expressions has been evaluated, the value of
<tt><i>expr<sub>0</sub></i></tt> is applied to the values of <tt><i>expr<sub>1</sub></i>&nbsp;...</tt>.
If <tt><i>expr<sub>0</sub></i></tt> does not evaluate to a procedure, or if the procedure does not
accept the number of arguments provided, an exception with condition type
<tt>&amp;assertion</tt> is raised.

<p>
<a name="./control:s2"></a>The order in which the procedure and argument
expressions are evaluated is unspecified.
It may be left to right, right to left, or any other order.
The evaluation is guaranteed to be sequential, however: whatever order
is chosen, each expression is fully evaluated before evaluation of
the next is started.

<p>

<p><tt>(+&nbsp;3&nbsp;4)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;7
<br>
<br>
((if&nbsp;(odd?&nbsp;3)&nbsp;+&nbsp;-)&nbsp;6&nbsp;2)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;8
<br>
<br>
((lambda&nbsp;(x)&nbsp;x)&nbsp;5)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;5
<br>
<br>
(let&nbsp;([f&nbsp;(lambda&nbsp;(x)&nbsp;(+&nbsp;x&nbsp;x))])<br>

&nbsp;&nbsp;(f&nbsp;8))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;16</tt>
<p><a name="./control:s3"></a><a name="desc:apply"></a>
<span class=formdef><b>procedure</b>: <tt>(apply&nbsp;<i>procedure</i>&nbsp;<i>obj</i>&nbsp;...&nbsp;<i>list</i>)</tt></span>
<br>
<b>returns: </b>the values of applying <tt><i>procedure</i></tt> to <tt><i>obj</i>&nbsp;...</tt> and
the elements of <tt><i>list</i></tt>
<br>
<b>libraries: </b><tt>(rnrs&nbsp;base)</tt>, <tt>(rnrs)</tt>

<p><tt>apply</tt> invokes <tt><i>procedure</i></tt>, passing
the first <tt><i>obj</i></tt> as the first argument,
the second <tt><i>obj</i></tt> as the second argument, and
so on for each object in <tt><i>obj</i>&nbsp;...</tt>, and passing the elements of
<tt><i>list</i></tt> in order as the remaining arguments.
Thus, <tt><i>procedure</i></tt> is called with as many arguments as there are
<tt><i>objs</i></tt> plus elements of <tt><i>list</i></tt>.

<p>
<tt>apply</tt> is useful when some or all of the arguments to be passed to
a procedure are in a list, since it frees the programmer from
explicitly destructuring the list.

<p>

<p><tt>(apply&nbsp;+&nbsp;'(4&nbsp;5))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;9
<br>
<br>
(apply&nbsp;min&nbsp;'(6&nbsp;8&nbsp;3&nbsp;2&nbsp;5))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;2
<br>
<br>
(apply&nbsp;min&nbsp;&nbsp;5&nbsp;1&nbsp;3&nbsp;'(6&nbsp;8&nbsp;3&nbsp;2&nbsp;5))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;1
<br>
<br>
(apply&nbsp;vector&nbsp;'a&nbsp;'b&nbsp;'(c&nbsp;d&nbsp;e))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#(a&nbsp;b&nbsp;c&nbsp;d&nbsp;e)
<br>
<br>
(define&nbsp;first<br>

&nbsp;&nbsp;(lambda&nbsp;(ls)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(apply&nbsp;(lambda&nbsp;(x&nbsp;.&nbsp;y)&nbsp;x)&nbsp;ls)))<br>

(define&nbsp;rest<br>

&nbsp;&nbsp;(lambda&nbsp;(ls)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(apply&nbsp;(lambda&nbsp;(x&nbsp;.&nbsp;y)&nbsp;y)&nbsp;ls)))<br>

(first&nbsp;'(a&nbsp;b&nbsp;c&nbsp;d))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;a<br>

(rest&nbsp;'(a&nbsp;b&nbsp;c&nbsp;d))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(b&nbsp;c&nbsp;d)
<br>
<br>
(apply&nbsp;append<br>

&nbsp;&nbsp;'(1&nbsp;2&nbsp;3)<br>

&nbsp;&nbsp;'((a&nbsp;b)&nbsp;(c&nbsp;d&nbsp;e)&nbsp;(f)))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(1&nbsp;2&nbsp;3&nbsp;a&nbsp;b&nbsp;c&nbsp;d&nbsp;e&nbsp;f)</tt>
<p>
<h3><a name="g98"></a><a name="./control:h2"></a>Section 5.2. Sequencing<a name="SECTSEQUENCING"></a></h3>



<p>
<a name="./control:s4"></a><span class=formdef><b>syntax</b>: <tt>(begin&nbsp;<i>expr<sub>1</sub></i>&nbsp;<i>expr<sub>2</sub></i>&nbsp;...)</tt></span>
<br>
<b>returns: </b>the values of the last subexpression
<br>
<b>libraries: </b><tt>(rnrs&nbsp;base)</tt>, <tt>(rnrs)</tt>

<p>The expressions <tt><i>expr<sub>1</sub></i>&nbsp;<i>expr<sub>2</sub></i>&nbsp;...</tt> are evaluated in sequence
from left to right.
<a name="./control:s5"></a><tt>begin</tt> is used to sequence assignments,
input/output, or other operations that cause <a name="./control:s6"></a>side effects.

<p>

<p><tt>(define&nbsp;x&nbsp;3)<br>

(begin<br>

&nbsp;&nbsp;(set!&nbsp;x&nbsp;(+&nbsp;x&nbsp;1))<br>

&nbsp;&nbsp;(+&nbsp;x&nbsp;x))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;8</tt>
<p>A <tt>begin</tt> form may contain zero or more definitions in place of
the expressions <tt><i>expr<sub>1</sub></i>&nbsp;<i>expr<sub>2</sub></i>&nbsp;...</tt>, in which case
it is considered to be a definition and may appear only where definitions
are valid.

<p>

<p><tt>(let&nbsp;()<br>

&nbsp;&nbsp;(begin&nbsp;(define&nbsp;x&nbsp;3)&nbsp;(define&nbsp;y&nbsp;4))<br>

&nbsp;&nbsp;(+&nbsp;x&nbsp;y))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;7</tt>
<p>This form of <tt>begin</tt> is primarily used by syntactic extensions
that must expand into multiple definitions.
(See page&nbsp;<a href="./binding.html#multi-define-syntax">101</a>.)

<p>
The bodies of many syntactic forms, including <tt>lambda</tt>, <tt>case-lambda</tt>, <tt>let</tt>,
<tt>let*</tt>, <tt>letrec</tt>, and <tt>letrec*</tt>, as well as the result clauses of <tt>cond</tt>,
<tt>case</tt>, and <tt>do</tt>, are treated as if they
were inside an <a name="./control:s7"></a>implicit <tt>begin</tt>; i.e., the expressions
making up the body or result clause are executed in sequence, with the values of the
last expression being returned.

<p>

<p><tt>(define&nbsp;swap-pair!<br>

&nbsp;&nbsp;(lambda&nbsp;(x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([temp&nbsp;(car&nbsp;x)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set-car!&nbsp;x&nbsp;(cdr&nbsp;x))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set-cdr!&nbsp;x&nbsp;temp)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x)))<br>

(swap-pair!&nbsp;(cons&nbsp;'a&nbsp;'b))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(b&nbsp;.&nbsp;a)</tt>
<p>
<h3><a name="g99"></a><a name="./control:h3"></a>Section 5.3. Conditionals<a name="SECTCONDITIONALS"></a></h3>



<p>
<a name="./control:s8"></a><span class=formdef><b>syntax</b>: <tt>(if&nbsp;<i>test</i>&nbsp;<i>consequent</i>&nbsp;<i>alternative</i>)</tt></span>
<br>
<span class=formdef><b>syntax</b>: <tt>(if&nbsp;<i>test</i>&nbsp;<i>consequent</i>)</tt></span>
<br>
<b>returns: </b>the values of <tt><i>consequent</i></tt> or <tt><i>alternative</i></tt> depending on the
value of <tt><i>test</i></tt>
<br>
<b>libraries: </b><tt>(rnrs&nbsp;base)</tt>, <tt>(rnrs)</tt>

<p><a name="./control:s9"></a>The <tt><i>test</i></tt>, <tt><i>consequent</i></tt>, and <tt><i>alternative</i></tt> subforms must be
expressions.
If <tt><i>test</i></tt> evaluates to a true value (anything other than <tt>#f</tt>),
<tt>consequent</tt> is evaluated and its values are returned.
Otherwise, <tt>alternative</tt> is evaluated and its values are returned.
With the second, "one-armed," form, which has no <tt><i>alternative</i></tt>,
the result is unspecified if <tt><i>test</i></tt> evaluates to false.

<p>

<p><tt>(let&nbsp;([ls&nbsp;'(a&nbsp;b&nbsp;c)])<br>

&nbsp;&nbsp;(if&nbsp;(null?&nbsp;ls)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'()<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cdr&nbsp;ls)))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(b&nbsp;c)
<br>
<br>
(let&nbsp;([ls&nbsp;'()])<br>

&nbsp;&nbsp;(if&nbsp;(null?&nbsp;ls)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'()<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cdr&nbsp;ls)))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;()
<br>
<br>
(let&nbsp;([abs<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(&lt;&nbsp;x&nbsp;0)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(-&nbsp;0&nbsp;x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x))])<br>

&nbsp;&nbsp;(abs&nbsp;-4))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;4
<br>
<br>
(let&nbsp;([x&nbsp;-4])<br>

&nbsp;&nbsp;(if&nbsp;(&lt;&nbsp;x&nbsp;0)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(list&nbsp;'minus&nbsp;(-&nbsp;0&nbsp;x))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(list&nbsp;'plus&nbsp;4)))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(minus&nbsp;4)</tt>
<p><a name="./control:s10"></a><span class=formdef><b>procedure</b>: <tt>(not&nbsp;<i>obj</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if <tt><i>obj</i></tt> is false, <tt>#f</tt> otherwise
<br>
<b>libraries: </b><tt>(rnrs&nbsp;base)</tt>, <tt>(rnrs)</tt>

<p><tt>not</tt> is equivalent to <tt>(lambda&nbsp;(x)&nbsp;(if&nbsp;x&nbsp;#f&nbsp;#t))</tt>.

<p>

<p><tt>(not&nbsp;#f)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(not&nbsp;#t)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(not&nbsp;'())&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(not&nbsp;(&lt;&nbsp;4&nbsp;5))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f</tt>
<p><a name="./control:s11"></a><span class=formdef><b>syntax</b>: <tt>(and&nbsp;<i>expr</i>&nbsp;...)</tt></span>
<br>
<b>returns: </b>see below
<br>
<b>libraries: </b><tt>(rnrs&nbsp;base)</tt>, <tt>(rnrs)</tt>

<p>If no subexpressions are present, the <tt>and</tt> form evaluates to <tt>#t</tt>.
Otherwise, <tt>and</tt> evaluates each subexpression in sequence from left to right
until only one subexpression remains or a subexpression returns <tt>#f</tt>.
If one subexpression remains, it is evaluated and its values are returned.
If a subexpression returns <tt>#f</tt>, <tt>and</tt> returns <tt>#f</tt> without
evaluating the remaining subexpressions.
A syntax definition of <tt>and</tt> appears on page&nbsp;<a href="./further.html#defn:and">62</a>.

<p>

<p><tt>(let&nbsp;([x&nbsp;3])<br>

&nbsp;&nbsp;(and&nbsp;(&gt;&nbsp;x&nbsp;2)&nbsp;(&lt;&nbsp;x&nbsp;4)))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t
<br>
<br>
(let&nbsp;([x&nbsp;5])<br>

&nbsp;&nbsp;(and&nbsp;(&gt;&nbsp;x&nbsp;2)&nbsp;(&lt;&nbsp;x&nbsp;4)))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f
<br>
<br>
(and&nbsp;#f&nbsp;'(a&nbsp;b)&nbsp;'(c&nbsp;d))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(and&nbsp;'(a&nbsp;b)&nbsp;'(c&nbsp;d)&nbsp;'(e&nbsp;f))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(e&nbsp;f)</tt>
<p><a name="./control:s12"></a><span class=formdef><b>syntax</b>: <tt>(or&nbsp;<i>expr</i>&nbsp;...)</tt></span>
<br>
<b>returns: </b>see below
<br>
<b>libraries: </b><tt>(rnrs&nbsp;base)</tt>, <tt>(rnrs)</tt>

<p>If no subexpressions are present, the <tt>or</tt> form evaluates to <tt>#f</tt>.
Otherwise, <tt>or</tt> evaluates each subexpression in sequence from left to right
until only one subexpression remains or a subexpression returns a value other
than <tt>#f</tt>.
If one subexpression remains, it is evaluated and its values are returned.
If a subexpression returns a value other than <tt>#f</tt>, <tt>or</tt> returns
that value without evaluating the remaining subexpressions.
A syntax definition of <tt>or</tt> appears on page&nbsp;<a href="./further.html#defn:or">63</a>.

<p>

<p><tt>(let&nbsp;([x&nbsp;3])<br>

&nbsp;&nbsp;(or&nbsp;(&lt;&nbsp;x&nbsp;2)&nbsp;(&gt;&nbsp;x&nbsp;4)))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f
<br>
<br>
(let&nbsp;([x&nbsp;5])<br>

&nbsp;&nbsp;(or&nbsp;(&lt;&nbsp;x&nbsp;2)&nbsp;(&gt;&nbsp;x&nbsp;4)))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t
<br>
<br>
(or&nbsp;#f&nbsp;'(a&nbsp;b)&nbsp;'(c&nbsp;d))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(a&nbsp;b)</tt>
<p><a name="./control:s13"></a><span class=formdef><b>syntax</b>: <tt>(cond&nbsp;<i>clause<sub>1</sub></i>&nbsp;<i>clause<sub>2</sub></i>&nbsp;...)</tt></span>
<br>
<b>returns: </b>see below
<br>
<b>libraries: </b><tt>(rnrs&nbsp;base)</tt>, <tt>(rnrs)</tt>

<p>Each <tt><i>clause</i></tt> but the last must take one of the forms
<a name="./control:s14"></a>below.

<p>

<p><tt>(<i>test</i>)<br>

(<i>test</i>&nbsp;<i>expr<sub>1</sub></i>&nbsp;<i>expr<sub>2</sub></i>&nbsp;...)<br>

(<i>test</i>&nbsp;=&gt;&nbsp;<i>expr</i>)</tt>
<p>The last clause may be in any of the above forms, or it may be
an "<a name="./control:s15"></a><tt>else</tt> clause" of the form

<p>

<p><tt>(else&nbsp;<i>expr<sub>1</sub></i>&nbsp;<i>expr<sub>2</sub></i>&nbsp;...)</tt>
<p>Each <tt><i>test</i></tt> is evaluated in order until one evaluates to a true
value or until all of the tests have been evaluated.
If the first clause whose <tt><i>test</i></tt> evaluates to a true value is
in the first form given above, the
value of <tt><i>test</i></tt> is returned.

<p>
If the first clause whose <tt><i>test</i></tt> evaluates to a true value is
in the second form given above, the
expressions <tt><i>expr<sub>1</sub></i>&nbsp;<i>expr<sub>2</sub></i>...</tt> are evaluated in
sequence and the values of the last expression are returned.

<p>
If the first clause whose <tt><i>test</i></tt> evaluates to a true value is
in the third form given above, the expression <tt><i>expr</i></tt> is
evaluated.
The value should be a procedure of one argument, which is applied
to the value of <tt><i>test</i></tt>.
The values of this application are returned.

<p>
If none of the tests evaluates to a true value and an <tt>else</tt> clause
is present, the expressions <tt><i>expr<sub>1</sub></i>&nbsp;<i>expr<sub>2</sub></i>&nbsp;...</tt> of the <tt>else</tt>
clause are evaluated in sequence and the values of the last expression
are returned.

<p>
If none of the tests evaluates to a true value and no <tt>else</tt> clause
is present, the value or values are unspecified.

<p>
See page&nbsp;<a href="./syntax.html#defn:cond">305</a> for a syntax definition of <tt>cond</tt>.

<p>

<p><tt>(let&nbsp;([x&nbsp;0])<br>

&nbsp;&nbsp;(cond<br>

&nbsp;&nbsp;&nbsp;&nbsp;[(&lt;&nbsp;x&nbsp;0)&nbsp;(list&nbsp;'minus&nbsp;(abs&nbsp;x))]<br>

&nbsp;&nbsp;&nbsp;&nbsp;[(&gt;&nbsp;x&nbsp;0)&nbsp;(list&nbsp;'plus&nbsp;x)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;[else&nbsp;(list&nbsp;'zero&nbsp;x)]))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(zero&nbsp;0)
<br>
<br>
(define&nbsp;select<br>

&nbsp;&nbsp;(lambda&nbsp;(x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(cond<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(not&nbsp;(symbol?&nbsp;x))]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(assq&nbsp;x&nbsp;'((a&nbsp;.&nbsp;1)&nbsp;(b&nbsp;.&nbsp;2)&nbsp;(c&nbsp;.&nbsp;3)))&nbsp;=&gt;&nbsp;cdr]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[else&nbsp;0])))
<br>
<br>
(select&nbsp;3)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(select&nbsp;'b)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;2<br>

(select&nbsp;'e)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;0</tt>
<p><a name="./control:s16"></a><span class=formdef><b>syntax</b>: <tt>else</tt></span>
<br>
<span class=formdef><b>syntax</b>: <tt>=&gt;</tt></span>
<br>
<b>libraries: </b><tt>(rnrs&nbsp;base)</tt>, <tt>(rnrs&nbsp;exceptions)</tt>, <tt>(rnrs)</tt>

<p>These identifiers are auxiliary keywords for <tt>cond</tt>.
Both also serve as auxiliary keywords for <tt>guard</tt>, and
<tt>else</tt> also serves as an auxiliary keyword for <tt>case</tt>.
It is a syntax violation to reference these identifiers except in
contexts where they are recognized as auxiliary keywords.


<p>
<a name="./control:s17"></a><span class=formdef><b>syntax</b>: <tt>(when&nbsp;<i>test-expr</i>&nbsp;<i>expr<sub>1</sub></i>&nbsp;<i>expr<sub>2</sub></i>&nbsp;...)</tt></span>
<br>
<span class=formdef><b>syntax</b>: <tt>(unless&nbsp;<i>test-expr</i>&nbsp;<i>expr<sub>1</sub></i>&nbsp;<i>expr<sub>2</sub></i>&nbsp;...)</tt></span>
<br>
<b>returns: </b>see below
<br>
<b>libraries: </b><tt>(rnrs&nbsp;control)</tt>, <tt>(rnrs)</tt>

<p>For <tt>when</tt>,
if <tt><i>test-expr</i></tt> evaluates to a true value, the expressions
<tt><i>expr<sub>1</sub></i>&nbsp;<i>expr<sub>2</sub></i>&nbsp;...</tt> are evaluated in sequence,
and the values of the last expression are returned.
If <tt><i>test-expr</i></tt> evaluates to false, none of the other expressions
are evaluated, and the value or values of <tt>when</tt> are unspecified.

<p>
For <tt>unless</tt>,
if <tt><i>test-expr</i></tt> evaluates to false, the expressions
<tt><i>expr<sub>1</sub></i>&nbsp;<i>expr<sub>2</sub></i>&nbsp;...</tt> are evaluated in sequence,
and the values of the last expression are returned.
If <tt><i>test-expr</i></tt> evaluates to a true value, none of the other
expressions are evaluated, and the value or values of <tt>unless</tt> are unspecified.

<p>
A <tt>when</tt> or <tt>unless</tt> expression is usually clearer than
the corresponding "one-armed" <tt>if</tt> expression.

<p>

<p><tt>(let&nbsp;([x&nbsp;-4]&nbsp;[sign&nbsp;'plus])<br>

&nbsp;&nbsp;(when&nbsp;(&lt;&nbsp;x&nbsp;0)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(set!&nbsp;x&nbsp;(-&nbsp;0&nbsp;x))<br>

&nbsp;&nbsp;&nbsp;&nbsp;(set!&nbsp;sign&nbsp;'minus))<br>

&nbsp;&nbsp;(list&nbsp;sign&nbsp;x))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(minus&nbsp;4)
<br>
<br>
(define&nbsp;check-pair<br>

&nbsp;&nbsp;(lambda&nbsp;(x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(unless&nbsp;(pair?&nbsp;x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(syntax-violation&nbsp;'check-pair&nbsp;"invalid&nbsp;argument"&nbsp;x))<br>

&nbsp;&nbsp;&nbsp;&nbsp;x))
<br>
<br>
(check-pair&nbsp;'(a&nbsp;b&nbsp;c))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(a&nbsp;b&nbsp;c)</tt>
<p><tt>when</tt> may be defined as follows:

<p>

<p><tt>(define-syntax&nbsp;when<br>

&nbsp;&nbsp;(syntax-rules&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;e0&nbsp;e1&nbsp;e2&nbsp;...)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;e0&nbsp;(begin&nbsp;e1&nbsp;e2&nbsp;...))]))</tt>
<p><tt>unless</tt> may be defined as follows:

<p>

<p><tt>(define-syntax&nbsp;unless<br>

&nbsp;&nbsp;(syntax-rules&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;e0&nbsp;e1&nbsp;e2&nbsp;...)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(not&nbsp;e0)&nbsp;(begin&nbsp;e1&nbsp;e2&nbsp;...))]))</tt>
<p>or in terms of <tt>when</tt> as follows:

<p>

<p><tt>(define-syntax&nbsp;unless<br>

&nbsp;&nbsp;(syntax-rules&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;e0&nbsp;e1&nbsp;e2&nbsp;...)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(when&nbsp;(not&nbsp;e0)&nbsp;e1&nbsp;e2&nbsp;...)]))</tt>
<p><a name="./control:s18"></a><span class=formdef><b>syntax</b>: <tt>(case&nbsp;<i>expr<sub>0</sub></i>&nbsp;<i>clause<sub>1</sub></i>&nbsp;<i>clause<sub>2</sub></i>&nbsp;...)</tt></span>
<br>
<b>returns: </b>see below
<br>
<b>libraries: </b><tt>(rnrs&nbsp;base)</tt>, <tt>(rnrs)</tt>

<p>Each clause but the last must take the form

<p>

<p><tt>((<i>key</i>&nbsp;...)&nbsp;<i>expr<sub>1</sub></i>&nbsp;<i>expr<sub>2</sub></i>&nbsp;...)</tt>
<p>where each <tt><i>key</i></tt> is a datum distinct from the other keys.
The last clause may be in the above form or it may be an
<a name="./control:s19"></a><tt>else</tt> clause of the form

<p>

<p><tt>(else&nbsp;<i>expr<sub>1</sub></i>&nbsp;<i>expr<sub>2</sub></i>&nbsp;...)</tt>
<p><tt><i>expr<sub>0</sub></i></tt> is evaluated and the result is compared
(using <tt>eqv?</tt>) against the keys of each clause in order.
If a clause containing a matching key is found, the
expressions <tt><i>expr<sub>1</sub></i>&nbsp;<i>expr<sub>2</sub></i>&nbsp;...</tt> are evaluated in sequence
and the values of the last expression are returned.

<p>
If none of the clauses contains a matching key and an <tt>else</tt> clause
is present, the expressions <tt><i>expr<sub>1</sub></i>&nbsp;<i>expr<sub>2</sub></i>&nbsp;...</tt> of the
<tt>else</tt> clause are evaluated in sequence and the values of the last
expression are returned.

<p>
If none of the clauses contains a matching key and no <tt>else</tt> clause
is present, the value or values are unspecified.

<p>
See page&nbsp;<a href="./syntax.html#defn:case">306</a> for a syntax definition of <tt>case</tt>.

<p>

<p><tt>(let&nbsp;([x&nbsp;4]&nbsp;[y&nbsp;5])<br>

&nbsp;&nbsp;(case&nbsp;(+&nbsp;x&nbsp;y)<br>

&nbsp;&nbsp;&nbsp;&nbsp;[(1&nbsp;3&nbsp;5&nbsp;7&nbsp;9)&nbsp;'odd]<br>

&nbsp;&nbsp;&nbsp;&nbsp;[(0&nbsp;2&nbsp;4&nbsp;6&nbsp;8)&nbsp;'even]<br>

&nbsp;&nbsp;&nbsp;&nbsp;[else&nbsp;'out-of-range]))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;odd</tt>
<p>
<h3><a name="g100"></a><a name="./control:h4"></a>Section 5.4. Recursion and Iteration<a name="SECTRECURSION"></a></h3>



<p>
<a name="./control:s20"></a><span class=formdef><b>syntax</b>: <tt>(let&nbsp;<i>name</i>&nbsp;((<i>var</i>&nbsp;<i>expr</i>)&nbsp;...)&nbsp;<i>body<sub>1</sub></i>&nbsp;<i>body<sub>2</sub></i>&nbsp;...)</tt></span>
<br>
<b>returns: </b>values of the final body expression
<br>
<b>libraries: </b><tt>(rnrs&nbsp;base)</tt>, <tt>(rnrs)</tt>

<p>This form of <tt>let</tt>, called <a name="./control:s21"></a><tt><i>named</i></tt>
<tt>let</tt>, is a general-purpose <a name="./control:s22"></a>iteration and
<a name="./control:s23"></a>recursion construct.
It is similar to the more common form of <tt>let</tt>
(see Section&nbsp;<a href="./binding.html#g92">4.4</a>) in the
binding of the variables <tt><i>var</i>&nbsp;...</tt> to the values of <tt><i>expr</i>&nbsp;...</tt> within
the body <tt><i>body<sub>1</sub></i>&nbsp;<i>body<sub>2</sub></i>&nbsp;...</tt>, which is processed and evaluated like
a <tt>lambda</tt> body.
In addition, the variable <tt><i>name</i></tt> is bound within the body to
a procedure that may be called to recur or iterate; the arguments to
the procedure become the new values of the variables <tt><i>var</i>&nbsp;...</tt>.

<p>
A named <tt>let</tt> expression of the form

<p>

<p><tt>(let&nbsp;<i>name</i>&nbsp;((<i>var</i>&nbsp;<i>expr</i>)&nbsp;...)<br>

&nbsp;&nbsp;<i>body<sub>1</sub></i>&nbsp;<i>body<sub>2</sub></i>&nbsp;...)</tt>
<p>can be rewritten with <tt>letrec</tt> as follows.

<p>

<p><tt>((letrec&nbsp;((<i>name</i>&nbsp;(lambda&nbsp;(<i>var</i>&nbsp;...)&nbsp;<i>body<sub>1</sub></i>&nbsp;<i>body<sub>2</sub></i>&nbsp;...)))<br>

&nbsp;&nbsp;&nbsp;<i>name</i>)<br>

&nbsp;<i>expr</i>&nbsp;...)</tt>
<p>A syntax definition of <tt>let</tt> that implements this transformation
and handles unnamed <tt>let</tt> as well
can be found on page&nbsp;<a href="./syntax.html#defn:let">312</a>.


<p>
The procedure <a name="./control:s24"></a><tt>divisors</tt> defined below uses named <tt>let</tt> to compute the
nontrivial divisors of a nonnegative integer.

<p>

<p><tt>(define&nbsp;divisors<br>

&nbsp;&nbsp;(lambda&nbsp;(n)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;f&nbsp;([i&nbsp;2])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cond<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(&gt;=&nbsp;i&nbsp;n)&nbsp;'()]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(integer?&nbsp;(/&nbsp;n&nbsp;i))&nbsp;(cons&nbsp;i&nbsp;(f&nbsp;(+&nbsp;i&nbsp;1)))]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[else&nbsp;(f&nbsp;(+&nbsp;i&nbsp;1))]))))
<br>
<br>
(divisors&nbsp;5)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;()<br>

(divisors&nbsp;32)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(2&nbsp;4&nbsp;8&nbsp;16)</tt>
<p>The version above is non-tail-recursive when a divisor is found and
tail-recursive when a divisor is not found.
The version below is fully tail-recursive.
It builds up the list in reverse order, but this is easy to remedy,
if desired, by reversing the list on exit.

<p>

<p><tt>(define&nbsp;divisors<br>

&nbsp;&nbsp;(lambda&nbsp;(n)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;f&nbsp;([i&nbsp;2]&nbsp;[ls&nbsp;'()])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cond<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(&gt;=&nbsp;i&nbsp;n)&nbsp;ls]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(integer?&nbsp;(/&nbsp;n&nbsp;i))&nbsp;(f&nbsp;(+&nbsp;i&nbsp;1)&nbsp;(cons&nbsp;i&nbsp;ls))]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[else&nbsp;(f&nbsp;(+&nbsp;i&nbsp;1)&nbsp;ls)]))))</tt>
<p><a name="./control:s25"></a><span class=formdef><b>syntax</b>: <tt>(do&nbsp;((<i>var</i>&nbsp;<i>init</i>&nbsp;<i>update</i>)&nbsp;...)&nbsp;(<i>test</i>&nbsp;<i>result</i>&nbsp;...)&nbsp;<i>expr</i>&nbsp;...)</tt></span>
<br>
<b>returns: </b>the values of the last <tt><i>result</i></tt> expression
<br>
<b>libraries: </b><tt>(rnrs&nbsp;control)</tt>, <tt>(rnrs)</tt>

<p><tt>do</tt> allows a common restricted form of <a name="./control:s26"></a>iteration
to be expressed succinctly.
The variables <tt><i>var</i>&nbsp;...</tt> are bound initially to the
values of <tt><i>init</i>&nbsp;...</tt> and are rebound on each subsequent
iteration to the values of <tt><i>update</i>&nbsp;...</tt>.
The expressions <tt><i>test</i></tt>, 
<tt><i>update</i>&nbsp;...</tt>,
<tt><i>expr</i>&nbsp;...</tt>, and
<tt><i>result</i>&nbsp;...</tt>
are all within the scope of the bindings
established for <tt><i>var</i>&nbsp;...</tt>.

<p>
On each step, the test expression <tt><i>test</i></tt> is evaluated.
If the value of <tt><i>test</i></tt> is true, iteration ceases,
the expressions <tt><i>result</i>&nbsp;...</tt> are evaluated in
sequence, and the values of the last expression are returned.
If no result expressions are present, the value or values of the <tt>do</tt>
expression are unspecified.

<p>
If the value of <tt><i>test</i></tt> is false, the expressions <tt><i>expr</i>&nbsp;...</tt>
are evaluated in sequence, the expressions <tt><i>update</i>&nbsp;...</tt> are
evaluated, new bindings for <tt><i>var</i>&nbsp;...</tt> to the values of
<tt><i>update</i>&nbsp;...</tt> are created, and iteration continues.

<p>
The expressions <tt><i>expr</i>&nbsp;...</tt> are evaluated only for effect
and are often omitted entirely.
Any <tt><i>update</i></tt> expression may be omitted, in which case the effect is
the same as if the <tt><i>update</i></tt> were simply the corresponding
<tt><i>var</i></tt>.

<p>
Although looping constructs in most languages require that the loop
iterands be updated via assignment, <tt>do</tt> requires the loop
iterands <tt><i>var</i>&nbsp;...</tt> to be updated via rebinding.
In fact, no side effects are involved in the evaluation of a
<tt>do</tt> expression unless they are performed explicitly by its
subexpressions.

<p>
See page&nbsp;<a href="./syntax.html#defn:do">313</a> for a syntax definition of <tt>do</tt>.

<p>
The definitions of <a name="./control:s27"></a><tt>factorial</tt> and <a name="./control:s28"></a><tt>fibonacci</tt> below are
straightforward translations of the tail-recursive named-<tt>let</tt> versions
given in Section&nbsp;<a href="./further.html#g55">3.2</a>.

<p>

<p><tt>(define&nbsp;factorial<br>

&nbsp;&nbsp;(lambda&nbsp;(n)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(do&nbsp;([i&nbsp;n&nbsp;(-&nbsp;i&nbsp;1)]&nbsp;[a&nbsp;1&nbsp;(*&nbsp;a&nbsp;i)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((zero?&nbsp;i)&nbsp;a))))
<br>
<br>
(factorial&nbsp;10)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;3628800
<br>
<br>
(define&nbsp;fibonacci<br>

&nbsp;&nbsp;(lambda&nbsp;(n)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(=&nbsp;n&nbsp;0)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(do&nbsp;([i&nbsp;n&nbsp;(-&nbsp;i&nbsp;1)]&nbsp;[a1&nbsp;1&nbsp;(+&nbsp;a1&nbsp;a2)]&nbsp;[a2&nbsp;0&nbsp;a1])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((=&nbsp;i&nbsp;1)&nbsp;a1)))))
<br>
<br>
(fibonacci&nbsp;6)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;8</tt>
<p>The definition of <a name="./control:s29"></a><tt>divisors</tt> below is
similar to the tail-recursive definition of <tt>divisors</tt> given
with the description of named <tt>let</tt> above.

<p>

<p><tt>(define&nbsp;divisors<br>

&nbsp;&nbsp;(lambda&nbsp;(n)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(do&nbsp;([i&nbsp;2&nbsp;(+&nbsp;i&nbsp;1)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ls&nbsp;'()<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(integer?&nbsp;(/&nbsp;n&nbsp;i))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cons&nbsp;i&nbsp;ls)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ls)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((&gt;=&nbsp;i&nbsp;n)&nbsp;ls))))</tt>
<p>The definition of <tt>scale-vector!</tt> below, which scales each
element of a vector <i>v</i> by a constant <i>k</i>, demonstrates a nonempty
<tt>do</tt> body.

<p>

<p><tt>(define&nbsp;scale-vector!<br>

&nbsp;&nbsp;(lambda&nbsp;(v&nbsp;k)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([n&nbsp;(vector-length&nbsp;v)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(do&nbsp;([i&nbsp;0&nbsp;(+&nbsp;i&nbsp;1)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((=&nbsp;i&nbsp;n))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(vector-set!&nbsp;v&nbsp;i&nbsp;(*&nbsp;(vector-ref&nbsp;v&nbsp;i)&nbsp;k))))))
<br>
<br>
(define&nbsp;vec&nbsp;(vector&nbsp;1&nbsp;2&nbsp;3&nbsp;4&nbsp;5))<br>

(scale-vector!&nbsp;vec&nbsp;2)<br>

vec&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#(2&nbsp;4&nbsp;6&nbsp;8&nbsp;10)</tt>
<p>
<h3><a name="g101"></a><a name="./control:h5"></a>Section 5.5. Mapping and Folding</h3>



<p>
When a program must recur or iterate over the elements of a list, a mapping
or folding operator is often more convenient.
These operators abstract away from null checks and explicit recursion by
applying a procedure to the elements of the list one by one.
A few mapping operators are also available for vectors and strings.


<p>
<a name="./control:s30"></a><span class=formdef><b>procedure</b>: <tt>(map&nbsp;<i>procedure</i>&nbsp;<i>list<sub>1</sub></i>&nbsp;<i>list<sub>2</sub></i>&nbsp;...)</tt></span>
<br>
<b>returns: </b>list of results
<br>
<b>libraries: </b><tt>(rnrs&nbsp;base)</tt>, <tt>(rnrs)</tt>

<p><a name="./control:s31"></a><a name="./control:s32"></a><tt>map</tt> applies <tt><i>procedure</i></tt> to corresponding
elements of the lists <tt><i>list<sub>1</sub></i>&nbsp;<i>list<sub>2</sub></i>&nbsp;...</tt> and returns a
list of the resulting values.
The lists <tt><i>list<sub>1</sub></i>&nbsp;<i>list<sub>2</sub></i>&nbsp;...</tt> must be of the same length.
<tt><i>procedure</i></tt> should accept as many arguments as there are lists, should
return a single value, and should not mutate the <tt><i>list</i></tt> arguments.

<p>

<p><tt>(map&nbsp;abs&nbsp;'(1&nbsp;-2&nbsp;3&nbsp;-4&nbsp;5&nbsp;-6))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(1&nbsp;2&nbsp;3&nbsp;4&nbsp;5&nbsp;6)
<br>
<br>
(map&nbsp;(lambda&nbsp;(x&nbsp;y)&nbsp;(*&nbsp;x&nbsp;y))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'(1&nbsp;2&nbsp;3&nbsp;4)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'(8&nbsp;7&nbsp;6&nbsp;5))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(8&nbsp;14&nbsp;18&nbsp;20)</tt>
<p>While the order in which the applications themselves occur is not
specified, the order of the values in the output list is the same
as that of the corresponding values in the input lists.

<p>
<tt>map</tt> might be defined as follows.

<p>

<p><tt>(define&nbsp;map<br>

&nbsp;&nbsp;(lambda&nbsp;(f&nbsp;ls&nbsp;.&nbsp;more)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(null?&nbsp;more)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;map1&nbsp;([ls&nbsp;ls])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(null?&nbsp;ls)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'()<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cons&nbsp;(f&nbsp;(car&nbsp;ls))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(map1&nbsp;(cdr&nbsp;ls)))))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;map-more&nbsp;([ls&nbsp;ls]&nbsp;[more&nbsp;more])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(null?&nbsp;ls)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'()<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cons<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(apply&nbsp;f&nbsp;(car&nbsp;ls)&nbsp;(map&nbsp;car&nbsp;more))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(map-more&nbsp;(cdr&nbsp;ls)&nbsp;(map&nbsp;cdr&nbsp;more))))))))</tt>
<p>No error checking is done by this version of <tt>map</tt>; <tt>f</tt> is assumed to
be a procedure and the other arguments are assumed to be proper lists
of the same length.
An interesting feature of this definition is that <tt>map</tt> uses itself
to pull out the cars and cdrs of the list of input lists; this works
because of the special treatment of the single-list case.


<p>
<a name="./control:s33"></a><a name="desc:for-each"></a>
<span class=formdef><b>procedure</b>: <tt>(for-each&nbsp;<i>procedure</i>&nbsp;<i>list<sub>1</sub></i>&nbsp;<i>list<sub>2</sub></i>&nbsp;...)</tt></span>
<br>
<b>returns: </b>unspecified
<br>
<b>libraries: </b><tt>(rnrs&nbsp;base)</tt>, <tt>(rnrs)</tt>

<p><a name="./control:s34"></a><a name="./control:s35"></a><tt>for-each</tt> is similar to <tt>map</tt> except that
<tt>for-each</tt> does
not create and return a list of the resulting values, and <tt>for-each</tt>
guarantees to perform the applications in sequence over the elements from
left to right.
<tt><i>procedure</i></tt> should accept as many arguments as there are lists
and should not mutate the <tt><i>list</i></tt> arguments.
<tt>for-each</tt> may be defined without error checks as follows.

<p>

<p><tt>(define&nbsp;for-each<br>

&nbsp;&nbsp;(lambda&nbsp;(f&nbsp;ls&nbsp;.&nbsp;more)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(do&nbsp;([ls&nbsp;ls&nbsp;(cdr&nbsp;ls)]&nbsp;[more&nbsp;more&nbsp;(map&nbsp;cdr&nbsp;more)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((null?&nbsp;ls))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(apply&nbsp;f&nbsp;(car&nbsp;ls)&nbsp;(map&nbsp;car&nbsp;more)))))
<br>
<br>
(let&nbsp;([same-count&nbsp;0])<br>

&nbsp;&nbsp;(for-each<br>

&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(x&nbsp;y)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(when&nbsp;(=&nbsp;x&nbsp;y)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set!&nbsp;same-count&nbsp;(+&nbsp;same-count&nbsp;1))))<br>

&nbsp;&nbsp;&nbsp;&nbsp;'(1&nbsp;2&nbsp;3&nbsp;4&nbsp;5&nbsp;6)<br>

&nbsp;&nbsp;&nbsp;&nbsp;'(2&nbsp;3&nbsp;3&nbsp;4&nbsp;7&nbsp;6))<br>

&nbsp;&nbsp;same-count)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;3</tt>
<p><a name="./control:s36"></a><span class=formdef><b>procedure</b>: <tt>(exists&nbsp;<i>procedure</i>&nbsp;<i>list<sub>1</sub></i>&nbsp;<i>list<sub>2</sub></i>&nbsp;...)</tt></span>
<br>
<b>returns: </b>see below
<br>
<b>libraries: </b><tt>(rnrs&nbsp;lists)</tt>, <tt>(rnrs)</tt>

<p>The lists <tt><i>list<sub>1</sub></i>&nbsp;<i>list<sub>2</sub></i>&nbsp;...</tt> must be of the same length.
<tt><i>procedure</i></tt> should accept as many arguments as there are lists and should
not mutate the <tt><i>list</i></tt> arguments.
If the lists are empty, <tt>exists</tt> returns <tt>#f</tt>.
Otherwise, <tt>exists</tt> applies <tt><i>procedure</i></tt> to corresponding elements
of the lists <tt><i>list<sub>1</sub></i>&nbsp;<i>list<sub>2</sub></i>&nbsp;...</tt> in sequence until either the
lists each have only one element or <tt><i>procedure</i></tt> returns a true value <tt><i>t</i></tt>.
In the former case, <tt>exists</tt> tail-calls <tt><i>procedure</i></tt>, applying it to the
remaining element of each list.
In the latter case, <tt>exists</tt> returns <tt><i>t</i></tt>.

<p>

<p><tt>(exists&nbsp;symbol?&nbsp;'(1.0&nbsp;#\a&nbsp;"hi"&nbsp;'()))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f
<br>
<br>
(exists&nbsp;member<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'(a&nbsp;b&nbsp;c)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'((c&nbsp;b)&nbsp;(b&nbsp;a)&nbsp;(a&nbsp;c)))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(b&nbsp;a)
<br>
<br>
(exists&nbsp;(lambda&nbsp;(x&nbsp;y&nbsp;z)&nbsp;(=&nbsp;(+&nbsp;x&nbsp;y)&nbsp;z))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'(1&nbsp;2&nbsp;3&nbsp;4)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'(1.2&nbsp;2.3&nbsp;3.4&nbsp;4.5)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'(2.3&nbsp;4.4&nbsp;6.4&nbsp;8.6))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t</tt>
<p><tt>exists</tt> may be defined (somewhat inefficiently and without error
checks) as follows:

<p>

<p><tt>(define&nbsp;exists<br>

&nbsp;&nbsp;(lambda&nbsp;(f&nbsp;ls&nbsp;.&nbsp;more)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(and&nbsp;(not&nbsp;(null?&nbsp;ls))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;exists&nbsp;([x&nbsp;(car&nbsp;ls)]&nbsp;[ls&nbsp;(cdr&nbsp;ls)]&nbsp;[more&nbsp;more])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(null?&nbsp;ls)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(apply&nbsp;f&nbsp;x&nbsp;(map&nbsp;car&nbsp;more))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(or&nbsp;(apply&nbsp;f&nbsp;x&nbsp;(map&nbsp;car&nbsp;more))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(exists&nbsp;(car&nbsp;ls)&nbsp;(cdr&nbsp;ls)&nbsp;(map&nbsp;cdr&nbsp;more))))))))</tt>
<p><a name="./control:s37"></a><span class=formdef><b>procedure</b>: <tt>(for-all&nbsp;<i>procedure</i>&nbsp;<i>list<sub>1</sub></i>&nbsp;<i>list<sub>2</sub></i>&nbsp;...)</tt></span>
<br>
<b>returns: </b>see below
<br>
<b>libraries: </b><tt>(rnrs&nbsp;lists)</tt>, <tt>(rnrs)</tt>

<p>The lists <tt><i>list<sub>1</sub></i>&nbsp;<i>list<sub>2</sub></i>&nbsp;...</tt> must be of the same length.
<tt><i>procedure</i></tt> should accept as many arguments as there are lists and should
not mutate the <tt><i>list</i></tt> arguments.
If the lists are empty, <tt>for-all</tt> returns <tt>#t</tt>.
Otherwise, <tt>for-all</tt> applies <tt><i>procedure</i></tt> to corresponding elements
of the lists <tt><i>list<sub>1</sub></i>&nbsp;<i>list<sub>2</sub></i>&nbsp;...</tt> in sequence until either the
lists each have only one element left or <tt><i>procedure</i></tt> returns <tt>#f</tt>.
In the former case, <tt>for-all</tt> tail-calls <tt><i>procedure</i></tt>, applying it to the
remaining element of each list.
In the latter case, <tt>for-all</tt> returns <tt>#f</tt>.

<p>

<p><tt>(for-all&nbsp;symbol?&nbsp;'(a&nbsp;b&nbsp;c&nbsp;d))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t
<br>
<br>
(for-all&nbsp;=<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'(1&nbsp;2&nbsp;3&nbsp;4)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'(1.0&nbsp;2.0&nbsp;3.0&nbsp;4.0))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t
<br>
<br>
(for-all&nbsp;(lambda&nbsp;(x&nbsp;y&nbsp;z)&nbsp;(=&nbsp;(+&nbsp;x&nbsp;y)&nbsp;z))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'(1&nbsp;2&nbsp;3&nbsp;4)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'(1.2&nbsp;2.3&nbsp;3.4&nbsp;4.5)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'(2.2&nbsp;4.3&nbsp;6.5&nbsp;8.5))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f</tt>
<p><tt>for-all</tt> may be defined (somewhat inefficiently and without error
checks) as follows:

<p>

<p><tt>(define&nbsp;for-all<br>

&nbsp;&nbsp;(lambda&nbsp;(f&nbsp;ls&nbsp;.&nbsp;more)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(or&nbsp;(null?&nbsp;ls)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;for-all&nbsp;([x&nbsp;(car&nbsp;ls)]&nbsp;[ls&nbsp;(cdr&nbsp;ls)]&nbsp;[more&nbsp;more])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(null?&nbsp;ls)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(apply&nbsp;f&nbsp;x&nbsp;(map&nbsp;car&nbsp;more))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(and&nbsp;(apply&nbsp;f&nbsp;x&nbsp;(map&nbsp;car&nbsp;more))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(for-all&nbsp;(car&nbsp;ls)&nbsp;(cdr&nbsp;ls)&nbsp;(map&nbsp;cdr&nbsp;more))))))))</tt>
<p><a name="./control:s38"></a><span class=formdef><b>procedure</b>: <tt>(fold-left&nbsp;<i>procedure</i>&nbsp;<i>obj</i>&nbsp;<i>list<sub>1</sub></i>&nbsp;<i>list<sub>2</sub></i>&nbsp;...)</tt></span>
<br>
<b>returns: </b>see below
<br>
<b>libraries: </b><tt>(rnrs&nbsp;lists)</tt>, <tt>(rnrs)</tt>

<p><a name="./control:s39"></a><a name="./control:s40"></a>The <tt><i>list</i></tt> arguments should all have the same length.
<tt><i>procedure</i></tt> should accept one more argument than the number of <tt><i>list</i></tt>
arguments and return a single value.
It should not mutate the <tt><i>list</i></tt> arguments.

<p>
<tt>fold-left</tt> returns <tt><i>obj</i></tt> if the <tt><i>list</i></tt> arguments are empty.
If they are not empty, <tt>fold-left</tt> applies <tt><i>procedure</i></tt> to
<tt><i>obj</i></tt> and the cars of <tt><i>list<sub>1</sub></i>&nbsp;<i>list<sub>2</sub></i>&nbsp;...</tt>,
then recurs with
the value returned by <tt><i>procedure</i></tt> in place of <tt><i>obj</i></tt> and the cdr of
each <tt><i>list</i></tt> in place of the <tt><i>list</i></tt>.

<p>

<p><tt>(fold-left&nbsp;cons&nbsp;'()&nbsp;'(1&nbsp;2&nbsp;3&nbsp;4))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;((((()&nbsp;.&nbsp;1)&nbsp;.&nbsp;2)&nbsp;.&nbsp;3)&nbsp;.&nbsp;4)
<br>
<br>
(fold-left<br>

&nbsp;&nbsp;(lambda&nbsp;(a&nbsp;x)&nbsp;(+&nbsp;a&nbsp;(*&nbsp;x&nbsp;x)))<br>

&nbsp;&nbsp;0&nbsp;'(1&nbsp;2&nbsp;3&nbsp;4&nbsp;5))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;55
<br>
<br>
(fold-left<br>

&nbsp;&nbsp;(lambda&nbsp;(a&nbsp;.&nbsp;args)&nbsp;(append&nbsp;args&nbsp;a))<br>

&nbsp;&nbsp;'(question)<br>

&nbsp;&nbsp;'(that&nbsp;not&nbsp;to)<br>

&nbsp;&nbsp;'(is&nbsp;to&nbsp;be)<br>

&nbsp;&nbsp;'(the&nbsp;be:&nbsp;or))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(to&nbsp;be&nbsp;or&nbsp;not&nbsp;to&nbsp;be:&nbsp;that&nbsp;is&nbsp;the&nbsp;question)</tt>
<p><a name="./control:s41"></a><span class=formdef><b>procedure</b>: <tt>(fold-right&nbsp;<i>procedure</i>&nbsp;<i>obj</i>&nbsp;<i>list<sub>1</sub></i>&nbsp;<i>list<sub>2</sub></i>&nbsp;...)</tt></span>
<br>
<b>returns: </b>see below
<br>
<b>libraries: </b><tt>(rnrs&nbsp;lists)</tt>, <tt>(rnrs)</tt>

<p><a name="./control:s42"></a><a name="./control:s43"></a>The <tt><i>list</i></tt> arguments should all have the same length.
<tt><i>procedure</i></tt> should accept one more argument than the number of <tt><i>list</i></tt>
arguments and return a single value.
It should not mutate the <tt><i>list</i></tt> arguments.

<p>
<tt>fold-right</tt> returns <tt><i>obj</i></tt> if the <tt><i>list</i></tt> arguments are empty.
If they are not empty, <tt>fold-right</tt> recurs with the cdr of each
<tt><i>list</i></tt> replacing the <tt><i>list</i></tt>, then applies
<tt><i>procedure</i></tt> to the cars of <tt><i>list<sub>1</sub></i>&nbsp;<i>list<sub>2</sub></i>&nbsp;...</tt> and
the result returned by the recursion.

<p>

<p><tt>(fold-right&nbsp;cons&nbsp;'()&nbsp;'(1&nbsp;2&nbsp;3&nbsp;4))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(1&nbsp;2&nbsp;3&nbsp;4)
<br>
<br>
(fold-right<br>

&nbsp;&nbsp;(lambda&nbsp;(x&nbsp;a)&nbsp;(+&nbsp;a&nbsp;(*&nbsp;x&nbsp;x)))<br>

&nbsp;&nbsp;0&nbsp;'(1&nbsp;2&nbsp;3&nbsp;4&nbsp;5))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;55
<br>
<br>
(fold-right<br>

&nbsp;&nbsp;(lambda&nbsp;(x&nbsp;y&nbsp;a)&nbsp;(cons*&nbsp;x&nbsp;y&nbsp;a))&nbsp;&nbsp;&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(parting&nbsp;is&nbsp;such&nbsp;sweet&nbsp;sorrow<br>

&nbsp;&nbsp;'((with&nbsp;apologies))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="gifs/ghostRightarrow.gif">&nbsp;&nbsp;gotta&nbsp;go&nbsp;see&nbsp;ya&nbsp;tomorrow<br>

&nbsp;&nbsp;'(parting&nbsp;such&nbsp;sorrow&nbsp;go&nbsp;ya)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="gifs/ghostRightarrow.gif">&nbsp;&nbsp;(with&nbsp;apologies))<br>

&nbsp;&nbsp;'(is&nbsp;sweet&nbsp;gotta&nbsp;see&nbsp;tomorrow))</tt>
<p><a name="./control:s44"></a><span class=formdef><b>procedure</b>: <tt>(vector-map&nbsp;<i>procedure</i>&nbsp;<i>vector<sub>1</sub></i>&nbsp;<i>vector<sub>1</sub></i>&nbsp;...)</tt></span>
<br>
<b>returns: </b>vector of results
<br>
<b>libraries: </b><tt>(rnrs&nbsp;base)</tt>, <tt>(rnrs)</tt>

<p><a name="./control:s45"></a><a name="./control:s46"></a><tt>vector-map</tt> applies <tt><i>procedure</i></tt> to corresponding
elements of <tt><i>vector<sub>1</sub></i>&nbsp;<i>vector<sub>2</sub></i>&nbsp;...</tt> and returns a
vector of the resulting values.
The vectors <tt><i>vector<sub>1</sub></i>&nbsp;<i>vector<sub>2</sub></i>&nbsp;...</tt> must be of the same length, and
<tt><i>procedure</i></tt> should accept as many arguments as there are vectors and
return a single value.

<p>

<p><tt>(vector-map&nbsp;abs&nbsp;'#(1&nbsp;-2&nbsp;3&nbsp;-4&nbsp;5&nbsp;-6))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#(1&nbsp;2&nbsp;3&nbsp;4&nbsp;5&nbsp;6)<br>

(vector-map&nbsp;(lambda&nbsp;(x&nbsp;y)&nbsp;(*&nbsp;x&nbsp;y))<br>

&nbsp;&nbsp;'#(1&nbsp;2&nbsp;3&nbsp;4)<br>

&nbsp;&nbsp;'#(8&nbsp;7&nbsp;6&nbsp;5))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#(8&nbsp;14&nbsp;18&nbsp;20)</tt>
<p>While the order in which the applications themselves occur is not
specified, the order of the values in the output vector is the same
as that of the corresponding values in the input vectors.

<p>
<a name="./control:s47"></a><span class=formdef><b>procedure</b>: <tt>(vector-for-each&nbsp;<i>procedure</i>&nbsp;<i>vector<sub>1</sub></i>&nbsp;<i>vector<sub>2</sub></i>&nbsp;...)</tt></span>
<br>
<b>returns: </b>unspecified
<br>
<b>libraries: </b><tt>(rnrs&nbsp;base)</tt>, <tt>(rnrs)</tt>

<p><a name="./control:s48"></a><a name="./control:s49"></a><tt>vector-for-each</tt> is similar to <tt>vector-map</tt> except that
<tt>vector-for-each</tt> does
not create and return a vector of the resulting values, and <tt>vector-for-each</tt>
guarantees to perform the applications in sequence over the elements from
left to right.

<p>

<p><tt>(let&nbsp;([same-count&nbsp;0])<br>

&nbsp;&nbsp;(vector-for-each<br>

&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(x&nbsp;y)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(when&nbsp;(=&nbsp;x&nbsp;y)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set!&nbsp;same-count&nbsp;(+&nbsp;same-count&nbsp;1))))<br>

&nbsp;&nbsp;&nbsp;&nbsp;'#(1&nbsp;2&nbsp;3&nbsp;4&nbsp;5&nbsp;6)<br>

&nbsp;&nbsp;&nbsp;&nbsp;'#(2&nbsp;3&nbsp;3&nbsp;4&nbsp;7&nbsp;6))<br>

&nbsp;&nbsp;same-count)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;3</tt>
<p><a name="./control:s50"></a><span class=formdef><b>procedure</b>: <tt>(string-for-each&nbsp;<i>procedure</i>&nbsp;<i>string<sub>1</sub></i>&nbsp;<i>string<sub>2</sub></i>&nbsp;...)</tt></span>
<br>
<b>returns: </b>unspecified
<br>
<b>libraries: </b><tt>(rnrs&nbsp;base)</tt>, <tt>(rnrs)</tt>

<p><a name="./control:s51"></a><a name="./control:s52"></a><tt>string-for-each</tt> is similar to
<tt>for-each</tt> and <tt>vector-for-each</tt>
except that the inputs are strings rather than lists or vectors.

<p>

<p><tt>(let&nbsp;([ls&nbsp;'()])<br>

&nbsp;&nbsp;(string-for-each<br>

&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;r&nbsp;(set!&nbsp;ls&nbsp;(cons&nbsp;r&nbsp;ls)))<br>

&nbsp;&nbsp;&nbsp;&nbsp;"abcd"<br>

&nbsp;&nbsp;&nbsp;&nbsp;"===="<br>

&nbsp;&nbsp;&nbsp;&nbsp;"1234")<br>

&nbsp;&nbsp;(map&nbsp;list-&gt;string&nbsp;(reverse&nbsp;ls)))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;("a=1"&nbsp;"b=2"&nbsp;"c=3"&nbsp;"d=4")</tt>
<p>
<h3><a name="g102"></a><a name="./control:h6"></a>Section 5.6. Continuations<a name="SECTCONTINUATIONS"></a></h3>



<p>
Continuations in Scheme are procedures that represent the remainder
of a computation from a given point in the computation.
They may be obtained with <tt>call-with-current-continuation</tt>, which
can be abbreviated to <a name="./control:s53"></a><tt>call/cc</tt>.

<p>
<a name="./control:s54"></a><span class=formdef><b>procedure</b>: <tt>(call/cc&nbsp;<i>procedure</i>)</tt></span>
<br>
<span class=formdef><b>procedure</b>: <tt>(call-with-current-continuation&nbsp;<i>procedure</i>)</tt></span>
<br>
<b>returns: </b>see below
<br>
<b>libraries: </b><tt>(rnrs&nbsp;base)</tt>, <tt>(rnrs)</tt>

<p>These procedures are the same.
The shorter name is often used for the obvious reason that it requires
fewer keystrokes to type.

<p>
<tt>call/cc</tt> obtains its continuation and passes it to <tt><i>procedure</i></tt>,
which should accept one argument.
The continuation itself is represented by a procedure.
Each time this procedure is applied to zero or more values, it returns the values to the
continuation of the <tt>call/cc</tt> application.
That is, when the continuation procedure is called, it returns its arguments
as the values of the application of <tt>call/cc</tt>.

<p>
If <tt><i>procedure</i></tt> returns normally when passed the continuation procedure,
the values returned by <tt>call/cc</tt> are the values returned by <tt><i>procedure</i></tt>.

<p>
Continuations allow the implementation of <a name="./control:s55"></a>nonlocal exits,
backtracking&nbsp;[<a class=citation href="./bibliography.html#g232">14</a>,<a class=citation href="./bibliography.html#g247">29</a>],
coroutines&nbsp;[<a class=citation href="./bibliography.html#g234">16</a>], and
multitasking&nbsp;[<a class=citation href="./bibliography.html#g228">10</a>,<a class=citation href="./bibliography.html#g250">32</a>].

<p>
The example below illustrates the use of a continuation to perform
a nonlocal exit from a loop.

<p>

<p><tt>(define&nbsp;member<br>

&nbsp;&nbsp;(lambda&nbsp;(x&nbsp;ls)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(call/cc<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(break)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(do&nbsp;([ls&nbsp;ls&nbsp;(cdr&nbsp;ls)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((null?&nbsp;ls)&nbsp;#f)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(when&nbsp;(equal?&nbsp;x&nbsp;(car&nbsp;ls))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(break&nbsp;ls)))))))
<br>
<br>
(member&nbsp;'d&nbsp;'(a&nbsp;b&nbsp;c))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(member&nbsp;'b&nbsp;'(a&nbsp;b&nbsp;c))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(b&nbsp;c)</tt>
<p>Additional examples are given in Sections&nbsp;<a href="./further.html#g63">3.3</a>
and&nbsp;<a href="./examples.html#g208">12.11</a>.

<p>
The current continuation is typically represented internally as a stack
of procedure activation records, and obtaining the continuation
involves encapsulating the stack within a procedural object.
Since an encapsulated stack has indefinite extent, some mechanism must
be used to preserve the stack contents indefinitely.
This can be done with surprising ease and efficiency and with no impact
on programs that do not use continuations&nbsp;[<a class=citation href="./bibliography.html#g235">17</a>].

<p>
<a name="./control:s56"></a><a name="desc:dynamic-wind"></a>
<span class=formdef><b>procedure</b>: <tt>(dynamic-wind&nbsp;<i>in</i>&nbsp;<i>body</i>&nbsp;<i>out</i>)</tt></span>
<br>
<b>returns: </b>values resulting from the application of <tt><i>body</i></tt>
<br>
<b>libraries: </b><tt>(rnrs&nbsp;base)</tt>, <tt>(rnrs)</tt>

<p><a name="./control:s57"></a><tt>dynamic-wind</tt> offers "protection" from continuation
invocation.
It is useful for performing tasks that must be performed whenever control
enters or leaves <tt><i>body</i></tt>, either normally or by continuation application.

<p>
The three arguments <tt><i>in</i></tt>, <tt><i>body</i></tt>, and <tt><i>out</i></tt> must be procedures
and should accept zero arguments, i.e., they should be <a name="./control:s58"></a><tt><i>thunks</i></tt>.
Before applying <tt><i>body</i></tt>, and each time <tt><i>body</i></tt> is entered subsequently
by the application of a continuation created within <tt><i>body</i></tt>, the <tt><i>in</i></tt>
thunk is applied.
Upon normal exit from <tt><i>body</i></tt> and each time <tt><i>body</i></tt> is exited by
the application of a continuation created outside <tt><i>body</i></tt>, the <tt><i>out</i></tt>
thunk is applied.

<p>
Thus, it is guaranteed that <tt><i>in</i></tt> is invoked at least once.
In addition, if <tt><i>body</i></tt> ever returns, <tt><i>out</i></tt> is invoked at least
once.

<p>
The following example demonstrates the use of <tt>dynamic-wind</tt> to be sure
that an input port is closed after processing, regardless of whether the
processing completes normally.

<p>

<p><tt>(let&nbsp;([p&nbsp;(open-input-file&nbsp;"input-file")])<br>

&nbsp;&nbsp;(dynamic-wind<br>

&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;()&nbsp;#f)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;()&nbsp;(process&nbsp;p))<br>

&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;()&nbsp;(close-port&nbsp;p))))</tt>
<p><a name="./control:s59"></a>Common Lisp provides a similar
facility (<tt>unwind-protect</tt>) for protection from <a name="./control:s60"></a>nonlocal exits.
This is often sufficient.
<tt>unwind-protect</tt> provides only the equivalent to <tt><i>out</i></tt>, however,
since Common Lisp does not support fully general continuations.
Here is how <tt>unwind-protect</tt> might be specified with <tt>dynamic-wind</tt>.

<p>

<p><tt>(define-syntax&nbsp;unwind-protect<br>

&nbsp;&nbsp;(syntax-rules&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;body&nbsp;cleanup&nbsp;...)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(dynamic-wind<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;()&nbsp;#f)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;()&nbsp;body)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;()&nbsp;cleanup&nbsp;...))]))
<br>
<br>
((call/cc<br>

&nbsp;&nbsp;&nbsp;(let&nbsp;([x&nbsp;'a])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(k)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(unwind-protect<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(k&nbsp;(lambda&nbsp;()&nbsp;x))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set!&nbsp;x&nbsp;'b))))))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;b</tt>
<p>Some Scheme implementations support a controlled form of assignment
known as <a name="./control:s61"></a><i>fluid
binding</i>, in which a variable takes on a
temporary value during a given computation and reverts to the old value
after the computation has completed.
The syntactic form <tt>fluid-let</tt> defined below in terms of <tt>dynamic-wind</tt>
permits the fluid binding of a single variable <tt>x</tt> to the value of
an expression <tt>e</tt> within a the body <tt>b1&nbsp;b2&nbsp;...</tt>.

<p>

<p><tt>(define-syntax&nbsp;fluid-let<br>

&nbsp;&nbsp;(syntax-rules&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;((x&nbsp;e))&nbsp;b1&nbsp;b2&nbsp;...)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([y&nbsp;e])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([swap&nbsp;(lambda&nbsp;()&nbsp;(let&nbsp;([t&nbsp;x])&nbsp;(set!&nbsp;x&nbsp;y)&nbsp;(set!&nbsp;y&nbsp;t)))])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(dynamic-wind&nbsp;swap&nbsp;(lambda&nbsp;()&nbsp;b1&nbsp;b2&nbsp;...)&nbsp;swap)))]))</tt>
<p>Implementations that support <tt>fluid-let</tt> typically extend it to
allow an indefinite number of <tt>(x&nbsp;e)</tt> pairs, as with <tt>let</tt>.

<p>
If no continuations are invoked within the body of a <tt>fluid-let</tt>,
the behavior is the same as if the variable were simply assigned
the new value on entry and assigned the old value on return.

<p>

<p><tt>(let&nbsp;([x&nbsp;3])<br>

&nbsp;&nbsp;(+&nbsp;(fluid-let&nbsp;([x&nbsp;5])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;8</tt>
<p>A fluid-bound variable also reverts to the old value if a continuation
created outside of the <tt>fluid-let</tt> is invoked.

<p>

<p><tt>(let&nbsp;([x&nbsp;'a])<br>

&nbsp;&nbsp;(let&nbsp;([f&nbsp;(lambda&nbsp;()&nbsp;x)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;(cons&nbsp;(call/cc<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(k)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(fluid-let&nbsp;([x&nbsp;'b])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(k&nbsp;(f)))))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(f))))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(b&nbsp;.&nbsp;a)</tt>
<p>If control has left a <tt>fluid-let</tt> body, either normally
or by the invocation of a continuation, and control reenters the
body by the invocation of a continuation, the temporary value of
the fluid-bound variable is reinstated.
Furthermore, any changes to the temporary value are maintained
and reflected upon reentry.

<p>

<p><tt>(define&nbsp;reenter&nbsp;#f)<br>

(define&nbsp;x&nbsp;0)<br>

(fluid-let&nbsp;([x&nbsp;1])<br>

&nbsp;&nbsp;(call/cc&nbsp;(lambda&nbsp;(k)&nbsp;(set!&nbsp;reenter&nbsp;k)))<br>

&nbsp;&nbsp;(set!&nbsp;x&nbsp;(+&nbsp;x&nbsp;1))<br>

&nbsp;&nbsp;x)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;2<br>

x&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;0<br>

(reenter&nbsp;'*)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;3<br>

(reenter&nbsp;'*)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;4<br>

x&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;0</tt>
<p>A library showing how <tt>dynamic-wind</tt> might be implemented
were it not already built in is given below.
In addition to defining <tt>dynamic-wind</tt>, the code defines
a version of
<a name="./control:s62"></a><tt>call/cc</tt>
that does its part to support <tt>dynamic-wind</tt>.

<p>

<p><tt>(library&nbsp;(dynamic-wind)<br>

&nbsp;&nbsp;(export&nbsp;dynamic-wind&nbsp;call/cc<br>

&nbsp;&nbsp;&nbsp;&nbsp;(rename&nbsp;(call/cc&nbsp;call-with-current-continuation)))<br>

&nbsp;&nbsp;(import&nbsp;(rename&nbsp;(except&nbsp;(rnrs)&nbsp;dynamic-wind)&nbsp;(call/cc&nbsp;rnrs:call/cc)))
<br>
<br>
&nbsp;&nbsp;(define&nbsp;winders&nbsp;'())
<br>
<br>
&nbsp;&nbsp;(define&nbsp;common-tail<br>

&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(x&nbsp;y)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([lx&nbsp;(length&nbsp;x)]&nbsp;[ly&nbsp;(length&nbsp;y)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(do&nbsp;([x&nbsp;(if&nbsp;(&gt;&nbsp;lx&nbsp;ly)&nbsp;(list-tail&nbsp;x&nbsp;(-&nbsp;lx&nbsp;ly))&nbsp;x)&nbsp;(cdr&nbsp;x)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[y&nbsp;(if&nbsp;(&gt;&nbsp;ly&nbsp;lx)&nbsp;(list-tail&nbsp;y&nbsp;(-&nbsp;ly&nbsp;lx))&nbsp;y)&nbsp;(cdr&nbsp;y)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((eq?&nbsp;x&nbsp;y)&nbsp;x)))))
<br>
<br>
&nbsp;&nbsp;(define&nbsp;do-wind<br>

&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(new)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([tail&nbsp;(common-tail&nbsp;new&nbsp;winders)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;f&nbsp;([ls&nbsp;winders])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(not&nbsp;(eq?&nbsp;ls&nbsp;tail))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(begin<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set!&nbsp;winders&nbsp;(cdr&nbsp;ls))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((cdar&nbsp;ls))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(f&nbsp;(cdr&nbsp;ls)))))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;f&nbsp;([ls&nbsp;new])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(not&nbsp;(eq?&nbsp;ls&nbsp;tail))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(begin<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(f&nbsp;(cdr&nbsp;ls))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((caar&nbsp;ls))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set!&nbsp;winders&nbsp;ls)))))))</tt>
<p>
<p><tt>&nbsp;&nbsp;(define&nbsp;call/cc<br>

&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(f)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(rnrs:call/cc<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(k)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(f&nbsp;(let&nbsp;([save&nbsp;winders])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(unless&nbsp;(eq?&nbsp;save&nbsp;winders)&nbsp;(do-wind&nbsp;save))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(k&nbsp;x))))))))
<br>
<br>
&nbsp;&nbsp;(define&nbsp;dynamic-wind<br>

&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(in&nbsp;body&nbsp;out)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(in)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set!&nbsp;winders&nbsp;(cons&nbsp;(cons&nbsp;in&nbsp;out)&nbsp;winders))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let-values&nbsp;([ans*&nbsp;(body)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set!&nbsp;winders&nbsp;(cdr&nbsp;winders))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(out)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(apply&nbsp;values&nbsp;ans*)))))</tt>
<p>Together, <tt>dynamic-wind</tt> and <tt>call/cc</tt> manage a list
of <a name="./control:s63"></a><i>winders</i>.
A winder is a pair of <i>in</i> and <i>out</i> thunks established
by a call to <tt>dynamic-wind</tt>.
Whenever <tt>dynamic-wind</tt> is invoked, the <i>in</i> thunk is
invoked, a new winder containing the <i>in</i> and <i>out</i> thunks
is placed on the winders list, the <i>body</i> thunk is invoked,
the winder is removed from the winders list, and the <i>out</i>
thunk is invoked.
This ordering ensures that the winder is on the winders list only
when control has passed through <i>in</i> and not yet entered
<i>out</i>.
Whenever a continuation is obtained, the winders list is saved, and
whenever the continuation is invoked, the saved winders list is
reinstated.
During reinstatement, the <i>out</i> thunk of each winder on the
current winders list that is not also on the saved winders list is
invoked, followed by the <i>in</i> thunk of each winder on the saved
winders list that is not also on the current winders list.
The winders list is updated incrementally, again to ensure that
a winder is on the current winders list only if control has passed
through its <i>in</i> thunk and not entered its <i>out</i> thunk.

<p>
The test <tt>(not&nbsp;(eq?&nbsp;save&nbsp;winders))</tt> performed in <tt>call/cc</tt>
is not strictly necessary but makes invoking a continuation
less costly whenever the saved winders list is the same as the
current winders list.

<p>

<h3><a name="g103"></a><a name="./control:h7"></a>Section 5.7. Delayed Evaluation<a name="SECTDELAYED"></a></h3>



<p>
The syntactic form <tt>delay</tt> and the procedure <tt>force</tt> may be used in
combination to implement <a name="./control:s64"></a><i>lazy evaluation</i>.
An expression subject to lazy evaluation is not evaluated until its value is
required and, once evaluated, is never reevaluated.


<p>
<a name="./control:s65"></a><span class=formdef><b>syntax</b>: <tt>(delay&nbsp;<i>expr</i>)</tt></span>
<br>
<b>returns: </b>a promise
<br>
<span class=formdef><b>procedure</b>: <tt>(force&nbsp;<i>promise</i>)</tt></span>
<br>
<b>returns: </b>result of forcing <tt><i>promise</i></tt>
<br>
<b>libraries: </b><tt>(rnrs&nbsp;r5rs)</tt>

<p>The first time a promise created by <tt>delay</tt> is <i>forced</i> (with
<tt>force</tt>), it evaluates <tt><i>expr</i></tt>, "remembering" the resulting
value.
Thereafter, each time the promise is forced, it returns the remembered
value instead of reevaluating <tt><i>expr</i></tt>.

<p>
<tt>delay</tt> and <tt>force</tt> are typically used only in the absence of side
effects, e.g., assignments, so that the order of evaluation is unimportant.

<p>
The benefit of using <tt>delay</tt> and <tt>force</tt> is that some
amount of computation might be avoided altogether if it is delayed until
absolutely required.
Delayed evaluation may be used to construct conceptually infinite
lists, or <a name="./control:s66"></a><i>streams</i>.
The example below shows how a stream abstraction may be built with
<tt>delay</tt> and <tt>force</tt>.
A stream is a promise that, when forced, returns a pair whose cdr
is a stream.

<p>

<p><tt>(define&nbsp;stream-car<br>

&nbsp;&nbsp;(lambda&nbsp;(s)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(car&nbsp;(force&nbsp;s))))
<br>
<br>
(define&nbsp;stream-cdr<br>

&nbsp;&nbsp;(lambda&nbsp;(s)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(cdr&nbsp;(force&nbsp;s))))
<br>
<br>
(define&nbsp;counters<br>

&nbsp;&nbsp;(let&nbsp;next&nbsp;([n&nbsp;1])<br>

&nbsp;&nbsp;&nbsp;&nbsp;(delay&nbsp;(cons&nbsp;n&nbsp;(next&nbsp;(+&nbsp;n&nbsp;1))))))
<br>
<br>
(stream-car&nbsp;counters)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;1
<br>
<br>
(stream-car&nbsp;(stream-cdr&nbsp;counters))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;2
<br>
<br>
(define&nbsp;stream-add<br>

&nbsp;&nbsp;(lambda&nbsp;(s1&nbsp;s2)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(delay&nbsp;(cons<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(+&nbsp;(stream-car&nbsp;s1)&nbsp;(stream-car&nbsp;s2))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(stream-add&nbsp;(stream-cdr&nbsp;s1)&nbsp;(stream-cdr&nbsp;s2))))))
<br>
<br>
(define&nbsp;even-counters<br>

&nbsp;&nbsp;(stream-add&nbsp;counters&nbsp;counters))
<br>
<br>
(stream-car&nbsp;even-counters)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;2
<br>
<br>
(stream-car&nbsp;(stream-cdr&nbsp;even-counters))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;4</tt>
<p><tt>delay</tt> may be defined by

<p>

<p><tt>(define-syntax&nbsp;delay<br>

&nbsp;&nbsp;(syntax-rules&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;expr)&nbsp;(make-promise&nbsp;(lambda&nbsp;()&nbsp;expr))]))</tt>
<p>where <a name="./control:s67"></a><tt>make-promise</tt> might be defined
as follows.

<p>

<p><tt>(define&nbsp;make-promise<br>

&nbsp;&nbsp;(lambda&nbsp;(p)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([val&nbsp;#f]&nbsp;[set?&nbsp;#f])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(unless&nbsp;set?<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([x&nbsp;(p)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(unless&nbsp;set?<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set!&nbsp;val&nbsp;x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set!&nbsp;set?&nbsp;#t))))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val))))</tt>
<p>With this definition of <tt>delay</tt>, <tt>force</tt> simply invokes the promise
to force evaluation or to retrieve the saved value.

<p>

<p><tt>(define&nbsp;force<br>

&nbsp;&nbsp;(lambda&nbsp;(promise)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(promise)))</tt>
<p>The second test of the variable <tt>set?</tt> in <tt>make-promise</tt> is necessary
in the event that, as a result of applying <tt><i>p</i></tt>, the
promise is recursively forced.
Since a promise must always return the same value, the
result of the first application of <tt><i>p</i></tt> to complete is
returned.

<p>
Whether <tt>delay</tt> and <tt>force</tt> handle multiple return values
is unspecified; the implementation given above does not, but the following
version does, with the help of <tt>call-with-values</tt> and <tt>apply</tt>.

<p>

<p><tt>(define&nbsp;make-promise<br>

&nbsp;&nbsp;(lambda&nbsp;(p)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([vals&nbsp;#f]&nbsp;[set?&nbsp;#f])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(unless&nbsp;set?<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(call-with-values&nbsp;p<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;x<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(unless&nbsp;set?<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set!&nbsp;vals&nbsp;x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set!&nbsp;set?&nbsp;#t)))))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(apply&nbsp;values&nbsp;vals)))))
<br>
<br>
(define&nbsp;p&nbsp;(delay&nbsp;(values&nbsp;1&nbsp;2&nbsp;3)))<br>

(force&nbsp;p)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;1<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="gifs/ghostRightarrow.gif">&nbsp;2<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="gifs/ghostRightarrow.gif">&nbsp;3<br>

(call-with-values&nbsp;(lambda&nbsp;()&nbsp;(force&nbsp;p))&nbsp;+)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;6</tt>
<p>Neither implementation is quite right, since <tt>force</tt> must raise
an exception with condition type <tt>&amp;assertion</tt> if its argument is
not a promise.
Since distinguishing procedures created by <tt>make-promise</tt> from
other procedures is impossible, <tt>force</tt> cannot do so reliably.
The following reimplementation of <tt>make-promise</tt> and <tt>force</tt>
represents promises as records of the type <tt>promise</tt> to allow
<tt>force</tt> to make the required check.

<p>

<p><tt>(define-record-type&nbsp;promise<br>

&nbsp;&nbsp;(fields&nbsp;(immutable&nbsp;p)&nbsp;(mutable&nbsp;vals)&nbsp;(mutable&nbsp;set?))<br>

&nbsp;&nbsp;(protocol&nbsp;(lambda&nbsp;(new)&nbsp;(lambda&nbsp;(p)&nbsp;(new&nbsp;p&nbsp;#f&nbsp;#f)))))
<br>
<br>
(define&nbsp;force<br>

&nbsp;&nbsp;(lambda&nbsp;(promise)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(unless&nbsp;(promise?&nbsp;promise)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(assertion-violation&nbsp;'promise&nbsp;"invalid&nbsp;argument"&nbsp;promise))<br>

&nbsp;&nbsp;&nbsp;&nbsp;(unless&nbsp;(promise-set?&nbsp;promise)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(call-with-values&nbsp;(promise-p&nbsp;promise)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;x<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(unless&nbsp;(promise-set?&nbsp;promise)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(promise-vals-set!&nbsp;promise&nbsp;x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(promise-set?-set!&nbsp;promise&nbsp;#t)))))<br>

&nbsp;&nbsp;&nbsp;&nbsp;(apply&nbsp;values&nbsp;(promise-vals&nbsp;promise))))</tt>
<p>
<h3><a name="g104"></a><a name="./control:h8"></a>5.8. 多（返回）值<a name="SECTMRVS"></a></h3>



<p>
虽然Scheme的原始过程和大多数用户定义的过程都返回恰好一个值，但有时一些编程问题最好的解决办法却是返回0个或者多个甚至可变数量的返回值。
例如，把一个列表分割成两个子列表的过程就需要返回两个值。当然可以在过程中把要返回的多个值事先打包，由调用者去解包。还有一个更简洁的方式，
就是使用内置的multiple-values接口。
这个接口由两个过程组成：
<a name="./control:s68"></a><tt>values</tt>
和
<a name="./control:s69"></a><tt>call-with-values</tt>.
The former produces multiple values and the latter 
links procedures that produce multiple-value values with
procedures that consume them.


<p>
<a name="./control:s70"></a><span class=formdef><b>procedure</b>: <tt>(values&nbsp;<i>obj</i>&nbsp;...)</tt></span>
<br>
<b>returns: </b><tt><i>obj</i>&nbsp;...</tt>
<br>
<b>libraries: </b><tt>(rnrs&nbsp;base)</tt>, <tt>(rnrs)</tt>

<p>The procedure <tt>values</tt> accepts any number of arguments and
simply passes (returns) the arguments to its continuation.

<p>

<p><tt>(values)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>"><br>
<br>
(values&nbsp;1)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;1
<br>
<br>
(values&nbsp;1&nbsp;2&nbsp;3)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;1<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="gifs/ghostRightarrow.gif">&nbsp;2<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="gifs/ghostRightarrow.gif">&nbsp;3
<br>
<br>
(define&nbsp;head&amp;tail<br>

&nbsp;&nbsp;(lambda&nbsp;(ls)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(values&nbsp;(car&nbsp;ls)&nbsp;(cdr&nbsp;ls))))
<br>
<br>
(head&amp;tail&nbsp;'(a&nbsp;b&nbsp;c))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;a<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="gifs/ghostRightarrow.gif">&nbsp;(b&nbsp;c)</tt>
<p><a name="./control:s71"></a><span class=formdef><b>procedure</b>: <tt>(call-with-values&nbsp;<i>producer</i>&nbsp;<i>consumer</i>)</tt></span>
<br>
<b>returns: </b>see below
<br>
<b>libraries: </b><tt>(rnrs&nbsp;base)</tt>, <tt>(rnrs)</tt>

<p><tt><i>producer</i></tt> and <tt><i>consumer</i></tt> must be procedures.
<tt>call-with-values</tt> applies <tt><i>consumer</i></tt> to the values
returned by invoking <tt><i>producer</i></tt> without arguments.

<p>

<p><tt>(call-with-values<br>

&nbsp;&nbsp;(lambda&nbsp;()&nbsp;(values&nbsp;'bond&nbsp;'james))<br>

&nbsp;&nbsp;(lambda&nbsp;(x&nbsp;y)&nbsp;(cons&nbsp;y&nbsp;x)))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(james&nbsp;.&nbsp;bond)
<br>
<br>
(call-with-values&nbsp;values&nbsp;list)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;'()</tt>
<p>In the second example, <tt>values</tt> itself serves as the producer.
It receives no arguments and thus returns no values.
<tt>list</tt> is thus applied to no arguments and so returns the
empty list.

<p>
The procedure <a name="./control:s72"></a><tt>dxdy</tt> defined below computes
the change in <tt><i>x</i></tt> and <tt><i>y</i></tt> coordinates for a pair of points whose
coordinates are represented by <tt>(<i>x</i>&nbsp;.&nbsp;<i>y</i>)</tt> pairs.

<p>

<p><tt>(define&nbsp;dxdy<br>

&nbsp;&nbsp;(lambda&nbsp;(p1&nbsp;p2)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(values&nbsp;(-&nbsp;(car&nbsp;p2)&nbsp;(car&nbsp;p1))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(-&nbsp;(cdr&nbsp;p2)&nbsp;(cdr&nbsp;p1)))))
<br>
<br>
(dxdy&nbsp;'(0&nbsp;.&nbsp;0)&nbsp;'(0&nbsp;.&nbsp;5))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;0<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="gifs/ghostRightarrow.gif">&nbsp;5</tt>
<p><tt>dxdy</tt> can be used to compute the length and slope of
a segment represented by two
endpoints.<a name="./control:s73"></a><a name="./control:s74"></a>

<p>

<p><tt>(define&nbsp;segment-length<br>

&nbsp;&nbsp;(lambda&nbsp;(p1&nbsp;p2)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(call-with-values<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;()&nbsp;(dxdy&nbsp;p1&nbsp;p2))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(dx&nbsp;dy)&nbsp;(sqrt&nbsp;(+&nbsp;(*&nbsp;dx&nbsp;dx)&nbsp;(*&nbsp;dy&nbsp;dy)))))))
<br>
<br>
(define&nbsp;segment-slope<br>

&nbsp;&nbsp;(lambda&nbsp;(p1&nbsp;p2)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(call-with-values<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;()&nbsp;(dxdy&nbsp;p1&nbsp;p2))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(dx&nbsp;dy)&nbsp;(/&nbsp;dy&nbsp;dx)))))
<br>
<br>
(segment-length&nbsp;'(1&nbsp;.&nbsp;4)&nbsp;'(4&nbsp;.&nbsp;8))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;5<br>

(segment-slope&nbsp;'(1&nbsp;.&nbsp;4)&nbsp;'(4&nbsp;.&nbsp;8))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;4/3</tt>
<p>We can of course combine these to form one procedure that returns
two values.<a name="./control:s75"></a>

<p>

<p><tt>(define&nbsp;describe-segment<br>

&nbsp;&nbsp;(lambda&nbsp;(p1&nbsp;p2)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(call-with-values<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;()&nbsp;(dxdy&nbsp;p1&nbsp;p2))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(dx&nbsp;dy)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(values<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(sqrt&nbsp;(+&nbsp;(*&nbsp;dx&nbsp;dx)&nbsp;(*&nbsp;dy&nbsp;dy)))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(/&nbsp;dy&nbsp;dx))))))
<br>
<br>
(describe-segment&nbsp;'(1&nbsp;.&nbsp;4)&nbsp;'(4&nbsp;.&nbsp;8))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;5<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;4/3</tt>
<p>The example below employs multiple values to divide a
list nondestructively into two sublists of alternating
elements.

<p>

<p><tt>(define&nbsp;split<br>

&nbsp;&nbsp;(lambda&nbsp;(ls)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(or&nbsp;(null?&nbsp;ls)&nbsp;(null?&nbsp;(cdr&nbsp;ls)))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(values&nbsp;ls&nbsp;'())<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(call-with-values<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;()&nbsp;(split&nbsp;(cddr&nbsp;ls)))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(odds&nbsp;evens)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(values&nbsp;(cons&nbsp;(car&nbsp;ls)&nbsp;odds)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cons&nbsp;(cadr&nbsp;ls)&nbsp;evens)))))))
<br>
<br>
(split&nbsp;'(a&nbsp;b&nbsp;c&nbsp;d&nbsp;e&nbsp;f))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(a&nbsp;c&nbsp;e)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="gifs/ghostRightarrow.gif">&nbsp;(b&nbsp;d&nbsp;f)</tt>
<p>At each level of recursion, the procedure <a name="./control:s76"></a><tt>split</tt> returns two
values:  a list of the odd-numbered elements from the argument list and
a list of the even-numbered elements.


<p>
The continuation of a call to <tt>values</tt> need not be one established
by a call to <tt>call-with-values</tt>, nor must only <tt>values</tt> be used to return
to a continuation established by <tt>call-with-values</tt>.
In particular, <tt>(values&nbsp;<i>e</i>)</tt> and <tt><i>e</i></tt> are equivalent expressions.
For example:

<p>

<p><tt>(+&nbsp;(values&nbsp;2)&nbsp;4)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;6
<br>
<br>
(if&nbsp;(values&nbsp;#t)&nbsp;1&nbsp;2)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;1
<br>
<br>
(call-with-values<br>

&nbsp;&nbsp;(lambda&nbsp;()&nbsp;4)<br>

&nbsp;&nbsp;(lambda&nbsp;(x)&nbsp;x))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;4</tt>
<p>Similarly, <tt>values</tt> may be used to pass any number of values to
a continuation that ignores the values, as in the following.

<p>

<p><tt>(begin&nbsp;(values&nbsp;1&nbsp;2&nbsp;3)&nbsp;4)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;4</tt>
<p>Because a continuation may accept zero or more than one value,
continuations obtained via
<a name="./control:s77"></a><tt>call/cc</tt> may
accept zero or more than one argument.

<p>

<p><tt>(call-with-values<br>

&nbsp;&nbsp;(lambda&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;(call/cc&nbsp;(lambda&nbsp;(k)&nbsp;(k&nbsp;2&nbsp;3))))<br>

&nbsp;&nbsp;(lambda&nbsp;(x&nbsp;y)&nbsp;(list&nbsp;x&nbsp;y)))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(2&nbsp;3)</tt>
<p>The behavior is unspecified when a
continuation expecting exactly one value receives zero values or more
than one value.
For example, the behavior of each of the following expressions is
unspecified.
Some implementations raise an exception, while others silently
suppress additional values or supply defaults for missing values.

<p>

<p><tt>(if&nbsp;(values&nbsp;1&nbsp;2)&nbsp;'x&nbsp;'y)
<br>
<br>
(+&nbsp;(values)&nbsp;5)</tt>
<p>Programs that wish to force extra values to be ignored in particular
contexts can do so easily by calling <tt>call-with-values</tt> explicitly.
A syntactic form, which we might call <tt>first</tt>, can be defined to
abstract the discarding of more than one value when only one is
desired.

<p>

<p><tt>(define-syntax&nbsp;first<br>

&nbsp;&nbsp;(syntax-rules&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;expr)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(call-with-values<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;()&nbsp;expr)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(x&nbsp;.&nbsp;y)&nbsp;x))]))
<br>
<br>
(if&nbsp;(first&nbsp;(values&nbsp;#t&nbsp;#f))&nbsp;'a&nbsp;'b)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;a</tt>
<p>Since implementations are required to raise an exception with condition
type <tt>&amp;assertion</tt> if a procedure does not accept the number of
arguments passed to it, each of the following raises an exception.

<p>

<p><tt>(call-with-values<br>

&nbsp;&nbsp;(lambda&nbsp;()&nbsp;(values&nbsp;2&nbsp;3&nbsp;4))<br>

&nbsp;&nbsp;(lambda&nbsp;(x&nbsp;y)&nbsp;x))
<br>
<br>
(call-with-values<br>

&nbsp;&nbsp;(lambda&nbsp;()&nbsp;(call/cc&nbsp;(lambda&nbsp;(k)&nbsp;(k&nbsp;0))))<br>

&nbsp;&nbsp;(lambda&nbsp;(x&nbsp;y)&nbsp;x))</tt>
<p>Since <tt><i>producer</i></tt> is most often a <tt>lambda</tt> expression, it
is often convenient to use a syntactic extension that suppresses
the lambda expression in the interest of readability.

<p>

<p><tt>(define-syntax&nbsp;with-values<br>

&nbsp;&nbsp;(syntax-rules&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;expr&nbsp;consumer)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(call-with-values&nbsp;(lambda&nbsp;()&nbsp;expr)&nbsp;consumer)]))
<br>
<br>
(with-values&nbsp;(values&nbsp;1&nbsp;2)&nbsp;list)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(1&nbsp;2)<br>

(with-values&nbsp;(split&nbsp;'(1&nbsp;2&nbsp;3&nbsp;4))<br>

&nbsp;&nbsp;(lambda&nbsp;(odds&nbsp;evens)<br>

&nbsp;&nbsp;&nbsp;&nbsp;evens))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(2&nbsp;4)</tt>
<p>If the <tt><i>consumer</i></tt> is also a <tt>lambda</tt> expression, the
multiple-value variants of <tt>let</tt> and <tt>let*</tt> described
in Section&nbsp;<a href="./binding.html#g93">4.5</a> are usually even more
convenient.<a name="./control:s78"></a><a name="./control:s79"></a>

<p>

<p><tt>(let-values&nbsp;([(odds&nbsp;evens)&nbsp;(split&nbsp;'(1&nbsp;2&nbsp;3&nbsp;4))])<br>

&nbsp;&nbsp;evens)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(2&nbsp;4)
<br>
<br>
(let-values&nbsp;([ls&nbsp;(values&nbsp;'a&nbsp;'b&nbsp;'c)])<br>

&nbsp;&nbsp;ls)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(a&nbsp;b&nbsp;c)</tt>
<p>Many standard syntactic forms and procedures  pass along multiple values.
Most of these are "automatic," in the sense that nothing special
must be done by the implementation to make this happen.
The usual expansion of <tt>let</tt> into a direct
<tt>lambda</tt> call automatically propagates multiple
values produced by the body of the <tt>let</tt>.
Other operators must be coded specially to pass along multiple
values.
The <tt>call-with-port</tt> procedure (page&nbsp;<a href="./io.html#g127">7.6</a>),
for example, calls its procedure argument, then closes the port argument
before returning the procedure's values, so it must save the values
temporarily.
This is easily accomplished via <tt>let-values</tt>,
<tt>apply</tt>, and <tt>values</tt>:

<p>

<p><tt>(define&nbsp;call-with-port<a name="defn:call-with-port"></a><br>

&nbsp;&nbsp;(lambda&nbsp;(port&nbsp;proc)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(let-values&nbsp;([val*&nbsp;(proc&nbsp;port)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(close-port&nbsp;port)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(apply&nbsp;values&nbsp;val*))))</tt>
<p>If this seems like too much overhead when a single value is returned,
the code can use <tt>call-with-values</tt> and <tt>case-lambda</tt> to
handle the single-value case more efficiently:

<p>

<p><tt>(define&nbsp;call-with-port<br>

&nbsp;&nbsp;(lambda&nbsp;(port&nbsp;proc)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(call-with-values&nbsp;(lambda&nbsp;()&nbsp;(proc&nbsp;port))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(case-lambda<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(val)&nbsp;(close-port&nbsp;port)&nbsp;val]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[val*&nbsp;(close-port&nbsp;port)&nbsp;(apply&nbsp;values&nbsp;val*)]))))</tt>
<p>The definitions of <tt>values</tt> and <tt>call-with-values</tt> (and
concomitant redefinition of <tt>call/cc</tt>) in the library below
demonstrate that the multiple-return-values interface could be implemented
in Scheme if it were not already built in.
No error checking can be done, however, for the case in which more than one
value is returned to a single-value context, such as the test part
of an <tt>if</tt> expression.

<p>

<p><tt>(library&nbsp;(mrvs)<br>

&nbsp;&nbsp;(export&nbsp;call-with-values&nbsp;values&nbsp;call/cc<br>

&nbsp;&nbsp;&nbsp;&nbsp;(rename&nbsp;(call/cc&nbsp;call-with-current-continuation)))<br>

&nbsp;&nbsp;(import<br>

&nbsp;&nbsp;&nbsp;&nbsp;(rename<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(except&nbsp;(rnrs)&nbsp;values&nbsp;call-with-values)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(call/cc&nbsp;rnrs:call/cc)))
<br>
<br>
&nbsp;&nbsp;(define&nbsp;magic&nbsp;(cons&nbsp;'multiple&nbsp;'values))
<br>
<br>
&nbsp;&nbsp;(define&nbsp;magic?<br>

&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(and&nbsp;(pair?&nbsp;x)&nbsp;(eq?&nbsp;(car&nbsp;x)&nbsp;magic))))</tt>
<p>
<p><tt>&nbsp;&nbsp;(define&nbsp;call/cc<br>

&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(p)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(rnrs:call/cc<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(k)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(p&nbsp;(lambda&nbsp;args<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(k&nbsp;(apply&nbsp;values&nbsp;args))))))))
<br>
<br>
&nbsp;&nbsp;(define&nbsp;values<br>

&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;args<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(and&nbsp;(not&nbsp;(null?&nbsp;args))&nbsp;(null?&nbsp;(cdr&nbsp;args)))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(car&nbsp;args)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cons&nbsp;magic&nbsp;args))))
<br>
<br>
&nbsp;&nbsp;(define&nbsp;call-with-values<br>

&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(producer&nbsp;consumer)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([x&nbsp;(producer)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(magic?&nbsp;x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(apply&nbsp;consumer&nbsp;(cdr&nbsp;x))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(consumer&nbsp;x))))))</tt>
<p>Multiple values can be implemented more
efficiently&nbsp;[<a class=citation href="./bibliography.html#g220">2</a>], but this
code serves to illustrate the meanings of the operators
and may be used to provide multiple values in older, nonstandard
implementations that do not support them.


<p>

<h3><a name="g105"></a><a name="./control:h9"></a>Section 5.9. Eval<a name="SECTEVAL"></a></h3>



<p>
Scheme's <tt>eval</tt> procedure allows programmers to write
programs that construct and evaluate other programs.
This ability to do run-time <i>meta programming</i> should not be
overused but is handy when needed.

<p>
<a name="./control:s80"></a><span class=formdef><b>procedure</b>: <tt>(eval&nbsp;<i>obj</i>&nbsp;<i>environment</i>)</tt></span>
<br>
<b>returns: </b>values of the Scheme expression represented by <tt><i>obj</i></tt> in <tt><i>environment</i></tt>
<br>
<b>libraries: </b><tt>(rnrs&nbsp;eval)</tt>

<p>If <tt><i>obj</i></tt> does not represent a syntactically valid expression, <tt>eval</tt>
raises an exception with condition type <tt>&amp;syntax</tt>.
The environments returned by <tt>environment</tt>,
<tt>scheme-report-environment</tt>, and <tt>null-environment</tt> are
immutable.
Thus, <tt>eval</tt> also raises an exception with condition type
<tt>&amp;syntax</tt> if an assignment to any of the variables in the
environment appears within the expression.

<p>

<p><tt>(define&nbsp;cons&nbsp;'not-cons)<br>

(eval&nbsp;'(let&nbsp;([x&nbsp;3])&nbsp;(cons&nbsp;x&nbsp;4))&nbsp;(environment&nbsp;'(rnrs)))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(3&nbsp;.&nbsp;4)
<br>
<br>
(define&nbsp;lambda&nbsp;'not-lambda)<br>

(eval&nbsp;'(lambda&nbsp;(x)&nbsp;x)&nbsp;(environment&nbsp;'(rnrs)))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#&lt;procedure&gt;
<br>
<br>
(eval&nbsp;'(cons&nbsp;3&nbsp;4)&nbsp;(environment))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;<i>exception</i></tt>
<p><a name="./control:s81"></a><span class=formdef><b>procedure</b>: <tt>(environment&nbsp;<i>import-spec</i>&nbsp;...)</tt></span>
<br>
<b>returns: </b>an environment
<br>
<b>libraries: </b><tt>(rnrs&nbsp;eval)</tt>

<p><tt>environment</tt> returns an environment formed from the combined
bindings of the given import specifiers.
Each <tt><i>import-spec</i></tt> must be an s-expression representing a valid
import specifier (see Chapter&nbsp;<a href="./libraries.html#g142">10</a>).

<p>

<p><tt>(define&nbsp;env&nbsp;(environment&nbsp;'(rnrs)&nbsp;'(prefix&nbsp;(rnrs&nbsp;lists)&nbsp;$)))<br>

(eval&nbsp;'($cons*&nbsp;3&nbsp;4&nbsp;(*&nbsp;5&nbsp;8))&nbsp;env)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(3&nbsp;4&nbsp;.&nbsp;40)</tt>
<p><a name="./control:s82"></a><span class=formdef><b>procedure</b>: <tt>(null-environment&nbsp;<i>version</i>)</tt></span>
<br>
<span class=formdef><b>procedure</b>: <tt>(scheme-report-environment&nbsp;<i>version</i>)</tt></span>
<br>
<b>returns: </b>an R5RS compatibility environment
<br>
<b>libraries: </b><tt>(rnrs&nbsp;r5rs)</tt>

<p><tt><i>version</i></tt> must be the exact integer <tt>5</tt>.

<p>
<tt>null-environment</tt> returns an environment containing
bindings for the keywords whose meanings are defined by the
Revised<sup>5</sup> Report on Scheme, along with bindings for the
auxiliary keywords <tt>else</tt>, <tt>=&gt;</tt>, <tt>...</tt>,
and <tt>_</tt>.

<p>
<tt>scheme-report-environment</tt> returns an environment containing
the same keyword bindings as the environment
returned by <tt>null-environment</tt> along with bindings for
the variables whose meanings are defined by the Revised<sup>5</sup> Report on
Scheme, except those not defined by the Revised<sup>6</sup> Report:
<tt>load</tt>, <tt>interaction-environment</tt>,
<tt>transcript-on</tt>, <tt>transcript-off</tt>, and
<tt>char-ready?</tt>.

<p>
The bindings for each of the identifiers in the environments returned
by these procedures are those of the corresponding Revised<sup>6</sup> Report
library, so this does not provide full backward compatibility, even if the
excepted identifier bindings are not used.




<hr class=copyright align=left>
<p>
R. Kent Dybvig / <it>The Scheme Programming Language, Fourth Edition</it><br>
Copyright &copy; 2009 <a class=plain href="http://mitpress.mit.edu/catalog/item/default.asp?ttype=2&tid=11984">The MIT Press</a>.  Electronically reproduced by permission.<br>
Illustrations &copy; 2009 <a class=plain href="http://hebert.kitp.ucsb.edu/">Jean-Pierre H&eacute;bert</a><br>
ISBN 978-0-262-51298-5 / LOC QA76.73.S34D93<br>
<a class=plain href="http://mitpress.mit.edu/catalog/item/default.asp?ttype=2&tid=11984">to order this book</a> / <a class=plain href="canned/about.html">about this book</a>
</p>
<p><a class=plain href="http://www.scheme.com">http://www.scheme.com</a></p>
</body>
</html>
