<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
  "http://www.w3.org/TR/html4/loose.dtd"><!-- DO NOT EDIT THIS FILE-->
<!-- Edit the .tex version instead-->

<html>
<head>
<meta charset="utf-8">
<title>Input and Output</title>
<link href="tspl.css" rel="stylesheet" type="text/css">
</head>
<body>
<a name="g121"></a>
<a name="./io:h0"></a>

<div style="font-size: 12px; width: 500px; height: 500px; border: solid thin">
<img style="padding: 20px 10px 20px 20px" src="canned/ch7.png"><img src="canned/jph.png">
</div>
<h1>Chapter 7. Input and Output<a name="CHPTIO"></a></h1>





<p>
<a name="./io:s0"></a><a name="./io:s1"></a><a name="./io:s2"></a>All input and output operations are performed through <i>ports</i>.
A port is a pointer into a (possibly infinite) stream of data
(often a <a name="./io:s3"></a>file), an opening through which programs may draw bytes
or characters from the stream or place bytes or characters into the stream.
A port may be an input port, an output port, or both simultaneously.

<p>
Ports are first-class objects, like any other object in Scheme.
Like procedures, ports do not have a printed representation the way strings
and numbers do.
There are initially three ports: the current input port,
current output port, and current error port, which are textual ports
connected to the process's standard input, standard output, and
standard error streams.
Several ways to open new ports are provided.

<p>
An input port often points to a finite stream, e.g., an input
file stored on disk.
If one of the input operations, e.g., <tt>get-u8</tt>, <tt>get-char</tt>, or
<tt>get-datum</tt>, is asked to
read from a port that has reached the end of a finite stream, it returns
a special <a name="./io:s4"></a><i>eof</i> (end of file) <i>object</i>.
The predicate <a name="./io:s5"></a><tt>eof-object?</tt> may be used
to determine if the value returned from the input operation is the eof
object.

<p>
<a name="./io:s6"></a><a name="./io:s7"></a><a name="./io:s8"></a>Ports are either <i>binary</i> or <i>textual</i>.
A binary port allows a program to read or write 8-bit unsigned bytes, or
"octets," from or to the underlying stream.
A textual port allows a program to read or write characters.

<p>
<a name="./io:s9"></a><a name="./io:s10"></a><a name="./io:s11"></a><a name="./io:s12"></a><a name="./io:s13"></a>In many cases, the underlying stream is organized as a sequence of bytes,
but these bytes should be treated as encodings for characters.
In this case, a textual port may be created with a <i>transcoder</i> to
decode bytes to characters (for input) or encode characters to bytes (for
output).
A transcoder encapsulates a <i>codec</i> that determines how characters
are represented as bytes.
Three standard codecs are provided: a <i>latin-1</i> codec, a Unicode
<i>utf-8</i> codec, and a Unicode <i>utf-16</i> codec.
For the <i>latin-1</i> encoding, each character is represented by exactly
one byte.
For <i>utf-8</i>, each character is represented by from one
to four bytes, and for <i>utf-16</i>, each character is represented by
two or four bytes.

<p>
<a name="./io:s14"></a>A transcoder also encapsulates an <i>eol style</i> that determines
whether and how line endings are recognized.
If the eol style is <tt>none</tt>, no line endings are recognized.
The six other standard eol styles are the following:

<p>
<TABLE><TR><TD nowrap align="left">
<tt>lf</tt>: </TD><TD nowrap align="left"> line-feed character</TD></TR><TR><TD nowrap align="left">
<tt>cr</tt>: </TD><TD nowrap align="left"> carriage-return character</TD></TR><TR><TD nowrap align="left">
<tt>nel</tt>: </TD><TD nowrap align="left"> Unicode next-line character</TD></TR><TR><TD nowrap align="left">
<tt>ls</tt>: </TD><TD nowrap align="left"> Unicode line-separator character</TD></TR><TR><TD nowrap align="left">
<tt>crlf</tt>: </TD><TD nowrap align="left"> carriage return followed by line feed, and</TD></TR><TR><TD nowrap align="left">
<tt>crnel</tt>: </TD><TD nowrap align="left"> carriage return followed by next line
</TD></TR></TABLE>

<p>
The eol style affects input and output operations differently.
For input, any eol style except <tt>none</tt> causes each of the
line-ending characters or two-character sequences to be converted
into a single line-feed character.
For output, any eol style except <tt>none</tt> causes line-feed
characters to be converted into the specific
one- or two-character sequence associated with the eol style.
In the input direction, all eol styles except <tt>none</tt> are
equivalent, while in the output direction, the eol styles
<tt>none</tt> and <tt>lf</tt> are equivalent.

<p>
<a name="./io:s15"></a>In addition to the codec and eol style, a transcoder encapsulates just one
other piece of information:  an <i>error-handling mode</i> that determines
what happens if a decoding or encoding error occurs, i.e., if a sequence
of bytes cannot be converted to a character with the encapsulated codec in the
input direction or a character cannot be converted to a sequence of bytes
with the encapsulated codec in the output direction.
The error-handling mode is <tt>ignore</tt>, <tt>raise</tt>, or
<tt>replace</tt>.
If the error-handling mode is <tt>ignore</tt>, the offending sequence of
bytes or the character is ignored.
If the error-handling mode is <tt>raise</tt>, an exception with condition
type <tt>i/o-decoding</tt> or <tt>i/o-encoding</tt> is raised; in the
input direction, the port is positioned beyond the sequence of bytes.
If the error-handling mode is <tt>replace</tt>, a replacement character
or character encoding is produced: in the input direction, the replacement
character is U+FFFD, while in the output direction, the replacement is
either the encoding of U+FFFD for <tt>utf-8</tt> and <tt>utf-16</tt>
codecs or the encoding of the question-mark character (&nbsp;?&nbsp;) for the
<tt>latin-1</tt> codec.

<p>
<a name="./io:s16"></a><a name="./io:s17"></a><a name="./io:s18"></a>A port may be buffered for efficiency, to eliminate the overhead of a call
into the operating system for each byte or character.
Three standard buffer modes are supported: <i>block</i>, <i>line</i>,
and <i>none</i>.
With block buffering, input is drawn from a stream and output is sent to
the stream in chunks of some implementation-dependent size.
With line buffering, buffering is performed on a line-by-line basis or on
some other implementation-dependent basis.
Line buffering is typically distinguished from block buffering only for
textual output ports; there are no line divisions in binary ports, and
input is likely to be drawn from a stream as it becomes available.
With buffer-mode none, no buffering is performed, so output is sent
immediately to the stream and input is drawn only as needed.

<p>
The remainder of this chapter covers operations on transcoders,
file ports, standard ports, string and bytevector ports, custom ports,
general port operations, input operations, output operations,
convenience I/O, filesystem operations, and conversions between
bytevectors and strings.

<p>

<h3><a name="g122"></a><a name="./io:h1"></a>Section 7.1. Transcoders<a name="SECTTRANSCODERS"></a></h3>



<p>
As described above, transcoders encapsulate three values: a codec, an eol
style, and an error-handling mode.
This section describes the procedures that create or operate on
transcoders and the values that transcoders encapsulate.

<p>
<a name="./io:s19"></a><span class=formdef><b>procedure</b>: <tt>(make-transcoder&nbsp;<i>codec</i>)</tt></span>
<br>
<span class=formdef><b>procedure</b>: <tt>(make-transcoder&nbsp;<i>codec</i>&nbsp;<i>eol-style</i>)</tt></span>
<br>
<span class=formdef><b>procedure</b>: <tt>(make-transcoder&nbsp;<i>codec</i>&nbsp;<i>eol-style</i>&nbsp;<i>error-handling-mode</i>)</tt></span>
<br>
<b>returns: </b>a transcoder encapsulating <tt><i>codec</i></tt>, <tt><i>eol-style</i></tt>, and <tt><i>error-handling-mode</i></tt>
<br>
<b>libraries: </b><tt>(rnrs&nbsp;io&nbsp;ports)</tt>, <tt>(rnrs)</tt>

<p><tt><i>eol-style</i></tt> must be a valid eol-style symbol
(<tt>lf</tt>, <tt>cr</tt>, <tt>nel</tt>, <tt>ls</tt>, <tt>crlf</tt>,
<tt>crnel</tt>, or <tt>none</tt>); it defaults to the native
eol-style for the platform.
<tt><i>error-handling-mode</i></tt> must be a valid error-handling-mode
symbol (<tt>ignore</tt>, <tt>raise</tt>, or <tt>replace</tt>)
and defaults to <tt>replace</tt>.


<p>
<a name="./io:s20"></a><span class=formdef><b>procedure</b>: <tt>(transcoder-codec&nbsp;<i>transcoder</i>)</tt></span>
<br>
<b>returns: </b>the codec encapsulated in <tt><i>transcoder</i></tt>
<br>
<span class=formdef><b>procedure</b>: <tt>(transcoder-eol-style&nbsp;<i>transcoder</i>)</tt></span>
<br>
<b>returns: </b>the eol-style symbol encapsulated in <tt><i>transcoder</i></tt>
<br>
<span class=formdef><b>procedure</b>: <tt>(transcoder-error-handling-mode&nbsp;<i>transcoder</i>)</tt></span>
<br>
<b>returns: </b>the error-handling-mode symbol encapsulated in <tt><i>transcoder</i></tt>
<br>
<b>libraries: </b><tt>(rnrs&nbsp;io&nbsp;ports)</tt>, <tt>(rnrs)</tt>

<p><a name="./io:s21"></a><span class=formdef><b>procedure</b>: <tt>(native-transcoder)</tt></span>
<br>
<b>returns: </b>the native transcoder
<br>
<b>libraries: </b><tt>(rnrs&nbsp;io&nbsp;ports)</tt>, <tt>(rnrs)</tt>

<p>The native transcoder is implementation-dependent and may vary
by platform or locale.


<p>
<a name="./io:s22"></a><span class=formdef><b>procedure</b>: <tt>(latin-1-codec)</tt></span>
<br>
<b>returns: </b>a codec for ISO 8859-1 (Latin 1) character encodings
<br>
<span class=formdef><b>procedure</b>: <tt>(utf-8-codec)</tt></span>
<br>
<b>returns: </b>a codec for Unicode UTF-8 character encodings
<br>
<span class=formdef><b>procedure</b>: <tt>(utf-16-codec)</tt></span>
<br>
<b>returns: </b>a codec for Unicode UTF-16 character encodings
<br>
<b>libraries: </b><tt>(rnrs&nbsp;io&nbsp;ports)</tt>, <tt>(rnrs)</tt>

<p><a name="./io:s23"></a><span class=formdef><b>syntax</b>: <tt>(eol-style&nbsp;<i>symbol</i>)</tt></span>
<br>
<b>returns: </b><tt><i>symbol</i></tt>
<br>
<b>libraries: </b><tt>(rnrs&nbsp;io&nbsp;ports)</tt>, <tt>(rnrs)</tt>

<p><tt><i>symbol</i></tt> must be one of the symbols <tt>lf</tt>, <tt>cr</tt>, <tt>nel</tt>,
<tt>ls</tt>, <tt>crlf</tt>, <tt>crnel</tt>, or <tt>none</tt>.
The expression <tt>(eol-style&nbsp;<i>symbol</i>)</tt> is equivalent to the
expression <tt>(quote&nbsp;<i>symbol</i>)</tt> except the former checks at
expansion time that <tt><i>symbol</i></tt> is one of the eol-style symbols.
The <tt>eol-style</tt> syntax provides useful documentation as well.

<p>

<p><tt>(eol-style&nbsp;crlf)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;crlf<br>

(eol-style&nbsp;lfcr)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;<i>syntax&nbsp;violation</i></tt>
<p><a name="./io:s24"></a><span class=formdef><b>procedure</b>: <tt>(native-eol-style)</tt></span>
<br>
<b>returns: </b>the native eol style
<br>
<b>libraries: </b><tt>(rnrs&nbsp;io&nbsp;ports)</tt>, <tt>(rnrs)</tt>

<p>The native eol style is implementation-dependent and may vary
by platform or locale.


<p>
<a name="./io:s25"></a><span class=formdef><b>syntax</b>: <tt>(error-handling-mode&nbsp;<i>symbol</i>)</tt></span>
<br>
<b>returns: </b><tt><i>symbol</i></tt>
<br>
<b>libraries: </b><tt>(rnrs&nbsp;io&nbsp;ports)</tt>, <tt>(rnrs)</tt>

<p><tt><i>symbol</i></tt> must be one of the symbols <tt>ignore</tt>, <tt>raise</tt>,
or <tt>replace</tt>.
The expression <tt>(error-handling-mode&nbsp;<i>symbol</i>)</tt> is equivalent to the
expression <tt>(quote&nbsp;<i>symbol</i>)</tt> except that the former checks at
expansion time that <tt><i>symbol</i></tt> is one of the error-handling-mode symbols.
The <tt>error-handling-mode</tt> syntax provides useful documentation as well.

<p>

<p><tt>(error-handling-mode&nbsp;replace)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;replace<br>

(error-handling-mode&nbsp;relpace)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;<i>syntax&nbsp;violation</i></tt>
<p>
<h3><a name="g123"></a><a name="./io:h2"></a>Section 7.2. Opening Files<a name="SECTOPENINGFILES"></a></h3>



<p>
The procedures in this section are used for opening file ports.
Procedures for opening other kinds of ports, e.g., string
ports or custom ports, are described in subsequent sections.

<p>
Each of the file-open operations accepts a <tt><i>path</i></tt> argument
that names the file to be opened.
It must be a string or some other implementation-dependent value that
names a file.

<p>
Some of the file-open procedures accept optional <tt><i>options</i></tt>,
<tt><i>b-mode</i></tt>, and <tt><i>?transcoder</i></tt> arguments.
<tt><i>options</i></tt> must be an enumeration set over the symbols constituting
valid file options described in the <tt>file-options</tt> entry below,
and it defaults to the value of <tt>(file-options)</tt>.
<tt><i>b-mode</i></tt> must be a valid buffer mode described in the <tt>buffer-mode</tt>
entry below, and it defaults to <tt>block</tt>.
<tt><i>?transcoder</i></tt> must be a transcoder or <tt>#f</tt>; if it
is a transcoder, the open operation returns a transcoded port for
the underlying binary file, while if it is <tt>#f</tt> (the
default), the open operation returns a binary port.

<p>
Binary ports created by the procedures in this section support
the <tt>port-position</tt> and <tt>set-port-position!</tt> operations.
Whether textual ports created by the procedures in this section support
these operations is implementation-dependent.


<p>
<a name="./io:s26"></a><span class=formdef><b>syntax</b>: <tt>(file-options&nbsp;<i>symbol</i>&nbsp;...)</tt></span>
<br>
<b>returns: </b>a file-options enumeration set
<br>
<b>libraries: </b><tt>(rnrs&nbsp;io&nbsp;ports)</tt>, <tt>(rnrs)</tt>

<p>File-options enumeration sets may be passed to file-open operations to
control aspects of the open operation.
There are three standard file options: <tt>no-create</tt>, <tt>no-fail</tt>,
and <tt>no-truncate</tt>, which affect only file-open operations that
create output (including input/output) ports.

<p>
With the default file options, i.e., the value of <tt>(file-options)</tt>,
when a program attempts to open a file for output, an exception is raised with
condition type <tt>i/o-file-already-exists</tt> if the file already exists,
and the file is created if it does not already exist.
If the <tt>no-fail</tt> option is included, no exception is raised if the
file already exists; instead, the file is opened and truncated to zero
length.
If the <tt>no-create</tt> option is included, the file is not created if
it does not exist; instead, an exception is raised with condition type
<tt>i/o-file-does-not-exist</tt>.
The <tt>no-create</tt> option implies the <tt>no-fail</tt> option.
The <tt>no-truncate</tt> option is relevant only if the <tt>no-fail</tt>
option is included or implied, in which case if an existing file is
opened, it is not truncated, but the port's position is still set to the
beginning of the file.

<p>
It is perhaps easier to imagine that the default file options are the
imaginary option symbols <tt>create</tt>, <tt>fail-if-exists</tt>, and
<tt>truncate</tt>; <tt>no-create</tt> removes
<tt>create</tt>, <tt>no-fail</tt> removes <tt>fail-if-exists</tt>, and
<tt>no-truncate</tt> removes <tt>truncate</tt>.

<p>
Implementations may support additional file option symbols.
Chez&nbsp;Scheme, for example, supports options that control whether the file
is or should be compressed, whether it is locked for exclusive access, and
what permissions are given to the file if it is created&nbsp;[<a class=citation href="./bibliography.html#g227">9</a>].


<p>
<a name="./io:s27"></a><span class=formdef><b>syntax</b>: <tt>(buffer-mode&nbsp;<i>symbol</i>)</tt></span>
<br>
<b>returns: </b><tt><i>symbol</i></tt>
<br>
<b>libraries: </b><tt>(rnrs&nbsp;io&nbsp;ports)</tt>, <tt>(rnrs)</tt>

<p><tt><i>symbol</i></tt> must be one of the symbols <tt>block</tt>, <tt>line</tt>, or
<tt>none</tt>.
The expression <tt>(buffer-mode&nbsp;<i>symbol</i>)</tt> is equivalent to the
expression <tt>(quote&nbsp;<i>symbol</i>)</tt> except that the former checks at
expansion time that <tt><i>symbol</i></tt> is one of the buffer-mode symbols.
The <tt>buffer-mode</tt> syntax provides useful documentation as well.

<p>

<p><tt>(buffer-mode&nbsp;block)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;block<br>

(buffer-mode&nbsp;cushion)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;<i>syntax&nbsp;violation</i></tt>
<p><a name="./io:s28"></a><span class=formdef><b>syntax</b>: <tt>(buffer-mode?&nbsp;<i>obj</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if <tt><i>obj</i></tt> is a valid buffer mode, <tt>#f</tt> otherwise
<br>
<b>libraries: </b><tt>(rnrs&nbsp;io&nbsp;ports)</tt>, <tt>(rnrs)</tt>

<p>
<p><tt>(buffer-mode?&nbsp;'block)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(buffer-mode?&nbsp;'line)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(buffer-mode?&nbsp;'none)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(buffer-mode?&nbsp;'something-else)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f</tt>
<p><a name="./io:s29"></a><span class=formdef><b>procedure</b>: <tt>(open-file-input-port&nbsp;<i>path</i>)</tt></span>
<br>
<span class=formdef><b>procedure</b>: <tt>(open-file-input-port&nbsp;<i>path</i>&nbsp;<i>options</i>)</tt></span>
<br>
<span class=formdef><b>procedure</b>: <tt>(open-file-input-port&nbsp;<i>path</i>&nbsp;<i>options</i>&nbsp;<i>b-mode</i>)</tt></span>
<br>
<span class=formdef><b>procedure</b>: <tt>(open-file-input-port&nbsp;<i>path</i>&nbsp;<i>options</i>&nbsp;<i>b-mode</i>&nbsp;<i>?transcoder</i>)</tt></span>
<br>
<b>returns: </b>a new input port for the named file
<br>
<b>libraries: </b><tt>(rnrs&nbsp;io&nbsp;ports)</tt>, <tt>(rnrs)</tt>

<p>If <tt><i>?transcoder</i></tt> is present and not <tt>#f</tt>, it must be a
transcoder, and this procedure returns a textual input port
whose transcoder is <tt><i>?transcoder</i></tt>.
Otherwise, this procedure returns a binary input port.
See the lead-in to this section for a description of the constraints
on and effects of the other arguments.


<p>
<a name="./io:s30"></a><span class=formdef><b>procedure</b>: <tt>(open-file-output-port&nbsp;<i>path</i>)</tt></span>
<br>
<span class=formdef><b>procedure</b>: <tt>(open-file-output-port&nbsp;<i>path</i>&nbsp;<i>options</i>)</tt></span>
<br>
<span class=formdef><b>procedure</b>: <tt>(open-file-output-port&nbsp;<i>path</i>&nbsp;<i>options</i>&nbsp;<i>b-mode</i>)</tt></span>
<br>
<span class=formdef><b>procedure</b>: <tt>(open-file-output-port&nbsp;<i>path</i>&nbsp;<i>options</i>&nbsp;<i>b-mode</i>&nbsp;<i>?transcoder</i>)</tt></span>
<br>
<b>returns: </b>a new output port for the named file
<br>
<b>libraries: </b><tt>(rnrs&nbsp;io&nbsp;ports)</tt>, <tt>(rnrs)</tt>

<p>If <tt><i>?transcoder</i></tt> is present and not <tt>#f</tt>, it must be a
transcoder, and this procedure returns a textual output port
whose transcoder is <tt><i>?transcoder</i></tt>.
Otherwise, this procedure returns a binary output port.
See the lead-in to this section for a description of the constraints
on and effects of the other arguments.


<p>
<a name="./io:s31"></a><span class=formdef><b>procedure</b>: <tt>(open-file-input/output-port&nbsp;<i>path</i>)</tt></span>
<br>
<span class=formdef><b>procedure</b>: <tt>(open-file-input/output-port&nbsp;<i>path</i>&nbsp;<i>options</i>)</tt></span>
<br>
<span class=formdef><b>procedure</b>: <tt>(open-file-input/output-port&nbsp;<i>path</i>&nbsp;<i>options</i>&nbsp;<i>b-mode</i>)</tt></span>
<br>
<span class=formdef><b>procedure</b>: <tt>(open-file-input/output-port&nbsp;<i>path</i>&nbsp;<i>options</i>&nbsp;<i>b-mode</i>&nbsp;<i>?transcoder</i>)</tt></span>
<br>
<b>returns: </b>a new input/output port for the named file
<br>
<b>libraries: </b><tt>(rnrs&nbsp;io&nbsp;ports)</tt>, <tt>(rnrs)</tt>

<p>If <tt><i>?transcoder</i></tt> is present and not <tt>#f</tt>, it must be a
transcoder, and this procedure returns a textual input/output port
whose transcoder is <tt><i>?transcoder</i></tt>.
Otherwise, this procedure returns a binary input/output port.
See the lead-in to this section for a description of the constraints
on and effects of the other arguments.


<p>

<h3><a name="g124"></a><a name="./io:h3"></a>Section 7.3. Standard Ports<a name="SECTSTANDARDPORTS"></a></h3>



<p>
The procedures described in this section return ports that are attached to
a process's standard input, standard output, and standard error streams.
The first set returns "ready-made" textual ports with implementation-dependent
transcoders (if any) and buffer modes.
The second set creates fresh binary ports and can be used either for binary
input/output or, with the help of <tt>transcoded-port</tt>, for textual
input/output with program-supplied transcoders and buffer modes.

<p>
<a name="./io:s32"></a><span class=formdef><b>procedure</b>: <tt>(current-input-port)</tt></span>
<br>
<b>returns: </b>the current input port
<br>
<span class=formdef><b>procedure</b>: <tt>(current-output-port)</tt></span>
<br>
<b>returns: </b>the current output port
<br>
<span class=formdef><b>procedure</b>: <tt>(current-error-port)</tt></span>
<br>
<b>returns: </b>the current error port
<br>
<b>libraries: </b><tt>(rnrs&nbsp;io&nbsp;ports)</tt>, <tt>(rnrs&nbsp;io&nbsp;simple)</tt>, <tt>(rnrs)</tt>

<p>The current-input, current-output, and current-error ports return
pre-built textual ports that are initially associated with a process's
standard input, standard output, and standard error streams.

<p>
The values returned by <tt>current-input-port</tt> and
<tt>current-output-port</tt> can be altered temporarily by the
convenience I/O procedures
<tt>with-input-from-file</tt> and <tt>with-output-to-file</tt>
(Section&nbsp;<a href="./io.html#g130">7.9</a>).

<p>
<a name="./io:s33"></a><span class=formdef><b>procedure</b>: <tt>(standard-input-port)</tt></span>
<br>
<b>returns: </b>a fresh binary input port connected to the standard input stream
<br>
<span class=formdef><b>procedure</b>: <tt>(standard-output-port)</tt></span>
<br>
<b>returns: </b>a fresh binary output port connected to the standard output stream
<br>
<span class=formdef><b>procedure</b>: <tt>(standard-error-port)</tt></span>
<br>
<b>returns: </b>a fresh binary output port connected to the standard error stream
<br>
<b>libraries: </b><tt>(rnrs&nbsp;io&nbsp;ports)</tt>, <tt>(rnrs)</tt>

<p>Because ports may be buffered, confusion can result if operations on
more than one port attached to one of a process's standard streams are
interleaved.
Thus, these procedures are typically appropriate only when a program
no longer needs to use any existing ports attached to the standard
streams.


<p>

<h3><a name="g125"></a><a name="./io:h4"></a>Section 7.4. String and Bytevector Ports<a name="SECTSTRINGPORTS"></a></h3>



<p>
The procedures in this section allow bytevectors and strings to be used
as input or output streams.

<p>
Binary ports created by the procedures in this section support
the <tt>port-position</tt> and <tt>set-port-position!</tt> operations.
Whether textual ports created by the procedures in this section support
these operations is implementation-dependent.

<p>
<a name="./io:s34"></a><span class=formdef><b>procedure</b>: <tt>(open-bytevector-input-port&nbsp;<i>bytevector</i>)</tt></span>
<br>
<span class=formdef><b>procedure</b>: <tt>(open-bytevector-input-port&nbsp;<i>bytevector</i>&nbsp;<i>?transcoder</i>)</tt></span>
<br>
<b>returns: </b>a new input port that draws input from <tt><i>bytevector</i></tt>
<br>
<b>libraries: </b><tt>(rnrs&nbsp;io&nbsp;ports)</tt>, <tt>(rnrs)</tt>

<p>If <tt><i>?transcoder</i></tt> is present and not <tt>#f</tt>, it must be a
transcoder, and this procedure returns a textual input port
whose transcoder is <tt><i>?transcoder</i></tt>.
Otherwise, this procedure returns a binary input port.

<p>
The effect of modifying <tt><i>bytevector</i></tt> after this procedure is called
is unspecified.

<p>

<p><tt>(let&nbsp;([ip&nbsp;(open-bytevector-input-port&nbsp;#vu8(1&nbsp;2))])<br>

&nbsp;&nbsp;(let*&nbsp;([x1&nbsp;(get-u8&nbsp;ip)]&nbsp;[x2&nbsp;(get-u8&nbsp;ip)]&nbsp;[x3&nbsp;(get-u8&nbsp;ip)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;(list&nbsp;x1&nbsp;x2&nbsp;(eof-object?&nbsp;x3))))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(1&nbsp;2&nbsp;#t)</tt>
<p>There is no need to close a bytevector port; it's storage will be reclaimed
automatically when it is no longer needed, as with any other object, and
an open bytevector port does not tie up any operating system resources.


<p>
<a name="./io:s35"></a><span class=formdef><b>procedure</b>: <tt>(open-string-input-port&nbsp;<i>string</i>)</tt></span>
<br>
<b>returns: </b>a new textual input port that draws input from <tt><i>string</i></tt>
<br>
<b>libraries: </b><tt>(rnrs&nbsp;io&nbsp;ports)</tt>, <tt>(rnrs)</tt>

<p>The effect of modifying <tt><i>string</i></tt> after this procedure is called
is unspecified.
The new port may or may not have a transcoder, and if it does, the transcoder
is implementation-dependent.
While not required, implementations are encouraged to support <tt>port-position</tt>
and <tt>set-port-position!</tt> for string ports.

<p>

<p><tt>(get-line&nbsp;(open-string-input-port&nbsp;"hi.\nwhat's&nbsp;up?\n"))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;"hi."</tt>
<p>There is no need to close a string port; it's storage will be reclaimed
automatically when it is no longer needed, as with any other object, and
an open string port does not tie up any operating system resources.

<p>
<a name="./io:s36"></a><span class=formdef><b>procedure</b>: <tt>(open-bytevector-output-port)</tt></span>
<br>
<span class=formdef><b>procedure</b>: <tt>(open-bytevector-output-port&nbsp;<i>?transcoder</i>)</tt></span>
<br>
<b>returns: </b>two values, a new output port and an extraction procedure
<br>
<b>libraries: </b><tt>(rnrs&nbsp;io&nbsp;ports)</tt>, <tt>(rnrs)</tt>

<p>If <tt><i>?transcoder</i></tt> is present and not <tt>#f</tt>, it must be a
transcoder, and the port value is a textual output port
whose transcoder is <tt><i>?transcoder</i></tt>.
Otherwise, the port value is a binary output port.

<p>
The extraction procedure is a procedure that, when called without
arguments, creates a bytevector containing the accumulated bytes in the
port, clears the port of its accumulated bytes, resets its position to
zero, and returns the bytevector.
The accumulated bytes include any bytes written beyond the end of
the current position, if the position has been set back from its
maximum extent.

<p>

<p><tt>(let-values&nbsp;([(op&nbsp;g)&nbsp;(open-bytevector-output-port)])<br>

&nbsp;&nbsp;(put-u8&nbsp;op&nbsp;15)<br>

&nbsp;&nbsp;(put-u8&nbsp;op&nbsp;73)<br>

&nbsp;&nbsp;(put-u8&nbsp;op&nbsp;115)<br>

&nbsp;&nbsp;(set-port-position!&nbsp;op&nbsp;2)<br>

&nbsp;&nbsp;(let&nbsp;([bv1&nbsp;(g)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;(put-u8&nbsp;op&nbsp;27)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(list&nbsp;bv1&nbsp;(g))))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(#vu8(15&nbsp;73&nbsp;115)&nbsp;#vu8(27))</tt>
<p>There is no need to close a bytevector port; it's storage will be reclaimed
automatically when it is no longer needed, as with any other object, and
an open bytevector port does not tie up any operating system resources.


<p>
<a name="./io:s37"></a><span class=formdef><b>procedure</b>: <tt>(open-string-output-port)</tt></span>
<br>
<b>returns: </b>two values, a new textual output port and an extraction procedure
<br>
<b>libraries: </b><tt>(rnrs&nbsp;io&nbsp;ports)</tt>, <tt>(rnrs)</tt>

<p>The extraction procedure is a procedure that, when called without
arguments, creates a string containing the accumulated characters in the
port, clears the port of its accumulated characters, resets its position to
zero, and returns the string.
The accumulated characters include any characters written beyond the end of
the current position, if the position has been set back from its
maximum extent.
While not required, implementations are encouraged to support <tt>port-position</tt>
and <tt>set-port-position!</tt> for string ports.

<p>

<p><tt>(let-values&nbsp;([(op&nbsp;g)&nbsp;(open-string-output-port)])<br>

&nbsp;&nbsp;(put-string&nbsp;op&nbsp;"some&nbsp;data")<br>

&nbsp;&nbsp;(let&nbsp;([str1&nbsp;(g)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;(put-string&nbsp;op&nbsp;"new&nbsp;stuff")<br>

&nbsp;&nbsp;&nbsp;&nbsp;(list&nbsp;str1&nbsp;(g))))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;("some&nbsp;data"&nbsp;"new&nbsp;stuff")</tt>
<p>There is no need to close a string port; it's storage will be reclaimed
automatically when it is no longer needed, as with any other object, and
an open string port does not tie up any operating system resources.


<p>
<a name="./io:s38"></a><span class=formdef><b>procedure</b>: <tt>(call-with-bytevector-output-port&nbsp;<i>procedure</i>)</tt></span>
<br>
<span class=formdef><b>procedure</b>: <tt>(call-with-bytevector-output-port&nbsp;<i>procedure</i>&nbsp;<i>?transcoder</i>)</tt></span>
<br>
<b>returns: </b>a bytevector containing the accumulated bytes
<br>
<b>libraries: </b><tt>(rnrs&nbsp;io&nbsp;ports)</tt>, <tt>(rnrs)</tt>

<p>If <tt><i>?transcoder</i></tt> is present and not <tt>#f</tt>, it must be a
transcoder, and <tt><i>procedure</i></tt> is called with a textual bytevector output port
whose transcoder is <tt><i>?transcoder</i></tt>.
Otherwise, <tt><i>procedure</i></tt> is called with a binary bytevector output port.
If <tt><i>procedure</i></tt> returns, a bytevector containing the bytes accumulated in the port
is created, the accumulated bytes are cleared from the port, the port's position is
reset to zero, and the bytevector is returned from <tt>call-with-bytevector-output-port</tt>.
These actions occur each time <tt><i>procedure</i></tt> returns, if it returns
multiple times due to the invocation of a continuation created while
<tt><i>procedure</i></tt> is active.

<p>

<p><tt>(let&nbsp;([tx&nbsp;(make-transcoder&nbsp;(latin-1-codec)&nbsp;(eol-style&nbsp;lf)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(error-handling-mode&nbsp;replace))])<br>

&nbsp;&nbsp;(call-with-bytevector-output-port<br>

&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(p)&nbsp;(put-string&nbsp;p&nbsp;"abc"))<br>

&nbsp;&nbsp;&nbsp;&nbsp;tx))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#vu8(97&nbsp;98&nbsp;99)</tt>
<p><a name="./io:s39"></a><span class=formdef><b>procedure</b>: <tt>(call-with-string-output-port&nbsp;<i>procedure</i>)</tt></span>
<br>
<b>returns: </b>a string containing the accumulated characters
<br>
<b>libraries: </b><tt>(rnrs&nbsp;io&nbsp;ports)</tt>, <tt>(rnrs)</tt>

<p><tt><i>procedure</i></tt> is called with one argument, a string output port.
If <tt><i>procedure</i></tt> returns, a string containing the characters accumulated in the port
is created, the accumulated characters are cleared from the port, the port's position is
reset to zero, and the string is returned from <tt>call-with-string-output-port</tt>.
These actions occur each time <tt><i>procedure</i></tt> returns, if it returns
multiple times due to the invocation of a continuation created while
<tt><i>procedure</i></tt> is active.

<p>
<a name="./io:s40"></a><tt>call-with-string-output-port</tt> can be used along with
<tt>put-datum</tt> to define a procedure, <tt>object-&gt;string</tt>, that
returns a string containing the printed representation of an object.

<p>

<p><tt>(define&nbsp;(object-&gt;string&nbsp;x)<br>

&nbsp;&nbsp;(call-with-string-output-port<br>

&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(p)&nbsp;(put-datum&nbsp;p&nbsp;x))))
<br>
<br>
(object-&gt;string&nbsp;(cons&nbsp;'a&nbsp;'(b&nbsp;c)))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;"(a&nbsp;b&nbsp;c)"</tt>
<p>
<h3><a name="g126"></a><a name="./io:h5"></a>Section 7.5. Opening Custom Ports<a name="SECTCUSTOMPORTS"></a></h3>



<p>
<a name="./io:s41"></a><span class=formdef><b>procedure</b>: <tt>(make-custom-binary-input-port&nbsp;<i>id</i>&nbsp;<i>r!</i>&nbsp;<i>gp</i>&nbsp;<i>sp!</i>&nbsp;<i>close</i>)</tt></span>
<br>
<b>returns: </b>a new custom binary input port
<br>
<span class=formdef><b>procedure</b>: <tt>(make-custom-binary-output-port&nbsp;<i>id</i>&nbsp;<i>w!</i>&nbsp;<i>gp</i>&nbsp;<i>sp!</i>&nbsp;<i>close</i>)</tt></span>
<br>
<b>returns: </b>a new custom binary output port
<br>
<span class=formdef><b>procedure</b>: <tt>(make-custom-binary-input/output-port&nbsp;<i>id</i>&nbsp;<i>r!</i>&nbsp;<i>w!</i>&nbsp;<i>gp</i>&nbsp;<i>sp!</i>&nbsp;<i>close</i>)</tt></span>
<br>
<b>returns: </b>a new custom binary input/output port
<br>
<b>libraries: </b><tt>(rnrs&nbsp;io&nbsp;ports)</tt>, <tt>(rnrs)</tt>

<p>These procedures allow programs to create ports from arbitrary byte streams.
<tt><i>id</i></tt> must be a string naming the new port; the name is used for informational
purposes only, and an implementation may choose to include it in the printed
syntax, if any, of a custom port.
<tt><i>r!</i></tt> and <tt><i>w!</i></tt> must be procedures, while <tt><i>gp</i></tt>, <tt><i>sp!</i></tt>, and
<tt><i>close</i></tt> must each be a procedure or <tt>#f</tt>.
These arguments are described below.

<p>
<dl compact>
<dt><tt><i>r!</i></tt><dd> is called to draw input from the custom port, e.g., to support
<tt>get-u8</tt> or <tt>get-bytevector-n</tt>.
It is called with three arguments: <tt><i>bytevector</i></tt>, <tt><i>start</i></tt>, and <tt><i>n</i></tt>.
<tt><i>start</i></tt> will be a nonnegative exact integer, <tt><i>n</i></tt> will be a
positive exact integer, and the sum of <tt><i>start</i></tt> and <tt><i>n</i></tt> will
not exceed the length of <tt><i>bytevector</i></tt>.
If the byte stream is at end of file, <tt><i>r!</i></tt> should return exact 0.
Otherwise, it should read at least one and at most <tt><i>n</i></tt> bytes from
the stream, store these bytes in consecutive locations of <tt><i>bytevector</i></tt>
starting at <tt><i>start</i></tt>, and return as an exact positive integer the
number of bytes actually read.

<p>
<dt><tt><i>w!</i></tt><dd> is called to send output to the port, e.g., to support
<tt>put-u8</tt> or <tt>put-bytevector</tt>.
It is called with three arguments: <tt><i>bytevector</i></tt>, <tt><i>start</i></tt>, and <tt><i>n</i></tt>.
<tt><i>start</i></tt> and <tt><i>n</i></tt> will be nonnegative exact integers, and the
sum of <tt><i>start</i></tt> and <tt><i>n</i></tt> will not exceed the length of
<tt><i>bytevector</i></tt>.
<tt><i>w!</i></tt> should write up to <tt><i>n</i></tt> consecutive bytes from
<tt><i>bytevector</i></tt> starting at <tt><i>start</i></tt> and return, as an exact nonnegative
integer, the number of bytes actually written.

<p>
<dt><tt><i>gp</i></tt><dd> is called to query the port's position.
If it is <tt>#f</tt>, the port will not support <tt>port-position</tt>.
If it is not <tt>#f</tt>, it will be passed zero arguments and should
return the current position as a displacement in bytes from the start
of the byte stream as an exact nonnegative integer.

<p>
<dt><tt><i>sp!</i></tt><dd> is called to set the port's position.
If it is <tt>#f</tt>, the port will not support <tt>set-port-position!</tt>.
If it is not <tt>#f</tt>, it will be passed one argument, an exact
nonnegative integer representing the new position as a displacement in
bytes from the start of the byte stream, and it should set the position
to this value.

<p>
<dt><tt><i>close</i></tt><dd> is called to close the byte stream.
If it is <tt>#f</tt>, no action will be taken to close the byte stream
when the new port is closed.
If it is not <tt>#f</tt>, it will be passed zero arguments and should
take whatever actions are necessary to close the byte stream.
</dl>

<p>
If the new port is an input/output port and does not provide either a
<tt><i>gp</i></tt> or <tt><i>sp!</i></tt> procedure, it may not be possible for the
implementation to position the port properly if an output operation occurs
after an input operation, due to input buffering that must be done to
support <tt>lookahead-u8</tt> and is often done anyway for efficiency.
For the same reason, a call to <tt>port-position</tt> after an input
operation may not return an accurate position if the <tt><i>sp!</i></tt> procedure is
not provided.
Thus, programs that create custom binary input/output ports should generally
provide both <tt><i>gp</i></tt> and <tt><i>sp!</i></tt> procedures.


<p>
<a name="./io:s42"></a><span class=formdef><b>procedure</b>: <tt>(make-custom-textual-input-port&nbsp;<i>id</i>&nbsp;<i>r!</i>&nbsp;<i>gp</i>&nbsp;<i>sp!</i>&nbsp;<i>close</i>)</tt></span>
<br>
<b>returns: </b>a new custom textual input port
<br>
<span class=formdef><b>procedure</b>: <tt>(make-custom-textual-output-port&nbsp;<i>id</i>&nbsp;<i>w!</i>&nbsp;<i>gp</i>&nbsp;<i>sp!</i>&nbsp;<i>close</i>)</tt></span>
<br>
<b>returns: </b>a new custom textual output port
<br>
<span class=formdef><b>procedure</b>: <tt>(make-custom-textual-input/output-port&nbsp;<i>id</i>&nbsp;<i>r!</i>&nbsp;<i>w!</i>&nbsp;<i>gp</i>&nbsp;<i>sp!</i>&nbsp;<i>close</i>)</tt></span>
<br>
<b>returns: </b>a new custom textual input/output port
<br>
<b>libraries: </b><tt>(rnrs&nbsp;io&nbsp;ports)</tt>, <tt>(rnrs)</tt>

<p>These procedures allow programs to create ports from arbitrary character streams.
<tt><i>id</i></tt> must be a string naming the new port; the name is used for informational
purposes only, and an implementation may choose to include it in the printed
syntax, if any, of a custom port.
<tt><i>r!</i></tt> and <tt><i>w!</i></tt> must be procedures, while <tt><i>gp</i></tt>, <tt><i>sp!</i></tt>, and
<tt><i>close</i></tt> must each be a procedure or <tt>#f</tt>.
These arguments are described below.

<p>
<dl compact>
<dt><tt><i>r!</i></tt><dd> is called to draw input from the port, e.g., to support
<tt>get-char</tt> or <tt>get-string-n</tt>.
It is called with three arguments: <tt><i>string</i></tt>, <tt><i>start</i></tt>, and <tt><i>n</i></tt>.
<tt><i>start</i></tt> will be a nonnegative exact integer, <tt><i>n</i></tt> will be a
positive exact integer, and the sum of <tt><i>start</i></tt> and <tt><i>n</i></tt> will
not exceed the length of <tt><i>string</i></tt>.
If the character stream is at end of file, <tt><i>r!</i></tt> should return exact 0.
Otherwise, it should read at least one and at most <tt><i>n</i></tt> characters from
the stream, store these characters in consecutive locations of <tt><i>string</i></tt>
starting at <tt><i>start</i></tt>, and return as an exact positive integer the
number of characters actually read.

<p>
<dt><tt><i>w!</i></tt><dd> is called to send output to the port, e.g., to support
<tt>put-char</tt> or <tt>put-string</tt>.
It is called with three arguments: <tt><i>string</i></tt>, <tt><i>start</i></tt>, and <tt><i>n</i></tt>.
<tt><i>start</i></tt> and <tt><i>n</i></tt> will be nonnegative exact integers, and the
sum of <tt><i>start</i></tt> and <tt><i>n</i></tt> will not exceed the length of
<tt><i>string</i></tt>.
<tt><i>w!</i></tt> should write up to <tt><i>n</i></tt> consecutive characters from
<tt><i>string</i></tt> starting at <tt><i>start</i></tt> and return, as an exact nonnegative
integer, the number of characters actually written.

<p>
<dt><tt><i>gp</i></tt><dd> is called to query the port's position.
If it is <tt>#f</tt>, the port will not support <tt>port-position</tt>.
If it is not <tt>#f</tt>, it will be passed zero arguments and should
return the current position, which may be an arbitrary value.

<p>
<dt><tt><i>sp!</i></tt><dd> is called to set the port's position.
If it is <tt>#f</tt>, the port will not support <tt>set-port-position!</tt>.
If it is not <tt>#f</tt>, it will be passed one argument, <tt><i>pos</i></tt>, a value
representing the new position.
If <tt><i>pos</i></tt> is the result of a previous call to <tt><i>gp</i></tt>, <tt><i>sp!</i></tt> should
set the position to <tt><i>pos</i></tt>.

<p>
<dt><tt><i>close</i></tt><dd> is called to close the character stream.
If it is <tt>#f</tt>, no action will be taken to close the character stream
when the new port is closed.
If it is not <tt>#f</tt>, it will be passed zero arguments and should
take whatever actions are necessary to close the character stream.
</dl>

<p>
If the new port is an input/output port, it may not be possible for the
implementation to position the port properly if an output operation occurs
after an input operation, even if the <tt><i>gp</i></tt> and <tt><i>sp!</i></tt> procedures
are provided, due to input buffering that must be done to support
<tt>lookahead-char</tt> and is often done anyway for efficiency.
Since the representations of port positions are not specified, it is
not possible for the implementation to adjust the <tt><i>gp</i></tt> return
value to account for the number of buffered characters.
For the same reason, a call to <tt>port-position</tt> after an input
operation may not return an accurate position, even if the <tt><i>sp!</i></tt>
procedure is provided.

<p>
It should, however, be possible to perform output reliably after reading
if the position is reset to the starting position.
Thus, programs that create custom textual input/output ports should generally
provide both <tt><i>gp</i></tt> and <tt><i>sp!</i></tt> procedures, and consumers of these ports
should obtain the starting position via <tt>port-position</tt> before any
input operations and reset the position back to the starting position
before doing any output operations.


<p>

<h3><a name="g127"></a><a name="./io:h6"></a>Section 7.6. Port Operations<a name="SECTPORTOPERATIONS"></a></h3>



<p>
This section describes a variety of operations on ports that do
not directly involve either reading from or writing to a port.
The input and output operations are described in subsequent
sections.

<p>
<a name="./io:s43"></a><span class=formdef><b>procedure</b>: <tt>(port?&nbsp;<i>obj</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if <tt><i>obj</i></tt> is a port, <tt>#f</tt> otherwise
<br>
<b>libraries: </b><tt>(rnrs&nbsp;io&nbsp;ports)</tt>, <tt>(rnrs)</tt>

<p><a name="./io:s44"></a><span class=formdef><b>procedure</b>: <tt>(input-port?&nbsp;<i>obj</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if <tt><i>obj</i></tt> is an input or input/output port, <tt>#f</tt> otherwise
<br>
<span class=formdef><b>procedure</b>: <tt>(output-port?&nbsp;<i>obj</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if <tt><i>obj</i></tt> is an output or input/output port, <tt>#f</tt> otherwise
<br>
<b>libraries: </b><tt>(rnrs&nbsp;io&nbsp;ports)</tt>, <tt>(rnrs&nbsp;io&nbsp;simple)</tt>, <tt>(rnrs)</tt>

<p><a name="./io:s45"></a><span class=formdef><b>procedure</b>: <tt>(binary-port?&nbsp;<i>obj</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if <tt><i>obj</i></tt> is a binary port, <tt>#f</tt> otherwise
<br>
<span class=formdef><b>procedure</b>: <tt>(textual-port?&nbsp;<i>obj</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if <tt><i>obj</i></tt> is a textual port, <tt>#f</tt> otherwise
<br>
<b>libraries: </b><tt>(rnrs&nbsp;io&nbsp;ports)</tt>, <tt>(rnrs)</tt>

<p><a name="./io:s46"></a><span class=formdef><b>procedure</b>: <tt>(close-port&nbsp;<i>port</i>)</tt></span>
<br>
<b>returns: </b>unspecified
<br>
<b>libraries: </b><tt>(rnrs&nbsp;io&nbsp;ports)</tt>, <tt>(rnrs)</tt>

<p>If <tt><i>port</i></tt> is not already closed, <tt>close-port</tt> closes it,
first flushing any buffered bytes or characters to the underlying stream
if the port is an output port.
Once a port has been closed, no more input or output operations may be
performed on the port.
Because the operating system may place limits on the number of file ports open
at one time or restrict access to an open file, it is good practice to
close any file port that will no longer be used for input or output.
If the port is an output port, closing the port explicitly also ensures
that buffered data is written to the underlying stream.
Some Scheme implementations close file ports automatically after they become
inaccessible to the program or when the Scheme program exits, but it is
best to close file ports explicitly whenever possible.
Closing a port that has already been closed has no effect.


<p>
<a name="./io:s47"></a><span class=formdef><b>procedure</b>: <tt>(transcoded-port&nbsp;<i>binary-port</i>&nbsp;<i>transcoder</i>)</tt></span>
<br>
<b>returns: </b>a new textual port with the same byte stream as <tt><i>binary-port</i></tt>
<br>
<b>libraries: </b><tt>(rnrs&nbsp;io&nbsp;ports)</tt>, <tt>(rnrs)</tt>

<p>This procedure returns a new textual port with transcoder <tt><i>transcoder</i></tt>
and the same underlying byte stream as <tt><i>binary-port</i></tt>, positioned at
the current position of <tt><i>binary-port</i></tt>.

<p>
As a side effect of creating the textual port, <tt><i>binary-port</i></tt> is closed
to prevent read or write operations on <tt><i>binary-port</i></tt> from interfering
with read and write operations on the new textual port.
The underlying byte stream remains open, however, until the textual port
is closed.


<p>
<a name="./io:s48"></a><span class=formdef><b>procedure</b>: <tt>(port-transcoder&nbsp;<i>port</i>)</tt></span>
<br>
<b>returns: </b>the transcoder associated with <tt><i>port</i></tt> if any, <tt>#f</tt> otherwise
<br>
<b>libraries: </b><tt>(rnrs&nbsp;io&nbsp;ports)</tt>, <tt>(rnrs)</tt>

<p>This procedure always returns <tt>#f</tt> for binary ports and may return
<tt>#f</tt> for some textual ports.


<p>
<a name="./io:s49"></a><span class=formdef><b>procedure</b>: <tt>(port-position&nbsp;<i>port</i>)</tt></span>
<br>
<b>returns: </b>the port's current position
<br>
<span class=formdef><b>procedure</b>: <tt>(port-has-port-position?&nbsp;<i>port</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if the port supports <tt>port-position</tt>, <tt>#f</tt> otherwise
<br>
<b>libraries: </b><tt>(rnrs&nbsp;io&nbsp;ports)</tt>, <tt>(rnrs)</tt>

<p>A port may allow queries to determine its current position in
the underlying stream of bytes or characters.
If so, the procedure <tt>port-has-port-position?</tt> returns
<tt>#t</tt> and <tt>port-position</tt> returns the current position.
For binary ports, the position is always an exact nonnegative integer byte
displacement from the start of the byte stream.
For textual ports, the representation of a position is unspecified; it
may not be an exact nonnegative integer and, even if it is, it may not
represent either a byte or character displacement in the underlying stream.
The position may be used at some later time to reset the position if the
port supports <tt>set-port-position!</tt>.
If <tt>port-position</tt> is called on a port that does not support it,
an exception with condition type <tt>&amp;assertion</tt> is raised.


<p>
<a name="./io:s50"></a><span class=formdef><b>procedure</b>: <tt>(set-port-position!&nbsp;<i>port</i>&nbsp;<i>pos</i>)</tt></span>
<br>
<b>returns: </b>unspecified
<br>
<span class=formdef><b>procedure</b>: <tt>(port-has-set-port-position!?&nbsp;<i>port</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if the port supports <tt>set-port-position!</tt>, <tt>#f</tt> otherwise
<br>
<b>libraries: </b><tt>(rnrs&nbsp;io&nbsp;ports)</tt>, <tt>(rnrs)</tt>

<p>A port may allow its current position to be moved directly to a different
position in the underlying stream of bytes or characters.
If so, the procedure <tt>port-has-set-port-position!?</tt> returns
<tt>#t</tt> and <tt>set-port-position!</tt> changes the current position.
For binary ports, the position <tt><i>pos</i></tt> must be an exact nonnegative integer byte
displacement from the start of the byte stream.
For textual ports, the representation of a position is unspecified, as
described in the entry for <tt>port-position</tt> above, but <tt><i>pos</i></tt> must be
an appropriate position for the textual port, which is usually guaranteed
to be the case only if it was obtained from a call to <tt>port-position</tt>
on the same port.
If <tt>set-port-position!</tt> is called on a port that does not support it,
an exception with condition type <tt>&amp;assertion</tt> is raised.

<p>
If <tt><i>port</i></tt> is a binary output port and the position is set
beyond the current end of the data in the underlying stream, the
stream is not extended until new data is written at that position.
If new data is written at that position, the contents of each
intervening position is unspecified.
Binary ports created with <tt>open-file-output-port</tt> and
<tt>open-file-input/output-port</tt> can always be extended in this manner
within the limits of the underlying operating system.
In other cases, attempts to set the port beyond the current end of data
in the underlying object may result in an exception with condition
type <tt>&amp;i/o-invalid-position</tt>.


<p>
<a name="./io:s51"></a><a name="desc:call-with-port"></a>
<span class=formdef><b>procedure</b>: <tt>(call-with-port&nbsp;<i>port</i>&nbsp;<i>procedure</i>)</tt></span>
<br>
<b>returns: </b>the values returned by <tt><i>procedure</i></tt>
<br>
<b>libraries: </b><tt>(rnrs&nbsp;io&nbsp;ports)</tt>, <tt>(rnrs)</tt>

<p><tt>call-with-port</tt> calls <tt><i>procedure</i></tt> with <tt><i>port</i></tt> as the only
argument.
If <tt><i>procedure</i></tt> returns, <tt>call-with-port</tt> closes the port and
returns the values returned by <tt><i>procedure</i></tt>.

<p>
<tt>call-with-port</tt> does not automatically close the
port if a continuation created outside of <tt><i>procedure</i></tt> is invoked, since it
is possible that another continuation created inside of <tt><i>procedure</i></tt> will be
invoked at a later time, returning control to <tt><i>procedure</i></tt>.
If <tt><i>procedure</i></tt> does not return, an implementation is free to close the
port only if it can prove that the output port is no longer accessible.

<p>
The example below copies the contents of infile to outfile, overwriting
outfile if it exists.
Unless an error occurs, the ports are closed after the copy has been
completed.

<p>

<p><tt>(call-with-port&nbsp;(open-file-input-port&nbsp;"infile"&nbsp;(file-options)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(buffer-mode&nbsp;block)&nbsp;(native-transcoder))<br>

&nbsp;&nbsp;(lambda&nbsp;(ip)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(call-with-port&nbsp;(open-file-output-port&nbsp;"outfile"<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(file-options&nbsp;no-fail)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(buffer-mode&nbsp;block)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(native-transcoder))&nbsp;<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(op)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(do&nbsp;([c&nbsp;(get-char&nbsp;ip)&nbsp;(get-char&nbsp;ip)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((eof-object?&nbsp;c))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(put-char&nbsp;op&nbsp;c))))))</tt>
<p>A definition of <tt>call-with-port</tt> is given on page&nbsp;<a href="./control.html#defn:call-with-port">135</a>.

<p>
<a name="./io:s52"></a><span class=formdef><b>procedure</b>: <tt>(output-port-buffer-mode&nbsp;<i>port</i>)</tt></span>
<br>
<b>returns: </b>the symbol representing the buffer mode of <tt><i>port</i></tt>
<br>
<b>libraries: </b><tt>(rnrs&nbsp;io&nbsp;ports)</tt>, <tt>(rnrs)</tt>

<p>
<h3><a name="g128"></a><a name="./io:h7"></a>Section 7.7. Input Operations<a name="SECTINPUT"></a></h3>



<p>
Procedures whose primary purpose is to read data from an input port
are described in this section, along with related procedures for recognizing
or creating end-of-file (eof) objects.


<p>
<a name="./io:s53"></a><span class=formdef><b>procedure</b>: <tt>(eof-object?&nbsp;<i>obj</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if <tt><i>obj</i></tt> is an eof object, <tt>#f</tt> otherwise
<br>
<b>libraries: </b><tt>(rnrs&nbsp;io&nbsp;ports)</tt>, <tt>(rnrs&nbsp;io&nbsp;simple)</tt>, <tt>(rnrs)</tt>

<p>The end-of-file object is returned by input operations, e.g., <tt>get-datum</tt>,
when an input port has reached the end of input.


<p>
<a name="./io:s54"></a><span class=formdef><b>procedure</b>: <tt>(eof-object)</tt></span>
<br>
<b>returns: </b>the eof object
<br>
<b>libraries: </b><tt>(rnrs&nbsp;io&nbsp;ports)</tt>, <tt>(rnrs&nbsp;io&nbsp;simple)</tt>, <tt>(rnrs)</tt>

<p>
<p><tt>(eof-object?&nbsp;(eof-object))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t</tt>
<p><a name="./io:s55"></a><span class=formdef><b>procedure</b>: <tt>(get-u8&nbsp;<i>binary-input-port</i>)</tt></span>
<br>
<b>returns: </b>the next byte from <tt><i>binary-input-port</i></tt>, or the eof object
<br>
<b>libraries: </b><tt>(rnrs&nbsp;io&nbsp;ports)</tt>, <tt>(rnrs)</tt>

<p>If <tt><i>binary-input-port</i></tt> is at end of file, the eof object is returned.
Otherwise, the next available byte is returned as an unsigned 8-bit
quantity, i.e., an exact unsigned integer less than or equal to 255,
and the port's position is advanced one byte.


<p>
<a name="./io:s56"></a><span class=formdef><b>procedure</b>: <tt>(lookahead-u8&nbsp;<i>binary-input-port</i>)</tt></span>
<br>
<b>returns: </b>the next byte from <tt><i>binary-input-port</i></tt>, or the eof object
<br>
<b>libraries: </b><tt>(rnrs&nbsp;io&nbsp;ports)</tt>, <tt>(rnrs)</tt>

<p>If <tt><i>binary-input-port</i></tt> is at end of file, the eof object is returned.
Otherwise, the next available byte is returned as an unsigned 8-bit
quantity, i.e., an exact unsigned integer less than or equal to 255.
In contrast to <tt>get-u8</tt>, <tt>lookahead-u8</tt> does not consume
the byte it reads from the port, so if the next operation on the port
is a call to <tt>lookahead-u8</tt> or <tt>get-u8</tt>, the same
byte is returned.


<p>
<a name="./io:s57"></a><span class=formdef><b>procedure</b>: <tt>(get-bytevector-n&nbsp;<i>binary-input-port</i>&nbsp;<i>n</i>)</tt></span>
<br>
<b>returns: </b>a nonempty bytevector containing up to <tt><i>n</i></tt> bytes, or the eof object
<br>
<b>libraries: </b><tt>(rnrs&nbsp;io&nbsp;ports)</tt>, <tt>(rnrs)</tt>

<p><tt><i>n</i></tt> must be an exact nonnegative integer.
If <tt><i>binary-input-port</i></tt> is at end of file, the eof object is returned.
Otherwise, <tt>get-bytevector-n</tt> reads (as if with <tt>get-u8</tt>)
as many bytes, up to <tt><i>n</i></tt>, as are available before the port is at end
of file, and returns a new (nonempty) bytevector containing these bytes.
The port's position is advanced past the bytes read.


<p>
<a name="./io:s58"></a><span class=formdef><b>procedure</b>: <tt>(get-bytevector-n!&nbsp;<i>binary-input-port</i>&nbsp;<i>bytevector</i>&nbsp;<i>start</i>&nbsp;<i>n</i>)</tt></span>
<br>
<b>returns: </b>the count of bytes read or the eof object
<br>
<b>libraries: </b><tt>(rnrs&nbsp;io&nbsp;ports)</tt>, <tt>(rnrs)</tt>

<p><tt><i>start</i></tt> and <tt><i>n</i></tt> must be exact nonnegative integers, and the sum of
<tt><i>start</i></tt> and <tt><i>n</i></tt> must not exceed the length of <tt><i>bytevector</i></tt>.

<p>
If <tt><i>binary-input-port</i></tt> is at end of file, the eof object is returned.
Otherwise, <tt>get-bytevector-n!</tt> reads (as if with <tt>get-u8</tt>)
as many bytes, up to <tt><i>n</i></tt>, as are available before the port is at end
of file, stores the bytes in consecutive locations of <tt><i>bytevector</i></tt>
starting at <tt><i>start</i></tt>, and returns the count of bytes read as an exact
positive integer.
The port's position is advanced past the bytes read.


<p>
<a name="./io:s59"></a><span class=formdef><b>procedure</b>: <tt>(get-bytevector-some&nbsp;<i>binary-input-port</i>)</tt></span>
<br>
<b>returns: </b>a nonempty bytevector or the eof object
<br>
<b>libraries: </b><tt>(rnrs&nbsp;io&nbsp;ports)</tt>, <tt>(rnrs)</tt>

<p>If <tt><i>binary-input-port</i></tt> is at end of file, the eof object is returned.
Otherwise, <tt>get-bytevector-some</tt> reads (as if with <tt>get-u8</tt>)
at least one byte and possibly more, and returns a bytevector containing
these bytes.
The port's position is advanced past the bytes read.
The maximum number of bytes read by this operation is implementation-dependent.


<p>
<a name="./io:s60"></a><span class=formdef><b>procedure</b>: <tt>(get-bytevector-all&nbsp;<i>binary-input-port</i>)</tt></span>
<br>
<b>returns: </b>a nonempty bytevector or the eof object
<br>
<b>libraries: </b><tt>(rnrs&nbsp;io&nbsp;ports)</tt>, <tt>(rnrs)</tt>

<p>If <tt><i>binary-input-port</i></tt> is at end of file, the eof object is returned.
Otherwise, <tt>get-bytevector-all</tt> reads (as if with <tt>get-u8</tt>)
all of the bytes available before the port is at end of file and
returns a bytevector containing these bytes.
The port's position is advanced past the bytes read.


<p>
<a name="./io:s61"></a><span class=formdef><b>procedure</b>: <tt>(get-char&nbsp;<i>textual-input-port</i>)</tt></span>
<br>
<b>returns: </b>the next character from <tt><i>textual-input-port</i></tt>, or the eof object
<br>
<b>libraries: </b><tt>(rnrs&nbsp;io&nbsp;ports)</tt>, <tt>(rnrs)</tt>

<p>If <tt><i>textual-input-port</i></tt> is at end of file, the eof object is returned.
Otherwise, the next available character is returned
and the port's position is advanced one character.
If <tt><i>textual-input-port</i></tt> is a transcoded port, the position in the
underlying byte stream may advance by more than one byte.


<p>
<a name="./io:s62"></a><span class=formdef><b>procedure</b>: <tt>(lookahead-char&nbsp;<i>textual-input-port</i>)</tt></span>
<br>
<b>returns: </b>the next character from <tt><i>textual-input-port</i></tt>, or the eof object
<br>
<b>libraries: </b><tt>(rnrs&nbsp;io&nbsp;ports)</tt>, <tt>(rnrs)</tt>

<p>If <tt><i>textual-input-port</i></tt> is at end of file, the eof object is returned.
Otherwise, the next available character is returned.
In contrast to <tt>get-char</tt>, <tt>lookahead-char</tt> does not consume
the character it reads from the port, so if the next operation on the port
is a call to <tt>lookahead-char</tt> or <tt>get-char</tt>, the same
character is returned.

<p>
<tt>lookahead-char</tt> is provided for applications requiring one
character of lookahead.
The procedure <tt>get-word</tt> defined below
returns the next word from a textual input port as a string, where
a word is defined to be a sequence of alphabetic characters.
Since <tt>get-word</tt> does not know until it sees one character
beyond the word that it has read the entire word, it uses
<tt>lookahead-char</tt> to determine the next character and
<tt>get-char</tt> to consume the character.

<p>

<p><tt>(define&nbsp;get-word<br>

&nbsp;&nbsp;(lambda&nbsp;(p)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(list-&gt;string<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;f&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([c&nbsp;(lookahead-char&nbsp;p)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cond<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(eof-object?&nbsp;c)&nbsp;'()]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(char-alphabetic?&nbsp;c)&nbsp;(get-char&nbsp;p)&nbsp;(cons&nbsp;c&nbsp;(f))]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[else&nbsp;'()]))))))</tt>
<p><a name="./io:s63"></a><span class=formdef><b>procedure</b>: <tt>(get-string-n&nbsp;<i>textual-input-port</i>&nbsp;<i>n</i>)</tt></span>
<br>
<b>returns: </b>a nonempty string containing up to <tt><i>n</i></tt> characters, or the eof object
<br>
<b>libraries: </b><tt>(rnrs&nbsp;io&nbsp;ports)</tt>, <tt>(rnrs)</tt>

<p><tt><i>n</i></tt> must be an exact nonnegative integer.
If <tt><i>textual-input-port</i></tt> is at end of file, the eof object is returned.
Otherwise, <tt>get-string-n</tt> reads (as if with <tt>get-char</tt>)
as many characters, up to <tt><i>n</i></tt>, as are available before the port is at end
of file, and returns a new (nonempty) string containing these characters.
The port's position is advanced past the characters read.


<p>
<a name="./io:s64"></a><span class=formdef><b>procedure</b>: <tt>(get-string-n!&nbsp;<i>textual-input-port</i>&nbsp;<i>string</i>&nbsp;<i>start</i>&nbsp;<i>n</i>)</tt></span>
<br>
<b>returns: </b>the count of characters read or the eof object
<br>
<b>libraries: </b><tt>(rnrs&nbsp;io&nbsp;ports)</tt>, <tt>(rnrs)</tt>

<p><tt><i>start</i></tt> and <tt><i>n</i></tt> must be exact nonnegative integers, and the sum of
<tt><i>start</i></tt> and <tt><i>n</i></tt> must not exceed the length of <tt><i>string</i></tt>.

<p>
If <tt><i>textual-input-port</i></tt> is at end of file, the eof object is returned.
Otherwise, <tt>get-string-n!</tt> reads (as if with <tt>get-char</tt>)
as many characters, up to <tt><i>n</i></tt>, as are available before the port is at end
of file, stores the characters in consecutive locations of <tt><i>string</i></tt>
starting at <tt><i>start</i></tt>, and returns the count of characters read as an exact
positive integer.
The port's position is advanced past the characters read.

<p>
<tt>get-string-n!</tt> may be used to implement <tt>string-set!</tt> and
<tt>string-fill!</tt>, as illustrated below, although this is not its
primary purpose.

<p>

<p><tt>(define&nbsp;string-set!<a name="backdoor-string-fill"></a><br>

&nbsp;&nbsp;(lambda&nbsp;(s&nbsp;i&nbsp;c)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([sip&nbsp;(open-string-input-port&nbsp;(string&nbsp;c))])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(get-string-n!&nbsp;sip&nbsp;s&nbsp;i&nbsp;1)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;return&nbsp;unspecified&nbsp;values:<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;#f&nbsp;#f))))
<br>
<br>
(define&nbsp;string-fill!<br>

&nbsp;&nbsp;(lambda&nbsp;(s&nbsp;c)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([n&nbsp;(string-length&nbsp;s)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([sip&nbsp;(open-string-input-port&nbsp;(make-string&nbsp;n&nbsp;c))])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(get-string-n!&nbsp;sip&nbsp;s&nbsp;0&nbsp;n)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;return&nbsp;unspecified&nbsp;values:<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;#f&nbsp;#f)))))
<br>
<br>
(let&nbsp;([x&nbsp;(make-string&nbsp;3)])<br>

&nbsp;&nbsp;(string-fill!&nbsp;x&nbsp;#\-)<br>

&nbsp;&nbsp;(string-set!&nbsp;x&nbsp;2&nbsp;#\))<br>

&nbsp;&nbsp;(string-set!&nbsp;x&nbsp;0&nbsp;#\;)<br>

&nbsp;&nbsp;x)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;";-)"</tt>
<p><a name="./io:s65"></a><span class=formdef><b>procedure</b>: <tt>(get-string-all&nbsp;<i>textual-input-port</i>)</tt></span>
<br>
<b>returns: </b>a nonempty string or the eof object
<br>
<b>libraries: </b><tt>(rnrs&nbsp;io&nbsp;ports)</tt>, <tt>(rnrs)</tt>

<p>If <tt><i>textual-input-port</i></tt> is at end of file, the eof object is returned.
Otherwise, <tt>get-string-all</tt> reads (as if with <tt>get-char</tt>)
all of the characters available before the port is at end of file and
returns a string containing these characters.
The port's position is advanced past the characters read.



<p>
<a name="./io:s66"></a><span class=formdef><b>procedure</b>: <tt>(get-line&nbsp;<i>textual-input-port</i>)</tt></span>
<br>
<b>returns: </b>a string or the eof object
<br>
<b>libraries: </b><tt>(rnrs&nbsp;io&nbsp;ports)</tt>, <tt>(rnrs)</tt>

<p>If <tt><i>textual-input-port</i></tt> is at end of file, the eof object is returned.
Otherwise, <tt>get-line</tt> reads (as if with <tt>get-char</tt>)
all of the characters available before the port is at end of file or a
line-feed character has been read and returns a string containing all but
the line-feed character of the characters read.
The port's position is advanced past the characters read.

<p>

<p><tt>(let&nbsp;([sip&nbsp;(open-string-input-port&nbsp;"one\ntwo\n")])<br>

&nbsp;&nbsp;(let*&nbsp;([s1&nbsp;(get-line&nbsp;sip)]&nbsp;[s2&nbsp;(get-line&nbsp;sip)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;(list&nbsp;s1&nbsp;s2&nbsp;(port-eof?&nbsp;sip))))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;("one"&nbsp;"two"&nbsp;#t)
<br>
<br>
(let&nbsp;([sip&nbsp;(open-string-input-port&nbsp;"one\ntwo")])<br>

&nbsp;&nbsp;(let*&nbsp;([s1&nbsp;(get-line&nbsp;sip)]&nbsp;[s2&nbsp;(get-line&nbsp;sip)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;(list&nbsp;s1&nbsp;s2&nbsp;(port-eof?&nbsp;sip))))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;("one"&nbsp;"two"&nbsp;#t)</tt>
<p><a name="./io:s67"></a><span class=formdef><b>procedure</b>: <tt>(get-datum&nbsp;<i>textual-input-port</i>)</tt></span>
<br>
<b>returns: </b>a Scheme datum object or the eof object
<br>
<b>libraries: </b><tt>(rnrs&nbsp;io&nbsp;ports)</tt>, <tt>(rnrs)</tt>

<p>This procedure scans past whitespace and comments to find the start of
the external representation of a datum.
If <tt><i>textual-input-port</i></tt> reaches end of file before the start of the
external representation of a datum is found, the eof object is returned.

<p>
Otherwise, <tt>get-datum</tt> reads as many characters as necessary,
and no more, to parse a single datum, and returns a newly allocated
object whose structure is determined by the external representation.
The port's position is advanced past the characters read.
If an end-of-file is reached before the external representation of
the datum is complete, or an unexpected character is read,
an exception is raised with condition types <tt>&amp;lexical</tt> and
<tt>i/o-read</tt>.

<p>

<p><tt>(let&nbsp;([sip&nbsp;(open-string-input-port&nbsp;";&nbsp;a\n\n&nbsp;one&nbsp;(two)\n")])<br>

&nbsp;&nbsp;(let*&nbsp;([x1&nbsp;(get-datum&nbsp;sip)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[c1&nbsp;(lookahead-char&nbsp;sip)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[x2&nbsp;(get-datum&nbsp;sip)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;(list&nbsp;x1&nbsp;c1&nbsp;x2&nbsp;(port-eof?&nbsp;sip))))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(one&nbsp;#\space&nbsp;(two)&nbsp;#f)</tt>
<p><a name="./io:s68"></a><span class=formdef><b>procedure</b>: <tt>(port-eof?&nbsp;<i>input-port</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if <tt><i>input-port</i></tt> is at end-of-file, <tt>#f</tt> otherwise
<br>
<b>libraries: </b><tt>(rnrs&nbsp;io&nbsp;ports)</tt>, <tt>(rnrs)</tt>

<p>This procedure is similar to <tt>lookahead-u8</tt> on a binary input port
or <tt>lookahead-char</tt> on a textual input port, except that instead
of returning the next byte/character or eof object, it returns a boolean
value to indicate whether the value would be the eof object.


<p>

<h3><a name="g129"></a><a name="./io:h8"></a>Section 7.8. Output Operations<a name="SECTOUTPUT"></a></h3>



<p>
Procedures whose primary purpose is to send data to an output port
are described in this section.

<p>
<a name="./io:s69"></a><span class=formdef><b>procedure</b>: <tt>(put-u8&nbsp;<i>binary-output-port</i>&nbsp;<i>octet</i>)</tt></span>
<br>
<b>returns: </b>unspecified
<br>
<b>libraries: </b><tt>(rnrs&nbsp;io&nbsp;ports)</tt>, <tt>(rnrs)</tt>

<p><tt><i>octet</i></tt> must be an exact nonnegative integer less than or equal to 255.
This procedure writes <tt><i>octet</i></tt> to <tt><i>binary-output-port</i></tt>, advancing
the port's position by one byte.


<p>
<a name="./io:s70"></a><span class=formdef><b>procedure</b>: <tt>(put-bytevector&nbsp;<i>binary-output-port</i>&nbsp;<i>bytevector</i>)</tt></span>
<br>
<span class=formdef><b>procedure</b>: <tt>(put-bytevector&nbsp;<i>binary-output-port</i>&nbsp;<i>bytevector</i>&nbsp;<i>start</i>)</tt></span>
<br>
<span class=formdef><b>procedure</b>: <tt>(put-bytevector&nbsp;<i>binary-output-port</i>&nbsp;<i>bytevector</i>&nbsp;<i>start</i>&nbsp;<i>n</i>)</tt></span>
<br>
<b>returns: </b>unspecified
<br>
<b>libraries: </b><tt>(rnrs&nbsp;io&nbsp;ports)</tt>, <tt>(rnrs)</tt>

<p><tt><i>start</i></tt> and <tt><i>n</i></tt> must be nonnegative exact integers, and the sum of
<tt><i>start</i></tt> and <tt><i>n</i></tt> must not exceed the length of <tt><i>bytevector</i></tt>.
If not supplied, <tt><i>start</i></tt> defaults to zero and <tt><i>n</i></tt> defaults to
the difference between the length of <tt><i>bytevector</i></tt> and <tt><i>start</i></tt>.

<p>
This procedure writes the <tt><i>n</i></tt> bytes of <tt><i>bytevector</i></tt> starting at
<tt><i>start</i></tt> to the port and advances the its position
past the end of the bytes written.


<p>
<a name="./io:s71"></a><span class=formdef><b>procedure</b>: <tt>(put-char&nbsp;<i>textual-output-port</i>&nbsp;<i>char</i>)</tt></span>
<br>
<b>returns: </b>unspecified
<br>
<b>libraries: </b><tt>(rnrs&nbsp;io&nbsp;ports)</tt>, <tt>(rnrs)</tt>

<p>This procedure writes <tt><i>char</i></tt> to <tt><i>textual-output-port</i></tt>, advancing
the port's position by one character.
If <tt><i>textual-output-port</i></tt> is a transcoded port, the position in the
underlying byte stream may advance by more than one byte.


<p>
<a name="./io:s72"></a><span class=formdef><b>procedure</b>: <tt>(put-string&nbsp;<i>textual-output-port</i>&nbsp;<i>string</i>)</tt></span>
<br>
<span class=formdef><b>procedure</b>: <tt>(put-string&nbsp;<i>textual-output-port</i>&nbsp;<i>string</i>&nbsp;<i>start</i>)</tt></span>
<br>
<span class=formdef><b>procedure</b>: <tt>(put-string&nbsp;<i>textual-output-port</i>&nbsp;<i>string</i>&nbsp;<i>start</i>&nbsp;<i>n</i>)</tt></span>
<br>
<b>returns: </b>unspecified
<br>
<b>libraries: </b><tt>(rnrs&nbsp;io&nbsp;ports)</tt>, <tt>(rnrs)</tt>

<p><tt><i>start</i></tt> and <tt><i>n</i></tt> must be nonnegative exact integers, and the sum of
<tt><i>start</i></tt> and <tt><i>n</i></tt> must not exceed the length of <tt><i>string</i></tt>.
If not supplied, <tt><i>start</i></tt> defaults to zero and <tt><i>n</i></tt> defaults to
the difference between the length of <tt><i>string</i></tt> and <tt><i>start</i></tt>.

<p>
This procedure writes the <tt><i>n</i></tt> characters of <tt><i>string</i></tt> starting at
<tt><i>start</i></tt> to the port and advances the its position
past the end of the characters written.


<p>
<a name="./io:s73"></a><span class=formdef><b>procedure</b>: <tt>(put-datum&nbsp;<i>textual-output-port</i>&nbsp;<i>obj</i>)</tt></span>
<br>
<b>returns: </b>unspecified
<br>
<b>libraries: </b><tt>(rnrs&nbsp;io&nbsp;ports)</tt>, <tt>(rnrs)</tt>

<p>This procedure writes an external representation of <tt><i>obj</i></tt> to
<tt><i>textual-output-port</i></tt>.
If <tt><i>obj</i></tt> does not have an external representation as a datum,
the behavior is unspecified.
The precise external representation is implementation-dependent,
but when <tt><i>obj</i></tt> does have an external representation as a datum,
<tt>put-datum</tt> should produce a sequence of characters that
can later be read by <tt>get-datum</tt> as an object equivalent
(in the sense of <tt>equal?</tt>) to <tt><i>obj</i></tt>.
See Section&nbsp;<a href="./examples.html#g176">12.5</a> for an implementation of <tt>put-datum</tt>,
<tt>write</tt>, and <tt>display</tt>.


<p>
<a name="./io:s74"></a><span class=formdef><b>procedure</b>: <tt>(flush-output-port&nbsp;<i>output-port</i>)</tt></span>
<br>
<b>returns: </b>unspecified
<br>
<b>libraries: </b><tt>(rnrs&nbsp;io&nbsp;ports)</tt>, <tt>(rnrs)</tt>

<p>This procedure forces any bytes or characters in the buffer associated
with <tt><i>output-port</i></tt> to be sent immediately to the underlying stream.


<p>

<h3><a name="g130"></a><a name="./io:h9"></a>Section 7.9. Convenience I/O<a name="SECTCONVENIENCE"></a></h3>



<p>
The procedures in this section are referred to as "convenience"
I/O operators because they present a somewhat simplified interface for
creating and interacting with textual ports.
They also provide backward compatibility with the Revised<sup>5</sup> Report,
which did not support separate binary and textual I/O.

<p>
The convenience input/output procedures may be called with
or without an explicit port argument.
If called without an explicit port argument, the current input or output
port is used, as appropriate.
For example, <tt>(read-char)</tt> and <tt>(read-char&nbsp;(current-input-port))</tt>
both return the next character from the current input port.


<p>
<a name="./io:s75"></a><span class=formdef><b>procedure</b>: <tt>(open-input-file&nbsp;<i>path</i>)</tt></span>
<br>
<b>returns: </b>a new input port
<br>
<b>libraries: </b><tt>(rnrs&nbsp;io&nbsp;simple)</tt>, <tt>(rnrs)</tt>

<p><tt><i>path</i></tt> must be a string or some other implementation-dependent 
value that names a file.
<tt>open-input-file</tt> creates a new textual input port for the file named by
<tt><i>path</i></tt>, as if by <tt>open-file-input-port</tt>
with default options, an implementation-dependent buffer
mode, and an implementation-dependent transcoder.

<p>
The following shows the use of <tt>open-input-file</tt>, <tt>read</tt>, and
<tt>close-port</tt> in an expression that gathers a list of
objects from the file named by "myfile.ss."

<p>

<p><tt>(let&nbsp;([p&nbsp;(open-input-file&nbsp;"myfile.ss")])<br>

&nbsp;&nbsp;(let&nbsp;f&nbsp;([x&nbsp;(read&nbsp;p)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(eof-object?&nbsp;x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(begin<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(close-port&nbsp;p)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'())<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cons&nbsp;x&nbsp;(f&nbsp;(read&nbsp;p))))))</tt>
<p><a name="./io:s76"></a><span class=formdef><b>procedure</b>: <tt>(open-output-file&nbsp;<i>path</i>)</tt></span>
<br>
<b>returns: </b>a new output port
<br>
<b>libraries: </b><tt>(rnrs&nbsp;io&nbsp;simple)</tt>, <tt>(rnrs)</tt>

<p><tt><i>path</i></tt> must be a string or some other implementation-dependent 
value that names a file.
<tt>open-output-file</tt> creates a new output port for the file named by
<tt><i>path</i></tt>, as if by <tt>open-file-output-port</tt> with default options,
an implementation-dependent buffer mode, and an implementation-dependent
transcoder.

<p>
The following shows the use of <tt>open-output-file</tt> 
to write a list of objects (the value of
<tt>list-to-be-printed</tt>), separated by newlines, to the file
named by "myfile.ss."

<p>

<p><tt>(let&nbsp;([p&nbsp;(open-output-file&nbsp;"myfile.ss")])<br>

&nbsp;&nbsp;(let&nbsp;f&nbsp;([ls&nbsp;list-to-be-printed])<br>

&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(not&nbsp;(null?&nbsp;ls))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(begin<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(write&nbsp;(car&nbsp;ls)&nbsp;p)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(newline&nbsp;p)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(f&nbsp;(cdr&nbsp;ls)))))<br>

&nbsp;&nbsp;(close-port&nbsp;p))</tt>
<p><a name="./io:s77"></a><span class=formdef><b>procedure</b>: <tt>(call-with-input-file&nbsp;<i>path</i>&nbsp;<i>procedure</i>)</tt></span>
<br>
<b>returns: </b>the values returned by <tt><i>procedure</i></tt>
<br>
<b>libraries: </b><tt>(rnrs&nbsp;io&nbsp;simple)</tt>, <tt>(rnrs)</tt>

<p><tt><i>path</i></tt> must be a string or some other implementation-dependent 
value that names a file.
<tt><i>procedure</i></tt> should accept one argument.

<p>
<tt>call-with-input-file</tt> creates a new input port for the file named
by <tt><i>path</i></tt>, as if with <tt>open-input-file</tt>, and passes this port to <tt><i>procedure</i></tt>.
If <tt><i>procedure</i></tt> returns, <tt>call-with-input-file</tt> closes the input port
and returns the values returned by <tt><i>procedure</i></tt>.

<p>
<tt>call-with-input-file</tt> does not automatically close the input
port if a continuation created outside of <tt><i>procedure</i></tt> is invoked, since it
is possible that another continuation created inside of <tt><i>procedure</i></tt> will be
invoked at a later time, returning control to <tt><i>procedure</i></tt>.
If <tt><i>procedure</i></tt> does not return, an implementation is free to close the
input port only if it can prove that the input port is no longer accessible.
As shown in Section&nbsp;<a href="./control.html#g102">5.6</a>, <tt>dynamic-wind</tt> may be used to
ensure that the port is closed if a continuation created outside of
<tt><i>procedure</i></tt> is invoked.

<p>
The following example shows the use of <tt>call-with-input-file</tt>
in an expression that gathers
a list of objects from the file named by "myfile.ss."
It is functionally equivalent to the example given for
<tt>open-input-file</tt> above.

<p>

<p><tt>(call-with-input-file&nbsp;"myfile.ss"<br>

&nbsp;&nbsp;(lambda&nbsp;(p)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;f&nbsp;([x&nbsp;(read&nbsp;p)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(eof-object?&nbsp;x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'()<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cons&nbsp;x&nbsp;(f&nbsp;(read&nbsp;p)))))))</tt>
<p><tt>call-with-input-file</tt> might be defined without error checking as follows.

<p>

<p><tt>(define&nbsp;call-with-input-file<br>

&nbsp;&nbsp;(lambda&nbsp;(filename&nbsp;proc)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([p&nbsp;(open-input-file&nbsp;filename)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let-values&nbsp;([v*&nbsp;(proc&nbsp;p)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(close-port&nbsp;p)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(apply&nbsp;values&nbsp;v*)))))</tt>
<p><a name="./io:s78"></a><span class=formdef><b>procedure</b>: <tt>(call-with-output-file&nbsp;<i>path</i>&nbsp;<i>procedure</i>)</tt></span>
<br>
<b>returns: </b>the values returned by <tt><i>procedure</i></tt>
<br>
<b>libraries: </b><tt>(rnrs&nbsp;io&nbsp;simple)</tt>, <tt>(rnrs)</tt>

<p><tt><i>path</i></tt> must be a string or some other implementation-dependent 
value that names a file.
<tt><i>procedure</i></tt> should accept one argument.

<p>
<tt>call-with-output-file</tt> creates a new output port for the file named
by <tt><i>path</i></tt>, as if with <tt>open-output-file</tt>, and passes this port to <tt><i>procedure</i></tt>.
If <tt><i>procedure</i></tt> returns, <tt>call-with-output-file</tt> closes the output port
and returns the values returned by <tt><i>procedure</i></tt>.

<p>
<tt>call-with-output-file</tt> does not automatically close the output
port if a continuation created outside of <tt><i>procedure</i></tt> is invoked, since it
is possible that another continuation created inside of <tt><i>procedure</i></tt> will be
invoked at a later time, returning control to <tt><i>procedure</i></tt>.
If <tt><i>procedure</i></tt> does not return, an implementation is free to close the
output port only if it can prove that the output port is no longer accessible.
As shown in Section&nbsp;<a href="./control.html#g102">5.6</a>, <tt>dynamic-wind</tt> may be used to
ensure that the port is closed if a continuation created outside of
<tt><i>procedure</i></tt> is invoked.

<p>
The following shows the use of <tt>call-with-output-file</tt> to
write a list of objects (the value of  <tt>list-to-be-printed</tt>),
separated by newlines, to the file named by "myfile.ss."
It is functionally equivalent to the example given for
<tt>open-output-file</tt> above.

<p>

<p><tt>(call-with-output-file&nbsp;"myfile.ss"<br>

&nbsp;&nbsp;(lambda&nbsp;(p)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;f&nbsp;([ls&nbsp;list-to-be-printed])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(unless&nbsp;(null?&nbsp;ls)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(write&nbsp;(car&nbsp;ls)&nbsp;p)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(newline&nbsp;p)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(f&nbsp;(cdr&nbsp;ls))))))</tt>
<p><tt>call-with-output-file</tt> might be defined without error checking as follows.

<p>

<p><tt>(define&nbsp;call-with-output-file<br>

&nbsp;&nbsp;(lambda&nbsp;(filename&nbsp;proc)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([p&nbsp;(open-output-file&nbsp;filename)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let-values&nbsp;([v*&nbsp;(proc&nbsp;p)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(close-port&nbsp;p)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(apply&nbsp;values&nbsp;v*)))))</tt>
<p><a name="./io:s79"></a><span class=formdef><b>procedure</b>: <tt>(with-input-from-file&nbsp;<i>path</i>&nbsp;<i>thunk</i>)</tt></span>
<br>
<b>returns: </b>the values returned by <tt><i>thunk</i></tt>
<br>
<b>libraries: </b><tt>(rnrs&nbsp;io&nbsp;simple)</tt>, <tt>(rnrs)</tt>

<p><tt><i>path</i></tt> must be a string or some other implementation-dependent 
value that names a file.
<tt><i>thunk</i></tt> must be a procedure and should accept zero arguments.

<p>
<tt>with-input-from-file</tt> temporarily changes the current input port to be the
result of opening the file named by <tt><i>path</i></tt>, as if with <tt>open-input-file</tt>, during the
application of <tt><i>thunk</i></tt>.
If <tt><i>thunk</i></tt> returns, the port is closed and the current input port
is restored to its old value.

<p>
The behavior of <tt>with-input-from-file</tt> is unspecified
if a continuation created outside
of <tt><i>thunk</i></tt> is invoked before <tt><i>thunk</i></tt> returns.
An implementation may close the port and restore the current input
port to its old value---but it may not.


<p>
<a name="./io:s80"></a><span class=formdef><b>procedure</b>: <tt>(with-output-to-file&nbsp;<i>path</i>&nbsp;<i>thunk</i>)</tt></span>
<br>
<b>returns: </b>the values returned by <tt><i>thunk</i></tt>
<br>
<b>libraries: </b><tt>(rnrs&nbsp;io&nbsp;simple)</tt>, <tt>(rnrs)</tt>

<p><tt><i>path</i></tt> must be a string or some other implementation-dependent 
value that names a file.
<tt><i>thunk</i></tt> must be a procedure and should accept zero arguments.

<p>
<tt>with-output-to-file</tt> temporarily rebinds the current output port to be the
result of opening the file named by <tt><i>path</i></tt>, as if with <tt>open-output-file</tt>,
during the application of <tt><i>thunk</i></tt>.
If <tt><i>thunk</i></tt> returns, the port is closed and the current output port
is restored to its old value.

<p>
The behavior of <tt>with-output-to-file</tt> is unspecified if a
continuation created outside of <tt><i>thunk</i></tt> is invoked before
<tt><i>thunk</i></tt> returns.
An implementation may close the port and restore the current output
port to its old value---but it may not.


<p>
<a name="./io:s81"></a><span class=formdef><b>procedure</b>: <tt>(read)</tt></span>
<br>
<span class=formdef><b>procedure</b>: <tt>(read&nbsp;<i>textual-input-port</i>)</tt></span>
<br>
<b>returns: </b>a Scheme datum object or the eof object
<br>
<b>libraries: </b><tt>(rnrs&nbsp;io&nbsp;simple)</tt>, <tt>(rnrs)</tt>

<p>If <tt><i>textual-input-port</i></tt> is not supplied, it defaults to the current input port.
This procedure is otherwise equivalent to <tt>get-datum</tt>.


<p>
<a name="./io:s82"></a><span class=formdef><b>procedure</b>: <tt>(read-char)</tt></span>
<br>
<span class=formdef><b>procedure</b>: <tt>(read-char&nbsp;<i>textual-input-port</i>)</tt></span>
<br>
<b>returns: </b>the next character from <tt><i>textual-input-port</i></tt>
<br>
<b>libraries: </b><tt>(rnrs&nbsp;io&nbsp;simple)</tt>, <tt>(rnrs)</tt>

<p>If <tt><i>textual-input-port</i></tt> is not supplied, it defaults to the current input port.
This procedure is otherwise equivalent to <tt>get-char</tt>.


<p>
<a name="./io:s83"></a><span class=formdef><b>procedure</b>: <tt>(peek-char)</tt></span>
<br>
<span class=formdef><b>procedure</b>: <tt>(peek-char&nbsp;<i>textual-input-port</i>)</tt></span>
<br>
<b>returns: </b>the next character from <tt><i>textual-input-port</i></tt>
<br>
<b>libraries: </b><tt>(rnrs&nbsp;io&nbsp;simple)</tt>, <tt>(rnrs)</tt>

<p>If <tt><i>textual-input-port</i></tt> is not supplied, it defaults to the current input port.
This procedure is otherwise equivalent to <tt>lookahead-char</tt>.


<p>
<a name="./io:s84"></a><span class=formdef><b>procedure</b>: <tt>(write&nbsp;<i>obj</i>)</tt></span>
<br>
<span class=formdef><b>procedure</b>: <tt>(write&nbsp;<i>obj</i>&nbsp;<i>textual-output-port</i>)</tt></span>
<br>
<b>returns: </b>unspecified
<br>
<b>libraries: </b><tt>(rnrs&nbsp;io&nbsp;simple)</tt>, <tt>(rnrs)</tt>

<p>If <tt><i>textual-output-port</i></tt> is not supplied, it defaults to the current output port.
This procedure is otherwise equivalent to <tt>put-datum</tt>, with the
arguments reversed.
See Section&nbsp;<a href="./examples.html#g176">12.5</a> for an implementation of <tt>put-datum</tt>,
<tt>write</tt>, and <tt>display</tt>.

<p>
<a name="./io:s85"></a><span class=formdef><b>procedure</b>: <tt>(display&nbsp;<i>obj</i>)</tt></span>
<br>
<span class=formdef><b>procedure</b>: <tt>(display&nbsp;<i>obj</i>&nbsp;<i>textual-output-port</i>)</tt></span>
<br>
<b>returns: </b>unspecified
<br>
<b>libraries: </b><tt>(rnrs&nbsp;io&nbsp;simple)</tt>, <tt>(rnrs)</tt>

<p>If <tt><i>textual-output-port</i></tt> is not supplied, it defaults to the current output port.

<p>
<tt>display</tt> is similar to <tt>write</tt> or <tt>put-datum</tt> but prints strings
and characters found within <tt><i>obj</i></tt> directly.
Strings are printed without quotation marks or escapes for special characters, as if
by <tt>put-string</tt>, and characters
are printed without the <tt>#\</tt> notation, as if by <tt>put-char</tt>.
With <tt>display</tt>,
the three-element list <tt>(a&nbsp;b&nbsp;c)</tt>
and the two-element list <tt>("a&nbsp;b"&nbsp;c)</tt> both print as
<tt>(a&nbsp;b&nbsp;c)</tt>.
Because of this, <tt>display</tt> should not be used to print objects that
are intended to be read with <tt>read</tt>.
<tt>display</tt> is useful primarily for printing messages, with <tt><i>obj</i></tt>
most often being a string.
See Section&nbsp;<a href="./examples.html#g176">12.5</a> for an implementation of <tt>put-datum</tt>,
<tt>write</tt>, and <tt>display</tt>.

<p>
<a name="./io:s86"></a><span class=formdef><b>procedure</b>: <tt>(write-char&nbsp;<i>char</i>)</tt></span>
<br>
<span class=formdef><b>procedure</b>: <tt>(write-char&nbsp;<i>char</i>&nbsp;<i>textual-output-port</i>)</tt></span>
<br>
<b>returns: </b>unspecified
<br>
<b>libraries: </b><tt>(rnrs&nbsp;io&nbsp;simple)</tt>, <tt>(rnrs)</tt>

<p>If <tt><i>textual-output-port</i></tt> is not supplied, it defaults to the current output port.
This procedure is otherwise equivalent to <tt>put-char</tt>, with the
arguments reversed.


<p>
<a name="./io:s87"></a><span class=formdef><b>procedure</b>: <tt>(newline)</tt></span>
<br>
<span class=formdef><b>procedure</b>: <tt>(newline&nbsp;<i>textual-output-port</i>)</tt></span>
<br>
<b>returns: </b>unspecified
<br>
<b>libraries: </b><tt>(rnrs&nbsp;io&nbsp;simple)</tt>, <tt>(rnrs)</tt>

<p>If <tt><i>textual-output-port</i></tt> is not supplied, it defaults to the current output port.
<tt>newline</tt> sends a line-feed character to the port.


<p>
<a name="./io:s88"></a><span class=formdef><b>procedure</b>: <tt>(close-input-port&nbsp;<i>input-port</i>)</tt></span>
<br>
<span class=formdef><b>procedure</b>: <tt>(close-output-port&nbsp;<i>output-port</i>)</tt></span>
<br>
<b>returns: </b>unspecified
<br>
<b>libraries: </b><tt>(rnrs&nbsp;io&nbsp;simple)</tt>, <tt>(rnrs)</tt>

<p><tt>close-input-port</tt> closes an input port, and
<tt>close-output-port</tt> closes an output port.
These procedures are provided for backward compatibility with the Revised<sup>5</sup>
Report; they are not actually more convenient to use than <tt>close-port</tt>.


<p>

<h3><a name="g131"></a><a name="./io:h10"></a>Section 7.10. Filesystem Operations<a name="SECTFILESYSTEM"></a></h3>



<p>
Scheme has two standard operations, beyond file input/output, for interacting with the
filesystem: <tt>file-exists?</tt> and <tt>delete-file</tt>.
Most implementations support additional operations.


<p>
<a name="./io:s89"></a><span class=formdef><b>procedure</b>: <tt>(file-exists?&nbsp;<i>path</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if the file named by <tt><i>path</i></tt> exists, <tt>#f</tt> otherwise
<br>
<b>libraries: </b><tt>(rnrs&nbsp;files)</tt>, <tt>(rnrs)</tt>

<p><tt><i>path</i></tt> must be a string or some other implementation-dependent 
value that names a file.
Whether <tt>file-exists?</tt> follows symbolic links is unspecified.


<p>
<a name="./io:s90"></a><span class=formdef><b>procedure</b>: <tt>(delete-file&nbsp;<i>path</i>)</tt></span>
<br>
<b>returns: </b>unspecified
<br>
<b>libraries: </b><tt>(rnrs&nbsp;files)</tt>, <tt>(rnrs)</tt>

<p><tt><i>path</i></tt> must be a string or some other implementation-dependent 
value that names a file.
<tt>delete-file</tt> removes the file named by <tt><i>path</i></tt> if it exists
and can be deleted, otherwise it raises an exception with condition
type <tt>&amp;i/o-filename</tt>.
Whether <tt>delete-file</tt> follows symbolic links is unspecified.


<p>

<h3><a name="g132"></a><a name="./io:h11"></a>Section 7.11. Bytevector/String Conversions<a name="SECTBSCONVS"></a></h3>



<p>
The procedures described in this section encode or decode character
sequences, converting from strings to bytevectors or bytevectors to
strings.
They do not necessarily involve input/output, though they might be
implemented using bytevector input and output ports.

<p>
The first two procedures, <tt>bytevector-&gt;string</tt> and
<tt>string-&gt;bytevector</tt>, take an explicit transcoder argument that
determines the character encodings, eol styles, and error-handling modes.
The others perform specific Unicode conversions with an implicit
eol-style of <tt>none</tt> and error-handling mode of <tt>replace</tt>.


<p>
<a name="./io:s91"></a><span class=formdef><b>procedure</b>: <tt>(bytevector-&gt;string&nbsp;<i>bytevector</i>&nbsp;<i>transcoder</i>)</tt></span>
<br>
<b>returns: </b>a string containing the characters encoded in <tt><i>bytevector</i></tt>
<br>
<b>libraries: </b><tt>(rnrs&nbsp;io&nbsp;ports)</tt>, <tt>(rnrs)</tt>

<p>This operation, at least in effect, creates a bytevector input port with
the specified <tt><i>transcoder</i></tt> from which all of the available characters
are read, as if by <tt>get-string-all</tt>, and placed into the output
string.

<p>

<p><tt>(let&nbsp;([tx&nbsp;(make-transcoder&nbsp;(utf-8-codec)&nbsp;(eol-style&nbsp;lf)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(error-handling-mode&nbsp;replace))])<br>

&nbsp;&nbsp;(bytevector-&gt;string&nbsp;#vu8(97&nbsp;98&nbsp;99)&nbsp;tx))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;"abc"</tt>
<p><a name="./io:s92"></a><span class=formdef><b>procedure</b>: <tt>(string-&gt;bytevector&nbsp;<i>string</i>&nbsp;<i>transcoder</i>)</tt></span>
<br>
<b>returns: </b>a bytevector containing the encodings of the characters in <tt><i>string</i></tt>
<br>
<b>libraries: </b><tt>(rnrs&nbsp;io&nbsp;ports)</tt>, <tt>(rnrs)</tt>

<p>This operation, at least in effect, creates a bytevector output port with
the specified <tt><i>transcoder</i></tt> to which all of the characters of
<tt><i>string</i></tt> are written, then extracts a bytevector containing the
accumulated bytes.

<p>

<p><tt>(let&nbsp;([tx&nbsp;(make-transcoder&nbsp;(utf-8-codec)&nbsp;(eol-style&nbsp;none)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(error-handling-mode&nbsp;raise))])<br>

&nbsp;&nbsp;(string-&gt;bytevector&nbsp;"abc"&nbsp;tx))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#vu8(97&nbsp;98&nbsp;99)</tt>
<p><a name="./io:s93"></a><span class=formdef><b>procedure</b>: <tt>(string-&gt;utf8&nbsp;<i>string</i>)</tt></span>
<br>
<b>returns: </b>a bytevector containing the UTF-8 encoding of <tt><i>string</i></tt>
<br>
<b>libraries: </b><tt>(rnrs&nbsp;bytevectors)</tt>, <tt>(rnrs)</tt>

<p><a name="./io:s94"></a><span class=formdef><b>procedure</b>: <tt>(string-&gt;utf16&nbsp;<i>string</i>)</tt></span>
<br>
<span class=formdef><b>procedure</b>: <tt>(string-&gt;utf16&nbsp;<i>string</i>&nbsp;<i>endianness</i>)</tt></span>
<br>
<span class=formdef><b>procedure</b>: <tt>(string-&gt;utf32&nbsp;<i>string</i>)</tt></span>
<br>
<span class=formdef><b>procedure</b>: <tt>(string-&gt;utf32&nbsp;<i>string</i>&nbsp;<i>endianness</i>)</tt></span>
<br>
<b>returns: </b>a bytevector containing the specified encoding of <tt><i>string</i></tt>
<br>
<b>libraries: </b><tt>(rnrs&nbsp;bytevectors)</tt>, <tt>(rnrs)</tt>

<p><tt><i>endianness</i></tt> must be one of the symbols <tt>big</tt> or <tt>little</tt>.
If <tt><i>endianness</i></tt> is not provided or is the symbol <tt>big</tt>,
<tt>string-&gt;utf16</tt> returns the UTF-16BE encoding of <tt><i>string</i></tt> and
<tt>string-&gt;utf32</tt> returns the UTF-32BE encoding of <tt><i>string</i></tt>.
If <tt><i>endianness</i></tt> is the symbol <tt>little</tt>, <tt>string-&gt;utf16</tt> returns the
UTF-16LE encoding of <tt><i>string</i></tt> and <tt>string-&gt;utf32</tt> returns the
UTF-32LE encoding of <tt><i>string</i></tt>.
No byte-order mark is included in the encoding.


<p>
<a name="./io:s95"></a><span class=formdef><b>procedure</b>: <tt>(utf8-&gt;string&nbsp;<i>bytevector</i>)</tt></span>
<br>
<b>returns: </b>a string containing the UTF-8 decoding of <tt><i>bytevector</i></tt>
<br>
<b>libraries: </b><tt>(rnrs&nbsp;bytevectors)</tt>, <tt>(rnrs)</tt>

<p><a name="./io:s96"></a><span class=formdef><b>procedure</b>: <tt>(utf16-&gt;string&nbsp;<i>bytevector</i>&nbsp;<i>endianness</i>)</tt></span>
<br>
<span class=formdef><b>procedure</b>: <tt>(utf16-&gt;string&nbsp;<i>bytevector</i>&nbsp;<i>endianness</i>&nbsp;<i>endianness-mandatory?</i>)</tt></span>
<br>
<span class=formdef><b>procedure</b>: <tt>(utf32-&gt;string&nbsp;<i>bytevector</i>&nbsp;<i>endianness</i>)</tt></span>
<br>
<span class=formdef><b>procedure</b>: <tt>(utf32-&gt;string&nbsp;<i>bytevector</i>&nbsp;<i>endianness</i>&nbsp;<i>endianness-mandatory?</i>)</tt></span>
<br>
<b>returns: </b>a string containing the specified decoding of <tt><i>bytevector</i></tt>
<br>
<b>libraries: </b><tt>(rnrs&nbsp;bytevectors)</tt>, <tt>(rnrs)</tt>

<p><tt><i>endianness</i></tt> must be one of the symbols <tt>big</tt> or
<tt>little</tt>.
These procedures return a UTF-16 or UTF-32 decoding of <tt><i>bytevector</i></tt>,
with the endianness of the representation determined from the endianness
argument or byte-order mark (BOM).
If <tt><i>endianness-mandatory?</i></tt> is not provided or is <tt>#f</tt>, the
endianness is determined by a BOM at the front of <tt><i>bytevector</i></tt> or, if
no BOM is present, by <tt><i>endianness</i></tt>.
If <tt><i>endianness-mandatory?</i></tt> is <tt>#t</tt>, the endianness is
determined by <tt><i>endianness</i></tt>, and, if a BOM appears at the front of
<tt><i>bytevector</i></tt>, it is treated as a regular character encoding.

<p>
The UTF-16 BOM is the two-byte sequence <tt>#xFE</tt>, <tt>#xFF</tt>
specifying "big" or the two-byte sequence <tt>#xFF</tt>, <tt>#xFE</tt>
specifying "little."
The UTF-32 BOM is the four-byte sequence <tt>#x00</tt>, <tt>#x00</tt>,
<tt>#xFE</tt>, <tt>#xFF</tt> specifying "big" or the four-byte sequence
<tt>#xFF</tt>, <tt>#xFE</tt>, <tt>#x00</tt>, <tt>#x00</tt> specifying
"little."




<hr class=copyright align=left>
<p>
R. Kent Dybvig / <it>The Scheme Programming Language, Fourth Edition</it><br>
Copyright &copy; 2009 <a class=plain href="http://mitpress.mit.edu/catalog/item/default.asp?ttype=2&tid=11984">The MIT Press</a>.  Electronically reproduced by permission.<br>
Illustrations &copy; 2009 <a class=plain href="http://hebert.kitp.ucsb.edu/">Jean-Pierre H&eacute;bert</a><br>
ISBN 978-0-262-51298-5 / LOC QA76.73.S34D93<br>
<a class=plain href="http://mitpress.mit.edu/catalog/item/default.asp?ttype=2&tid=11984">to order this book</a> / <a class=plain href="canned/about.html">about this book</a>
</p>
<p><a class=plain href="http://www.scheme.com">http://www.scheme.com</a></p>
</body>
</html>
