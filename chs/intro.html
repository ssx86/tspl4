<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
  "http://www.w3.org/TR/html4/loose.dtd"><!-- DO NOT EDIT THIS FILE-->
<!-- Edit the .tex version instead-->

<html>
<head>
<title>简介</title>
<link href="tspl.css" rel="stylesheet" type="text/css">
</head>
<body>
<a name="g0"></a>
<a name="./intro:h0"></a>

<div style="font-size: 12px; width: 500px; height: 500px; border: solid thin">
<img style="padding: 20px 10px 20px 20px" src="canned/ch1.png"><img src="canned/jph.png">
</div>
<h1>第一章. 简介<a name="CHPTINTRO"></a></h1>





<p>
  Scheme是一个通用的计算机语言，它是一个高级语言，
  可以操作诸如字符串，列表和向量之类的结构化数据，
  也可以操作其他传统数据类型例如数值和字符。
  Scheme通常被视为<span class="todo">符号应用(symbolic applications)</span>，
  它丰富的数据类型和灵活的控制结构使它成为一个真正的通用语言。
  Scheme被用来编写文字编辑软件、<span class="todo">最优编译器</span>、
  操作系统、图形化包、专家系统、数值应用、
  金融分析包、虚拟现实系统，和其他几乎所有可以想象的程序。
  Scheme是一门相当容易掌握的语言，因为它只有很少的语法形式和语义概念，
  并且多数Scheme实现中的交互式特性，是鼓励动手实验的。
  然而，全面掌握Scheme语言也是很有挑战的。发掘它全部的潜力需要仔细的学习和练习。

<p>
用相同Scheme实现版本编写的程序在不同机器上具有极强的可移植性，因为机器依赖的部分几乎都是程序员不可见。
由于Scheme语言设计者们的努力，不同的Scheme实现版本之间也实现了很强的可移植性。他们发布了一系列的报告：
"<a name="./intro:s0"></a>Revised Reports"。
最近的
"Revised<sup>6</sup> Report"&nbsp;[<a class=citation href="./bibliography.html#g242">24</a>]通过一套标准库和定义可移植库、顶层程序规范机制，强调了可移植性，

<p>
  尽管早起的一些Scheme系统曾经低效并且缓慢，
  但很多新的编译型的实现已经很快了，
  编写出来的程序能够和低级语言写的同样程序不相上下。
  有时依然存在的相对效率较低是由运行时检查造成的，
  这些检查是为了支持泛型算法和帮助程序员检测、更正大量常见编码错误。
  这些检查在很多实现中可能允许关闭。

<p>
<p>
  Scheme支持很多类型的数据值/<a name="./intro:s1"></a><i>对象</i>，包括字符、字符串、符号、列表或对象向量，
  和一套数值类型，包括复数、实数和任意精度的有理数。

<p>
  用来存储对象内容的空间被<a name="./intro:s2"></a>自动按需分配，
  并且保持到不再需要为止，
  然后自动被回收。
  通常由一个<a name="./intro:s3"></a><i>垃圾回收器</i>定期回收不可达到的对象所占空间。
  简单的原子值，比如小整数、字符、布尔值和空表，
  通常表示成立即数，从而避免分配和释放空间的负担。

<p>
  如果不考虑表现形式，所有对象都是<a name="./intro:s4"></a><i>第一等</i>数据值，
  因为它们<span class="todo">永久保留</span>，可以随意被当做参数传递给一个过程、从一个过程中返回，
  还可以相互组合形成新的对象。
  这一点和很多其他语言是不同的，其他语言的复合类型数据（例如数组）
  通常要么静态分配空间永不释放，要么在进入一个代码块的时候分配空间，退出的时候无条件释放，
  要么就由程序员自己明确的控制分配和释放。

<p>
  Scheme 是一个值传递类型语言，但是至少对于可变对象来说，值是指向真正存储空间的<a name="./intro:s5"></a>指针。
  这些指针是隐藏在幕后的，程序员们不必意识到他们的存在，
  只需要了解一个对象的空间在这个对象被传递和从过程中返回的时候并没有被复制。

<p>
  <a name="./intro:s6"></a>Scheme的核心是很少的一组语法形式，其余的部分都由这个核心构建而成。
  一组扩展语法形式从核心形式中继承而来，
  还有一组<a name="./intro:s7"></a>原始过程，组成了整个Scheme语言。
  Scheme的<a name="./intro:s8"></a>解释器或者<a name="./intro:s9"></a>编译器可能很小很快，并且非常可靠。
  扩展语法形式和很多原始过程都能用Scheme自身来定义，从而简化了实现，增加了可靠性。

<p>
  Scheme程序和Scheme的数据结构共享同一套可打印的表现形式。
  这使得任何Scheme程序有一个自然而明确的可视为Scheme对象的内部表现形式。
  例如， <a name="./intro:s10"></a>变量和语法<a name="./intro:s11"></a>关键字与符号一致，结构化语法形式和列表一致。
  这个表示方法是Scheme语法扩展功能在按照现有语法形式和过程来定义新的语法形式时所依赖的基础。
  它也使得我们可以使用Scheme来实现Scheme解释器、编译器和其他Scheme程序转换工具，
  就像用Scheme编写其他语言的程序转换工具一样。

<p>
<p>Scheme变量和关键字使用<a name="./intro:s12"></a><i>词法作用域</i>，
  并且程序是分块结构化(<a name="./intro:s13"></a><i>block-structured</i>)的。
  标识符可能引入到一个程序或库中，或者局部绑定到指定的库、程序或过程体中。
  一个局部<a name="./intro:s14"></a>绑定只在词法上可见，就是说只在这段代码文本的内部可见。
  当一个同样名字的标识符在代码块外部出现的时候，它引用的是一个不同的绑定；
  如果外部不存在这个绑定的话，这个引用就是不合法的。
  代码块可以嵌套，并且内部的绑定可以<a name="./intro:s15"></a><i>屏蔽</i>(<i>shadow</i>)外部同名的标识符。
  一个绑定的<i>作用域</i>是这个标识符可见的代码段，减去这个标识符被屏蔽的代码段。
  块结构和词法作用域有助于创建模块化、高可读性、高可维护性和高可靠性的程序。
  词法作用域的代码能够更高效，因为编译器能够在程序运行之前检测出所有绑定的作用域，解析出所有绑定引用的标识符。
  这当然不是说编译器能够检测出所有变量的值，因为大多数情况下变量的实际值要到程序运行时才计算出来。

<p>
<p>在大多数语言中，<a name="./intro:s16"></a>过程定义就是简单的把一个名字和一个代码块关联起来。
  代码块中的变量就是这个过程的参数。
  在某些语言中，一个过程定义可以出现在另一个代码块或者过程中，只要这个过程仅在这个封闭代码块执行期间被调用即可。
  在其他的语言中，过程只能在顶层定义。
  在Scheme中，一个过程可以出现在任何代码块或者过程中，并且可能在之后的任何时候被调用，甚至那个封闭代码块已经执行完毕之后。
  为了支持<a name="./intro:s17"></a>词法作用域， 过程的代码必须携带着它定义时的词法上下文（环境）。


<p>
  此外，Scheme的过程不一定都是具名的。过程像字符串和数值一样，
  也是<a name="./intro:s18"></a>第一等数据对象，
  并且变量可以像绑定在其他对象上那样绑定在一个过程上。

<p>
  和其他语言中的过程一样，Scheme的过程可以递归。就是说，任何过程都可以直接或者间接的调用自己。
  很多优雅高效的算法都使用递归。
  有一种特殊的<a name="./intro:s19"></a>情况，叫做<a name="./intro:s20"></a>尾递归，
  是用来表达<a name="./intro:s21"></a>迭代或者<a name="./intro:s22"></a>循环的。
  一个过程直接返回另一过程调用结果时，发生<a name="./intro:s23"></a><i>尾调用</i>；
  一个过程直接或者间接递归的尾调用自身时，发生<i>尾递归</i>
  Scheme要求尾调用必须实现成跳转（goto），从而避免递归时带来的存储空间开销。
  最终程序员需要掌握的就只有简单的过程调用和递归，并且不需要掌握常规的各种循环结构。


<p>
<p
   Scheme支持用<a name="./intro:s24"></a><i>连续体</i>（<i>continuation</i>）来定义任意控制结构。
   Continuation是一个过程，嵌入了指定点之后整个程序的剩余部分。
   可以在程序运行的任何时刻得到一个continuation。
   和其他过程一样，一个continuation是第一等对象，可以在被创建之后的任何时刻被调用。
   Continuation能够实现复杂的控制机制，包括显式的回溯、多线程和协程。

<p>
  <a name="./intro:s25"></a>Scheme也允许程序员自己定义语法形式或者<i>语法扩展</i>。
  这可以通过编写转换过程确定新的语法形式到现有语法形式的映射关系来实现。。
  这些转换过程是用Scheme自我表述的，利用了一种能够自动进行语法检查、输入解析和输出重建的
  方便的高阶模式语言。
  默认情况下，整个转换过程使用词法作用域，但是程序员可以对转换器的输出中出现的所有标识符的作用域施加控制。
  语法扩展对定义新的语言结构、仿真其他语言结构、达到内联代码展开的效果，甚至是用Scheme仿真整个语言来说，都是很有用的。
  大多数大型Scheme程序都是由语法扩展和过程定义混合组成的。

<p>
<p>Scheme从<a name="./intro:s26"></a>Lisp语言进化而来，被视为List的一个方言。
  Scheme从Lisp继承了大量内容，比如把值看做第一等对象，
  很多重要的数据类型（符号和列表等），和把程序表示成对象等。
  词法作用域和快结构是从<a name="./intro:s27"></a>Algol 60&nbsp;[<a class=citation href="./bibliography.html#g239">21</a>]借鉴而来。
  Scheme是第一个采用词法作用域、快结构、过程视为一等公民、尾调用实现成跳转、引入continuation和词法作用域语法扩展的Lisp方言。


<p>
  <a name="./intro:s28"></a>Common Lisp&nbsp;[<a class=citation href="./bibliography.html#g245">27</a>]和Scheme是同一时期的
  Lisp语言，并且两者的发展互相受到了影响。
  类似Scheme但是有别于早期Lisp语言，Common Lisp采用了词法作用域和过程视为一等公民，
  但是Common Lisp的语法扩展机制不支持词法作用域。
  Common Lisp过程的求值规则和其他对象的求值规则有所不同，
  它为过程变量维护了一个单独的命名空间，
  从而禁止了将过程当做第一等对象来使用。
  同时，Common Lisp也不支持continuation，并且不对尾调用的处理作出强制要求，
  但它的确提供了在Scheme中没有的很多不太常用的控制结构。
  虽然这两个语言非常相似，Common Lisp提供了更多专用的构造，
  而Scheme则提供了更多通用的用来建造这些构造的基础结构。


<p>
<p>
  这一章剩下的部分介绍Scheme的语法和命名约定，以及整本书的印刷约定。

<p>

<h3><a name="g1"></a><a name="./intro:h1"></a>1.1. Scheme语法<a name="SECTINTROSYNTAX"></a></h3>



<p>
  Scheme程序是由关键字、变量、<a name="./intro:s29"></a>结构化形式、
  常量数据（数值、字符、字符串、引用向量、引用列表、引用符号等）、空白字符和注释组成的。
  
<p>
  关键字、变量和符号一并称作<a name="./intro:s30"></a>标识符（identifiers）。
  标识符可以由字母、数字和指定的特殊字符构成，包括<tt>?</tt>, <tt>!</tt>, <tt>.</tt>, <tt>+</tt>,
  <tt>-</tt>, <tt>*</tt>, <tt>/</tt>, <tt>&lt;</tt>, <tt>=</tt>, <tt>&gt;</tt>,
  <tt>:</tt>, <tt>$</tt>, <tt>%</tt>, <tt>^</tt>, <tt>&amp;</tt>, <tt>_</tt>,
  <tt>~</tt>, 和<tt>@</tt>，还有一组额外的Unicode字符。

  标识符不能以at符号&nbsp;(&nbsp;<tt>@</tt>&nbsp;)开头，并且通常不能以“能开始一个数值的字符”开头，
  比如数字、加号&nbsp;(&nbsp;<tt>+</tt>&nbsp;)，减号&nbsp;(&nbsp;<tt>-</tt>&nbsp;)，或者小数点&nbsp;(&nbsp;<tt>.</tt>&nbsp;)。
  其中例外的是：&nbsp;<tt>+</tt>,&nbsp;<tt>-</tt>和&nbsp;<tt>...</tt>，它们都是有效的标识符，
  还有以<tt>-&gt;</tt>开头的任何标识符。
  例如：<tt>hi</tt>, <tt>Hello</tt>, <tt>n</tt>, <tt>x</tt>, <tt>x3</tt>, <tt>x+2</tt>和<tt>?$&amp;*!!!</tt>这些全都是标识符。
  标识符用空白字符、注释、小括号()、中括号[]、字符串、（双）引号&nbsp;(&nbsp;<tt>""</tt>&nbsp;)和井号(&nbsp;<tt>#</tt>&nbsp;)。
  分隔符或者其他Unicode字符可以用转义的形式包含在一个标识符中，形如\xsv，其中sv是这个字符编码的十六进制记法。

<p>
  在Scheme中标识符没有长度的限制，程序员可以按照需要使用任意多的字符。
  但是长标识符并不能取代注释，频繁使用长标识符反而会导致一个程序很难格式化进而影响阅读。
  在小作用域中使用短标识符，大作用域中使用长标识符，是一个很好的规则。

<p>
  标识符可以任意混用大小写字母，并且大小写是敏感的。
  就是说，两个标识符即使只有字母大小写不同，也被视为不同的标识符。
  例如<tt>abcde</tt>, <tt>Abcde</tt>, <tt>AbCdE</tt>和<tt>ABCDE</tt>每一个都代表不同的标识符。
  这是在Revised Report中对以前版本的一个修改。

<p>
  结构化形式和<a name="./intro:s31"></a>列表常量用小括号()包围起来，例如：
  <tt>(a&nbsp;b&nbsp;c)</tt> 或 <tt>(*&nbsp;(-&nbsp;x&nbsp;2)&nbsp;y)</tt>。
  <a name="./intro:s32"></a>空表写作：<a name="./intro:s33"></a><tt>()</tt>。
  <a name="./intro:s34"></a>成对的中括号(&nbsp;<tt>[</tt>&nbsp;<tt>]</tt>&nbsp;)可以用来替换小括号(),
  通常在用在某些标准语法形式中的子表达式上，用来增加可读性，可以参考贯穿本书的各个示例代码。
  向量通常和list的记法一样，只是以<tt>#(</tt>开头，以<tt>)</tt>结尾，例如：
  <tt>#(this&nbsp;is&nbsp;a&nbsp;vector&nbsp;of&nbsp;symbols)</tt>。
  字节向量记作一个无符号byte值（0到255的整数）的序列，用<tt>#vu8(</tt>和<tt>)</tt>括起来，例如：
  <tt>#vu8(3&nbsp;250&nbsp;45&nbsp;73)</tt>。

<p>
  字符串用双引号包围起来，例如：
  <tt>"I&nbsp;am&nbsp;a&nbsp;string"</tt>。
  字符用<tt>#\</tt>开头，例如：<tt>#\a</tt>。
  同标识符一样，字符和字符串常量是大小写敏感的。
  数值可以写成整数（-123），比值（1/2），浮点数或科学计数法（1.3、1e23），
  或者用三角形式和极坐标形式表示的复数（1.3-2.7i、-1.2@73）。
  在数值中的字母大小写是不敏感的。
  <a name="./intro:s35"></a>布尔值代表<a name="./intro:s36"></a><i>真</i>和<a name="./intro:s37"></a><i>假</i>，
  记作<a name="./intro:s38"></a><tt>#t</tt>和<a name="./intro:s39"></a><tt>#f</tt>。
  Scheme的条件表达式实际上只把<tt>#f</tt>视作假，其他所有对象都视作真，所以：
  <tt>3</tt>, <tt>0</tt>, <tt>()</tt>, <tt>"false"</tt>和<tt>nil</tt>都是真。
  
<p>
  每种常量数据的语法细节将在<a href="./objects.html#g106">第六章</a>中单独的小节
  和<a href="./grammar.html#APPENDIXFORMALSYNTAX">第455页</a>开始的形式语法章节中介绍。

<p>
  Scheme的<a name="./intro:s40"></a>表达式可以跨越多行，并且不要求有显式的终结符号。
  由于表达式之间的<a name="./intro:s41"></a>空白字符（空格和换行）是没有影响的，
  Scheme程序应该使用缩进来尽量提高代码的可读性。

  <a name="./intro:s42"></a>注释可能出现在任何代码行中，
  从<a name="./intro:s43"></a><a name="./intro:s44"></a>分号(&nbsp;<tt>;</tt>&nbsp;)开始到行尾。
  用来解释一个Scheme表达式的注释通常以相同的缩进被放在该表达式的前一行。
  用来解释一个或一组过程的注释通常以不缩进（顶格）的形式放在过程的前面。
  多个注释字符通常用来引出下面这种注释：
  <br>
  <tt>;;;&nbsp;The&nbsp;following&nbsp;procedures&nbsp;...</tt>

<p>
  另外支持两种注释形式：块注释和数据注释。
  块注释使用<tt>#|</tt>和<tt>|#</tt>划定界限，并且可以嵌套。
  数据注释由一个<tt>#;</tt>前缀和紧跟在它后面的（可打印的）数据组成。
  数据注释通常用来注释掉个别的定义或表达式。
  例如：<tt>(three&nbsp;#;(not&nbsp;four)&nbsp;element&nbsp;list)</tt>。
  数据注释也可以被嵌套，虽然<tt>#;#;(a)(b)</tt>其实和分别注释掉<tt>(a)</tt>和<tt>(b)</tt>没有任何区别。
  
<p>
  有的Scheme值，比如过程和端口，没有标准的可打印的形式，
  <span class="todo">因此不能够在一个程序的可打印语法中以常量形式出现。</span>
  这本书用<tt>#&lt;<i>description</i>&gt;</tt>这样的记法来表示一个返回这种类型值的操作。例如：
  <tt>#&lt;procedure&gt;</tt>或<tt>#&lt;port&gt;</tt>。

<p>

<h3><a name="g2"></a><a name="./intro:h2"></a>1.2. Scheme命名约定<a name="SECTINTRONAMING"></a></h3>



<p>
  Scheme的<a name="./intro:s45"></a>命名约定意义在于让代码更规整。
  下面列出这些命名约定：

<p>
<ul>
  <li>断言以一个<a name="./intro:s46"></a><a name="./intro:s47"></a>问号 (&nbsp;<tt>?</tt>&nbsp;)结尾。
    断言就是返回真或者假的过程，例如 <tt>eq?</tt>, <tt>zero?</tt>和 <tt>string=?</tt>。
    普通数值比较运算符 <tt>=</tt>, <tt>&lt;</tt>, <tt>&gt;</tt>, <tt>&lt;=</tt>和<tt>&gt;=</tt>除外。

<p>
  <li>类型<a name="./intro:s48"></a>断言，例如<tt>pair?</tt>，由这个类型的名字，在这里是<tt>pair</tt>，
    和一个问号组成。

<p>
  <li>
    大多数字符、字符串和向量过程以<tt>char-</tt>, <tt>string-</tt>和<tt>vector-</tt>开头，比如说
    <tt>string-append</tt>。
    （有的列表过程以<tt>list-</tt>开头，但是大多数并不是）。

<p>
  <li>
    从一个类型的对象转化到另一个类型的对象的过程名字写作<a name="./intro:s49"></a><tt><i>type<sub>1</sub></i>-&gt;<i>type<sub>2</sub></i></tt>
    例如：<tt>vector-&gt;list</tt>。
    

<p>
  <li>
    会产生副作用的过程和语法形式以一个<a name="./intro:s50"></a><a name="./intro:s51"></a>叹号(&nbsp;<tt>!</tt>&nbsp;)结尾。
    这包括<tt>set!</tt>和<tt>vector-set!</tt>。
    完成输入输出的过程从技术上讲是会产生<a name="./intro:s52"></a>副作用的，但是它们的名字是个例外。
    
</ul>
<p>

<p>
  程序员在任何时候都应该在自己代码中尽量采用这些命名约定。
  
<p>

  <h3><a name="g3"></a><a name="./intro:h3"></a>1.3. 印刷和符号约定<a name="SECTINTRONOTATION"></a></h3>
  



<p>
  一个标准过程或语法形式如果唯一的作用就是产生一些副作用，那么称这样的过程返回是<a name="./intro:s53"></a><i>未指定的（unspecified）</i>。
  意思是说一个Scheme实现可以随意返回任何数量的值来作为这个过程或语法形式的返回值，每一个值都可以是任意Scheme对象。
  不要指望在不同的实现或者同一实现的不同版本之间这些返回值会保持一致，甚至在两次调用之间都未必一致。
  有的Scheme系统通常用一个特殊的对象来指代这个未指定的值。
  这个对象在交互式的Scheme系统中通常是禁止打印的，所以一个返回未指定值的表达式的值无法打印。
  
<p>
  <a name="./intro:s54"></a>虽然大多数标准过程返回一个值，这个语言实际上提供了返回0个、多个甚至可变个数返回值的支持。
  这个机制在&nbsp;<a href="./control.html#g104">5.8</a>节中会介绍。
  有的标准表达式如果它的子表达式中有返回多值的，那么它就会返回多值，例如，（子表达式是）调用一个返回多值的过程。
  当这种情况发生的时候，我们就会说这个表达式返回它子表达式的“values”（复数）而不是“value”。
  同样的，一个标准过程如果返回的是对一个过程参数的调用，我们会说是返回这个过程参数的“values”。
  
<p>
  <a name="./intro:s55"></a>这本书使用“必须”和“应该”来描述程序的需求，
  比如调用<tt>vector-ref</tt>的时候提供的索引值必须小于向量的长度这样的需求。
  如果使用了“必须”，意味着这个需求是实现强制的，就是说会抛出一个异常，通常带有条件类型<tt>&amp;assertion</tt>。
  如果使用了“应该”，意味着并不一定抛出异常，如果没有抛出异常，则程序的行为是未定义的。
  
<p>
  <a name="./intro:s56"></a>语法违例（syntax violation）这个短语用来描述一个程序畸形的情形。
  语法违例在程序执行之前被检测。如果检测到了一个语法违例，则会抛出一个<tt>&amp;syntax</tt>类型的异常，
  并且程序将不会被执行。

<p>
  这本书的印刷约定简单明了。所有的Scheme对象都使用<tt>印刷体</tt>，就像它们是从键盘上敲上去的一样。
  这包括语法关键字、变量、常量对象、Scheme表达式，和示例代码。
  在过程的描述中出现的参数，和语法形式描述中出现的语法变量，都使用<i>斜体</i>来打印。
  斜体也被用在某个术语第一次出现的时候。
  通常语法形式和过程的名字是不会大写的，即使是在句子的开头。以斜体字书写的语法变量亦是如此。
  
<p>
  在语法形式或过程的描述中，用一个或多个原型模式来展现某个过程的应用需要的语法形式或正确的参数个数。
  关键字或过程名字用印刷体给出，<span class="todo">小括号也是</span>。

  语法的其余部分或者参数都使用斜体展现，名字通常能代表此语法形式或过程期望的表达式或参数类型。
  省略号用来表示一个子表达式或参数出现0次或更多次。例如<tt>(or&nbsp;<i>expr</i>&nbsp;...)</tt>用来说明<tt>or</tt>
  的语法形式，其中有0个或者更多子表达式，而<tt>(member&nbsp;<i>obj</i>&nbsp;<i>list</i>)</tt>用来说明<tt>member</tt>过程，
  它期望两个参数，一个对象和一个列表。
  
<p>
  如果一个语法结构不符合它的原型，就会发生语法违例。
  同样的，如果传递给一个标准过程的参数数量不符，条件类型为<tt>&amp;assertion</tt>的异常将会抛出。
  当过程的参数类型或者其它（在描述中给出的）条件没有得到满足时，同样会抛出此异常。
  例如，<tt>vector-set!</tt>的原型是：

<p>

<p><tt>(vector-set!&nbsp;<i>vector</i>&nbsp;<i>n</i>&nbsp;<i>obj</i>)</tt>
<p>并且描述中说<tt><i>n</i></tt>必须是非负整数并严格小于<tt><i>向量（vector）</i></tt>的长度。
  因此，<tt>vector-set!</tt>必须接受3个参数，第一个必须是一个向量，第二个必须是比这个向量长度小的整数，
  第三个可以是任意Scheme对象。
  否则，一个<tt>&amp;assertion</tt>条件类型的异常将被抛出。

<p>
  在多数情况下，需要的参数类型是显而易见的，例如<tt><i>vector</i></tt>, <tt><i>obj</i></tt>或<tt><i>binary-input-port</i></tt>。
  其他情况下，主要是在数值程序上，会使用缩写形式，比如<tt><i>int</i></tt>代表integer，<tt><i>exint</i></tt>代表exact integer，<tt><i>fx</i></tt>代表fixnum。
    这些缩写会在用到的章节开头给出解释。
    




<hr class=copyright align=left>
<p>
R. Kent Dybvig / <it>The Scheme Programming Language, Fourth Edition</it><br>
Copyright &copy; 2009 <a class=plain href="http://mitpress.mit.edu/catalog/item/default.asp?ttype=2&tid=11984">The MIT Press</a>.  Electronically reproduced by permission.<br>
Illustrations &copy; 2009 <a class=plain href="http://hebert.kitp.ucsb.edu/">Jean-Pierre H&eacute;bert</a><br>
ISBN 978-0-262-51298-5 / LOC QA76.73.S34D93<br>
<a class=plain href="http://mitpress.mit.edu/catalog/item/default.asp?ttype=2&tid=11984">to order this book</a> / <a class=plain href="canned/about.html">about this book</a>
</p>
<p><a class=plain href="http://www.scheme.com">http://www.scheme.com</a></p>
</body>
</html>
