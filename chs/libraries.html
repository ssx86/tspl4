<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
  "http://www.w3.org/TR/html4/loose.dtd"><!-- DO NOT EDIT THIS FILE-->
<!-- Edit the .tex version instead-->

<html>
<head>
<title>Libraries and Top-Level Programs</title>
<link href="tspl.css" rel="stylesheet" type="text/css">
</head>
<body>
<a name="g142"></a>
<a name="./libraries:h0"></a>

<div style="font-size: 12px; width: 500px; height: 500px; border: solid thin">
<img style="padding: 20px 10px 20px 20px" src="canned/ch10.png"><img src="canned/jph.png">
</div>
<h1>Chapter 10. Libraries and Top-Level Programs<a name="CHPTLIBRARIES"></a></h1>





<p>
<a name="./libraries:s0"></a><a name="./libraries:s1"></a><i>Libraries</i> and
<i>top-level programs</i> are the basic units of portable code in the
language defined by the Revised<sup>6</sup> Report on Scheme&nbsp;[<a class=citation href="./bibliography.html#g242">24</a>].
Top-level programs may import from one or more libraries, and
libraries may import from other libraries.

<p>
Libraries are named using a parenthesized syntax that encloses a
sequence of identifiers, optionally followed by a version; the
version is itself a parenthesized form that encloses a sequence
of subversions represented as exact nonnegative integers.
So, for example, <tt>(a)</tt>, <tt>(a&nbsp;b)</tt>, <tt>(a&nbsp;b&nbsp;())</tt>,
and <tt>(a&nbsp;b&nbsp;(1&nbsp;2&nbsp;3))</tt> are all valid library names.
Implementations typically treat the sequence of names as a path by which a
library's source or object code can be found, possibly rooted in some
standard set of locations in the host-machine's filesystem.

<p>
An implementation of the standard library mechanism is available
with the portable implementation of <tt>syntax-case</tt>
at <i>http://www.cs.indiana.edu/syntax-case/</i>.

<p>

<h3><a name="g143"></a><a name="./libraries:h1"></a>Section 10.1. Standard Libraries</h3>



<p>
The Revised<sup>6</sup> Report&nbsp;[<a class=citation href="./bibliography.html#g242">24</a>] describes a base library

<p>

<p><tt>&nbsp;&nbsp;(rnrs&nbsp;base&nbsp;(6))</tt>
<p>that defines the most commonly used features of the language.
A separate Standard Libraries document&nbsp;[<a class=citation href="./bibliography.html#g244">26</a>] describes the
libraries listed below.

<p>

<p><tt>&nbsp;&nbsp;(rnrs&nbsp;arithmetic&nbsp;bitwise&nbsp;(6))<br>

&nbsp;&nbsp;(rnrs&nbsp;arithmetic&nbsp;fixnums&nbsp;(6))<br>

&nbsp;&nbsp;(rnrs&nbsp;arithmetic&nbsp;flonums&nbsp;(6))<br>

&nbsp;&nbsp;(rnrs&nbsp;bytevectors&nbsp;(6))<br>

&nbsp;&nbsp;(rnrs&nbsp;conditions&nbsp;(6))<br>

&nbsp;&nbsp;(rnrs&nbsp;control&nbsp;(6))<br>

&nbsp;&nbsp;(rnrs&nbsp;enums&nbsp;(6))<br>

&nbsp;&nbsp;(rnrs&nbsp;eval&nbsp;(6))<br>

&nbsp;&nbsp;(rnrs&nbsp;exceptions&nbsp;(6))<br>

&nbsp;&nbsp;(rnrs&nbsp;files&nbsp;(6))<br>

&nbsp;&nbsp;(rnrs&nbsp;hashtables&nbsp;(6))<br>

&nbsp;&nbsp;(rnrs&nbsp;io&nbsp;ports&nbsp;(6))<br>

&nbsp;&nbsp;(rnrs&nbsp;io&nbsp;simple&nbsp;(6))<br>

&nbsp;&nbsp;(rnrs&nbsp;lists&nbsp;(6))<br>

&nbsp;&nbsp;(rnrs&nbsp;mutable-pairs&nbsp;(6))<br>

&nbsp;&nbsp;(rnrs&nbsp;mutable-strings&nbsp;(6))<br>

&nbsp;&nbsp;(rnrs&nbsp;programs&nbsp;(6))<br>

&nbsp;&nbsp;(rnrs&nbsp;r5rs&nbsp;(6))<br>

&nbsp;&nbsp;(rnrs&nbsp;records&nbsp;procedural&nbsp;(6))<br>

&nbsp;&nbsp;(rnrs&nbsp;records&nbsp;syntactic&nbsp;(6))<br>

&nbsp;&nbsp;(rnrs&nbsp;records&nbsp;inspection&nbsp;(6))<br>

&nbsp;&nbsp;(rnrs&nbsp;sorting&nbsp;(6))<br>

&nbsp;&nbsp;(rnrs&nbsp;syntax-case&nbsp;(6))<br>

&nbsp;&nbsp;(rnrs&nbsp;unicode&nbsp;(6))</tt>
<p>One more library is described in the Standard Libraries document, a
composite library

<p>

<p><tt>&nbsp;&nbsp;(rnrs&nbsp;(6))</tt>
<p>that exports all of the
<tt>(rnrs&nbsp;base&nbsp;(6))</tt> bindings along with those of
the other libraries listed above, except those of
<tt>(rnrs&nbsp;eval&nbsp;(6))</tt>, <tt>(rnrs&nbsp;mutable-pairs&nbsp;(6))</tt>,
<tt>(rnrs&nbsp;mutable-strings&nbsp;(6))</tt>, and <tt>(rnrs&nbsp;r5rs&nbsp;(6))</tt>.

<p>
Although each of these libraries has the version <tt>(6)</tt>,
references to them can and in most cases should leave the version
out, e.g., the composite library should be referenced simply
as <tt>(rnrs)</tt>.

<p>

<h3><a name="g144"></a><a name="./libraries:h2"></a>Section 10.2. Defining New Libraries</h3>



<p>
New libraries are defined with the <tt>library</tt> form, which has
the following syntax.

<p>

<p><tt>(library&nbsp;<i>library-name</i><br>

&nbsp;&nbsp;(export&nbsp;<i>export-spec</i>&nbsp;...)<br>

&nbsp;&nbsp;(import&nbsp;<i>import-spec</i>&nbsp;...)<br>

&nbsp;&nbsp;<i>library-body</i>)</tt>
<p>A <tt><i>library-name</i></tt> specifies the name and possibly version by which the
library is identified by the <tt>import</tt> form of another library or
top-level program.
It also serves as kind of path that the implementation uses to locate the
library, via some implementation-specific process, whenever it needs to be
loaded.
A <tt><i>library-name</i></tt> has one of the following two forms:

<p>

<p><tt>(<i>identifier</i>&nbsp;<i>identifier</i>&nbsp;...)<br>

(<i>identifier</i>&nbsp;<i>identifier</i>&nbsp;...&nbsp;<i>version</i>)</tt>
<p><a name="./libraries:s2"></a>where <tt><i>version</i></tt> has the following form:

<p>

<p><tt>(<i>subversion</i>&nbsp;...)</tt>
<p>and each <tt><i>subversion</i></tt> represents an exact nonnegative integer.
A library name with no <tt><i>version</i></tt> is treated the same
as a library name with the empty <tt><i>version</i></tt> <tt>()</tt>.
For example, <tt>(list-tools&nbsp;setops)</tt> and
<tt>(list-tools&nbsp;setops&nbsp;())</tt> are equivalent and specify a
library name with no version, while
<tt>(list-tools&nbsp;setops&nbsp;(1&nbsp;2))</tt> specifies a versioned library name,
which can be thought of as Version&nbsp;1.2 of the <tt>(list-tools&nbsp;setops)</tt>
library.

<p>
<a name="./libraries:s3"></a>The <tt>export</tt> subform names the exports and, optionally, the names
by which they should be known outside of the library.
Each <tt><i>export-spec</i></tt> takes one of the following two forms:

<p>

<p><tt><i>identifier</i><br>

(rename&nbsp;(<i>internal-name</i>&nbsp;<i>export-name</i>)&nbsp;...)</tt>
<p>where each <tt><i>internal-name</i></tt> and <tt><i>export-name</i></tt> is an identifier.
The first form names a single export, <tt><i>identifier</i></tt>, whose export
name is the same as its internal name.
The second names a set of exports, each of whose export name is
given explicitly and may differ from its internal name.

<p>
<a name="./libraries:s4"></a><a name="./libraries:s5"></a><a name="desc:import"></a>The <tt>import</tt> subform names the other libraries upon which the new
library depends and, possibly, the set of identifiers to be imported and
the names by which they should be known inside the new library.
It may also specify when the bindings should be made available for
implementations that require such information.
Each <tt><i>import-spec</i></tt> takes one of the following two forms:

<p>

<p><tt><i>import-set</i><br>

(for&nbsp;<i>import-set</i>&nbsp;<i>import-level</i>&nbsp;...)</tt>
<p>where <tt><i>import-level</i></tt> is one of the following:

<p>

<p><tt>run<br>

expand<br>

(meta&nbsp;<i>level</i>)</tt>
<p>and <tt><i>level</i></tt> represents an exact integer.

<p>
<a name="./libraries:s6"></a>The <tt>for</tt> syntax declares when the imported bindings might be
used by the importing library and thus when the implementation must make
the bindings available.
<tt>run</tt> and <tt>(meta&nbsp;0)</tt> are equivalent and specify that the
bindings imported from a library might be referenced by the run-time
expressions (<tt>define</tt> right-hand-side expressions and initialization
expressions) of the importing library.
<tt>expand</tt> and <tt>(meta&nbsp;1)</tt> are equivalent and specify that the
bindings imported from a library might be referenced by the transformer
expressions (<tt>define-syntax</tt>, <tt>let-syntax</tt>, or
<tt>letrec-syntax</tt> right-hand-side expressions) of the importing
library.
<tt>(meta&nbsp;2)</tt> specifies that the bindings imported from
a library might be referenced by a transformer expression that
appears within a transformer expression of the importing library,
and so on for higher meta levels.
Negative meta levels may also be specified and are needed in certain
circumstances when a transformer expands into the transformer for another
keyword binding used at a lower meta level.

<p>
<a name="./libraries:s7"></a><a name="export-level"></a>A library export may have a non-zero <i>export</i> meta level, in which
case the effective import level is the sum of the level specified by
<tt>for</tt> and the export level.
The exports of each standard library except <tt>(rnrs&nbsp;base)</tt>
and <tt>(rnrs)</tt> have export level zero.
For <tt>(rnrs&nbsp;base)</tt>, all exports have export level zero except
for <tt>syntax-rules</tt>, <tt>identifier-syntax</tt>, and their
auxiliary keywords <tt>_</tt>, <tt>...</tt>, and <tt>set!</tt>.
<tt>set!</tt> has export levels zero and one, while the others have
export level one.
All exports of the <tt>(rnrs)</tt> library have export levels zero and
one.

<p>
It can be difficult for the programmer to specify the import levels that
allow a library or top-level program to compile or run properly.
Moreover, it is often impossible to cause a library's bindings to be made
available when they are needed without causing them to be made available in
some cases when they are not needed.
For example, it is not possible to say that the run-time bindings of a
library A are needed when a library B is expanded without also having the
run-time bindings of A made available when code importing B is expanded.
Making bindings available involves executing the code for the right-hand
sides of the bindings and possibly executing initialization expressions as
well, so the inability to specify when bindings are needed precisely can
add both compile- and run-time overhead to a program.

<p>
Because of this, implementations are permitted to ignore export levels and
the <tt>for</tt> wrapper on an <tt><i>import-set</i></tt> and instead automatically
determine, while expanding an importing library or top-level program, when
an imported library's bindings must be made available, based on where
references to the imported library's exports actually appear.
When using such an implementation, the <tt>for</tt> wrapper need never be used,
i.e., all <tt><i>import-spec</i></tt>s can be <tt><i>import-set</i></tt>s.
If code is intended for use with systems that do not automatically determine
when a library's bindings must be made available, however, the <tt>for</tt>
must be used if the importing library's bindings would not otherwise be
available at the right time.

<p>
<a name="./libraries:s8"></a><a name="./libraries:s9"></a><a name="./libraries:s10"></a><a name="./libraries:s11"></a><a name="./libraries:s12"></a>An <tt><i>import-set</i></tt> takes one of the following forms:

<p>

<p><tt><i>library-spec</i><br>

(only&nbsp;<i>import-set</i>&nbsp;<i>identifier</i>&nbsp;...)<br>

(except&nbsp;<i>import-set</i>&nbsp;<i>identifier</i>&nbsp;...)<br>

(prefix&nbsp;<i>import-set</i>&nbsp;<i>prefix</i>)<br>

(rename&nbsp;<i>import-set</i>&nbsp;(<i>import-name</i>&nbsp;<i>internal-name</i>)&nbsp;...)</tt>
<p>where <tt><i>prefix</i></tt>, <tt><i>import-name</i></tt>, and <tt><i>internal-name</i></tt> are identifiers.
An <tt><i>import-set</i></tt> is a recursive specification of the identifiers to be
imported from a library and possibly the names by which they should be known
within the importing library.
At the base of the recursive structure must sit a <tt><i>library-spec</i></tt>,
which identifies a library and imports all of the identifiers from that
library.
An <tt>only</tt> wrapper restricts the imported identifiers of the
enclosed <tt><i>import-set</i></tt> to the ones listed, an <tt>except</tt> wrapper
restricts the imported identifiers of the enclosed <tt><i>import-set</i></tt> to
those not listed, a <tt>prefix</tt> wrapper adds a prefix to each of the
imported identifiers of the enclosed <tt><i>import-set</i></tt>, and a
<tt>rename</tt> wrapper specifies internal names for selected identifiers
of the enclosed <tt><i>import-set</i></tt>, while leaving the names of the other
imports alone.
So, for example, the <tt><i>import-set</i></tt>

<p>

<p><tt>(prefix<br>

&nbsp;&nbsp;(only<br>

&nbsp;&nbsp;&nbsp;&nbsp;(rename&nbsp;(list-tools&nbsp;setops)&nbsp;(difference&nbsp;diff))<br>

&nbsp;&nbsp;&nbsp;&nbsp;union<br>

&nbsp;&nbsp;&nbsp;&nbsp;diff)<br>

&nbsp;&nbsp;set:)</tt>
<p>imports only <tt>union</tt> and <tt>difference</tt> from the
<tt>(list-tools&nbsp;setops)</tt> library, renames <tt>difference</tt> to
<tt>diff</tt> while leaving <tt>union</tt> alone, and adds the prefix
<tt>set:</tt> to the two names so that the names by which the two
imports are known inside the importing library are
<tt>set:union</tt> and <tt>set:diff</tt>.

<p>
A <tt><i>library-spec</i></tt> takes one of the following forms:

<p>

<p><tt><i>library-reference</i><br>

(library&nbsp;<i>library-reference</i>)</tt>
<p>where a <tt><i>library-reference</i></tt> is in either of the following two forms:

<p>

<p><tt>(<i>identifier</i>&nbsp;<i>identifier</i>&nbsp;...)<br>

(<i>identifier</i>&nbsp;<i>identifier</i>&nbsp;...&nbsp;<i>version-reference</i>)</tt>
<p>Enclosing a <tt><i>library-reference</i></tt> in a <tt>library</tt> wrapper is necessary
when the first identifier of the <tt><i>library-reference</i></tt> is
<tt>for</tt>, <tt>library</tt>, <tt>only</tt>, <tt>except</tt>, <tt>prefix</tt>, or
<tt>rename</tt>, to distinguish it from an <tt><i>import-spec</i></tt> or <tt><i>import-set</i></tt>
identified by one of these keywords.

<p>
<a name="./libraries:s13"></a>A <tt><i>version-reference</i></tt> identifies a particular version of the library or
a set of possible versions.
A <tt><i>version-reference</i></tt> has one of the following forms:

<p>

<p><tt>(<i>subversion-reference<sub>1</sub></i>&nbsp;...&nbsp;<i>subversion-reference<sub>n</sub></i>)<br>

(and&nbsp;<i>version-reference</i>&nbsp;...)<br>

(or&nbsp;<i>version-reference</i>&nbsp;...)<br>

(not&nbsp;<i>version-reference</i>)</tt>
<p>A <tt><i>version-reference</i></tt> of the first form matches a <tt><i>version</i></tt> with
at least <i>n</i> elements if each <tt><i>subversion-reference</i></tt> matches
<tt><i>version</i></tt>'s corresponding <tt><i>subversion</i></tt>.
An <tt>and</tt> <tt><i>version-reference</i></tt> form matches a <tt><i>version</i></tt> if
each of its <tt><i>version-reference</i></tt> subforms matches <tt><i>version</i></tt>.
An <tt>or</tt> <tt><i>version-reference</i></tt> form matches a <tt><i>version</i></tt> if
any of its <tt><i>version-reference</i></tt> subforms matches <tt><i>version</i></tt>.
A <tt>not</tt> <tt><i>version-reference</i></tt> form matches a <tt><i>version</i></tt> if
its <tt><i>version-reference</i></tt> subform does not match <tt><i>version</i></tt>.

<p>
A <tt><i>subversion-reference</i></tt> takes one of the following forms:

<p>

<p><tt><i>subversion</i><br>

(&gt;=&nbsp;<i>subversion</i>)<br>

(&lt;=&nbsp;<i>subversion</i>)<br>

(and&nbsp;<i>subversion-reference</i>&nbsp;...)<br>

(or&nbsp;<i>subversion-reference</i>&nbsp;...)<br>

(not&nbsp;<i>subversion-reference</i>)</tt>
<p>A <tt><i>subversion-reference</i></tt> of the first form matches a
<tt><i>subversion</i></tt> if it is identical to it.
A <tt>&gt;=</tt> <tt><i>subversion-reference</i></tt> matches a <tt><i>version</i></tt>'s
<tt><i>subversion</i></tt> if the <tt><i>version</i></tt>'s <tt><i>subversion</i></tt> is greater
than or equal to the <tt><i>subversion</i></tt> appearing within the
<tt>&gt;=</tt> form.
Similarly, a <tt>&lt;=</tt> <tt><i>subversion-reference</i></tt> matches a <tt><i>version</i></tt>'s
<tt><i>subversion</i></tt> if the <tt><i>version</i></tt>'s <tt><i>subversion</i></tt> is less
than or equal to the <tt><i>subversion</i></tt> appearing within the
<tt>&gt;=</tt> form.
An <tt>and</tt> <tt><i>subversion-reference</i></tt> form
matches a <tt><i>version</i></tt>'s <tt><i>subversion</i></tt> if each of its
<tt><i>subversion-reference</i></tt> subforms matches the <tt><i>version</i></tt>'s
<tt><i>subversion</i></tt>.
An <tt>or</tt> <tt><i>subversion-reference</i></tt> matches a <tt><i>version</i></tt>'s
<tt><i>subversion</i></tt> if any of its <tt><i>subversion-reference</i></tt> subforms match
the <tt><i>version</i></tt>'s <tt><i>subversion</i></tt>.
A <tt>not</tt> <tt><i>subversion-reference</i></tt> matches a <tt><i>version</i></tt>'s
<tt><i>subversion</i></tt> if its <tt><i>subversion-reference</i></tt> subform does not
match the <tt><i>version</i></tt>'s <tt><i>subversion</i></tt>.

<p>
For example, if two versions of a library are available, one with version
<tt>(1&nbsp;2)</tt> and the other with version <tt>(1&nbsp;3&nbsp;1)</tt>, the
version references <tt>()</tt> and <tt>(1)</tt> match both,
<tt>(1&nbsp;2)</tt> matches the first but not the second,
<tt>(1&nbsp;3)</tt> matches the second but not the first,
<tt>(1&nbsp;(&gt;=&nbsp;2))</tt> matches both, and
<tt>(and&nbsp;(1&nbsp;(&gt;=&nbsp;3))&nbsp;(not&nbsp;(1&nbsp;3&nbsp;1)))</tt> matches neither.

<p>
When a library reference identifies more than one available library,
one of the available libraries is selected in some
implementation-dependent manner.

<p>
Libraries and top-level programs should not, directly or indirectly,
specify the import of two libraries that have the same names but
different versions.
To avoid problems such as incompatible types and replicated state,
implementations are encouraged, though not required, to prohibit programs
from importing two versions of the same library.

<p>
<a name="./libraries:s14"></a>A <tt><i>library-body</i></tt> contains definitions of exported
identifiers, definitions of identifiers not intended for export, and
initialization expressions.
It consists of a (possibly empty) sequence of definitions followed by a
(possibly empty) sequence of initialization expressions.
When <tt>begin</tt>, <tt>let-syntax</tt>, or <tt>letrec-syntax</tt> forms
occur in a library body prior to the first expression, they are spliced
into the body.
Any body form may be produced by a syntactic extension, including
definitions, the splicing forms just mentioned, or initialization
expressions.
A library body is expanded in the same manner as a <tt>lambda</tt>
or other body (page&nbsp;<a href="./syntax.html#body-expansion">292</a>), and it expands into
the equivalent of a <tt>letrec*</tt> form so that the definitions
and initialization forms in the body are evaluated from left to right.

<p>
Each of the exports listed in a library's <tt>export</tt> form must either
be imported from another library or defined within the <tt><i>library-body</i></tt>,
in either case with the internal rather than the export name, if the two
differ.

<p>
Each identifier imported into or defined within a library must have
exactly one binding.
If imported into a library, it must not be defined in the library body,
and if defined in the library body, it must be defined only once.
If imported from two libraries, it must have the same binding in both
cases, which can happen only if the binding originates in one
of the two libraries and is reexported by the other or if the binding
originates in a third library and is reexported by both.

<p>
<a name="./libraries:s15"></a>The identifiers defined within a library and not exported by the
library are not visible in code that appears outside of the library.
A syntactic extension defined within a library may, however,
expand into a reference to such an identifier, so that the expanded
code does contain a reference to the identifier; this is referred
to as an <i>indirect export</i>.

<p>
<a name="./libraries:s16"></a>The exported variables of a library are <i>immutable</i> both inside the
library and outside, whether they are explicitly or implicitly exported.
It is a syntax violation if an explicitly exported variable appears on
the left-hand side of a <tt>set!</tt> expression within or outside of
the exporting library.
It is also a syntax violation if any other variable defined by a library
appears on the left-hand side of a <tt>set!</tt> expression and is
indirectly exported.

<p>
Libraries are loaded and the code contained within them evaluated on
an "as needed" basis by the implementation, as determined by the
import relationships among libraries.
A library's transformer expressions (the expressions on the right-hand
sides of a library body's <tt>define-syntax</tt> forms) may be evaluated
at different times from the library's body expressions (the expressions on
the right-hand side of the body's <tt>define</tt> forms, plus
initialization expressions).
At a minimum, the transformer expressions of a library must be evaluated
when (if not before) a reference to one of the library's exported keywords
is found while expanding another library or top-level program, and the
body expressions must be evaluated when (if not before) a reference to one
of the library's exported variables is evaluated, which may occur either
when a program using the library is run or when another library or
top-level program is being expanded, if the reference is evaluated by a
transformer called during the expansion process.
An implementation may evaluate a library's transformer and body expressions
as many times as it pleases in the process of expanding other libraries.
In particular, it may evaluate the expressions zero times if they are not
actually needed, exactly one time, or one time for each meta level of the
expansion.
It is generally a bad idea for the evaluation of a library's transformer
or body expressions to involve externally visible side effects, e.g.,
popping up a window, since the time or times at which these side effects
occur is unspecified.
Localized effects that affect only the library's initialization,
e.g., to create a table used by the library, are generally okay.

<p>
Examples are given in Section&nbsp;<a href="./libraries.html#g146">10.4</a>.

<p>

<h3><a name="g145"></a><a name="./libraries:h3"></a>Section 10.3. Top-Level Programs<a name="SECTLIBPROGRAMS"></a></h3>



<p>
A top-level program is not a syntactic form per se but rather a
set of forms that are usually delimited only by file boundaries.
Top-level programs can be thought of as library forms without the
<tt>library</tt> wrapper, library name, and export form.
The other difference is that definitions and expressions can
be intermixed within the body of a top-level program but not
within the body of a library.
Thus the syntax of a top-level program is, simply, an <tt>import</tt>
form followed by a sequence of definitions and expressions:

<p>

<p><tt>(import&nbsp;<i>import-spec</i>&nbsp;...)<br>

<i>definition-or-expression</i><br>

...</tt>
<p>An expression that appears within a top-level program body before
one or more definitions is treated as if it appeared on
the right-hand side of a definition for a dummy variable that is not
visible anywhere within the program.


<p>
<a name="./libraries:s17"></a><span class=formdef><b>procedure</b>: <tt>(command-line)</tt></span>
<br>
<b>returns: </b>a list of strings representing command-line arguments
<br>
<b>libraries: </b><tt>(rnrs&nbsp;programs)</tt>, <tt>(rnrs)</tt>

<p>This procedure may be used within a top-level program to obtain a list
of the command-line arguments passed to the program.

<p>
<a name="./libraries:s18"></a><span class=formdef><b>procedure</b>: <tt>(exit)</tt></span>
<br>
<span class=formdef><b>procedure</b>: <tt>(exit&nbsp;<i>obj</i>)</tt></span>
<br>
<b>returns: </b>does not return
<br>
<b>libraries: </b><tt>(rnrs&nbsp;programs)</tt>, <tt>(rnrs)</tt>

<p>This procedure may be used to exit from a top-level program to the
operating system.
If no <tt><i>obj</i></tt> is given, the exit value returned to the operating
system should indicate a normal exit.
If <tt><i>obj</i></tt> is false, the exit value returned to the operating
system should indicate an abnormal exit.
Otherwise, <tt><i>obj</i></tt> is translated into an exit value as
appropriate for the operating system.



<p>

<h3><a name="g146"></a><a name="./libraries:h4"></a>Section 10.4. Examples<a name="SECTLIBEXAMPLES"></a></h3>



<p>
The example below demonstrates several features of the <tt>library</tt> syntax.
It defines "Version 1" of the <tt>(list-tools&nbsp;setops)</tt> library, which
exports two keywords and several variables.
The library imports the <tt>(rnrs&nbsp;base)</tt> library, which provides
everything it needs except the <tt>member</tt> procedure, which it imports
from <tt>(rnrs&nbsp;lists)</tt>.
Most of the variables exported by the library are bound to procedures,
which is typical.

<p>
The syntactic extension <tt>set</tt> expands into a reference to the variable
<tt>list-&gt;set</tt>, and <tt>member?</tt> similarly expands into a reference
to the variable <tt>$member?</tt>.
While <tt>list-&gt;set</tt> is explicitly exported, <tt>$member?</tt> is not.
This makes <tt>$member?</tt> an indirect export.
The procedure <tt>u-d-help</tt> is not explicitly exported, and
since neither of the exported syntactic extensions expand into references
to <tt>u-d-help</tt>, it is not indirectly exported either.
This means it could be assigned, but it is not assigned in this example.

<p>

<p><tt>(library&nbsp;(list-tools&nbsp;setops&nbsp;(1))<br>

&nbsp;&nbsp;(export&nbsp;set&nbsp;empty-set&nbsp;empty-set?&nbsp;list-&gt;set&nbsp;set-&gt;list<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;union&nbsp;intersection&nbsp;difference&nbsp;member?)<br>

&nbsp;&nbsp;(import&nbsp;(rnrs&nbsp;base)&nbsp;(only&nbsp;(rnrs&nbsp;lists)&nbsp;member))
<br>
<br>
&nbsp;&nbsp;(define-syntax&nbsp;set<br>

&nbsp;&nbsp;&nbsp;&nbsp;(syntax-rules&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;x&nbsp;...)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(list-&gt;set&nbsp;(list&nbsp;x&nbsp;...))]))
<br>
<br>
&nbsp;&nbsp;(define&nbsp;empty-set&nbsp;'())
<br>
<br>
&nbsp;&nbsp;(define&nbsp;empty-set?&nbsp;null?)
<br>
<br>
&nbsp;&nbsp;(define&nbsp;list-&gt;set<br>

&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(ls)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cond<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(null?&nbsp;ls)&nbsp;'()]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(member&nbsp;(car&nbsp;ls)&nbsp;(cdr&nbsp;ls))&nbsp;(list-&gt;set&nbsp;(cdr&nbsp;ls))]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[else&nbsp;(cons&nbsp;(car&nbsp;ls)&nbsp;(list-&gt;set&nbsp;(cdr&nbsp;ls)))])))
<br>
<br>
&nbsp;&nbsp;(define&nbsp;set-&gt;list&nbsp;(lambda&nbsp;(set)&nbsp;set))
<br>
<br>
&nbsp;&nbsp;(define&nbsp;u-d-help<br>

&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(s1&nbsp;s2&nbsp;ans)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;f&nbsp;([s1&nbsp;s1])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cond<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(null?&nbsp;s1)&nbsp;ans]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(member?&nbsp;(car&nbsp;s1)&nbsp;s2)&nbsp;(f&nbsp;(cdr&nbsp;s1))]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[else&nbsp;(cons&nbsp;(car&nbsp;s1)&nbsp;(f&nbsp;(cdr&nbsp;s1)))]))))
<br>
<br>
&nbsp;&nbsp;(define&nbsp;union<br>

&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(s1&nbsp;s2)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(u-d-help&nbsp;s1&nbsp;s2&nbsp;s2)))
<br>
<br>
&nbsp;&nbsp;(define&nbsp;intersection<br>

&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(s1&nbsp;s2)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cond<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(null?&nbsp;s1)&nbsp;'()]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(member?&nbsp;(car&nbsp;s1)&nbsp;s2)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cons&nbsp;(car&nbsp;s1)&nbsp;(intersection&nbsp;(cdr&nbsp;s1)&nbsp;s2))]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[else&nbsp;(intersection&nbsp;(cdr&nbsp;s1)&nbsp;s2)])))
<br>
<br>
&nbsp;&nbsp;(define&nbsp;difference<br>

&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(s1&nbsp;s2)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(u-d-help&nbsp;s1&nbsp;s2&nbsp;'())))
<br>
<br>
&nbsp;&nbsp;(define&nbsp;member-help?<br>

&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(x&nbsp;s)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(and&nbsp;(member&nbsp;x&nbsp;s)&nbsp;#t)))
<br>
<br>
&nbsp;&nbsp;(define-syntax&nbsp;member?<br>

&nbsp;&nbsp;&nbsp;&nbsp;(syntax-rules&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;elt-expr&nbsp;set-expr)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([x&nbsp;elt-expr]&nbsp;[s&nbsp;set-expr])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(and&nbsp;(not&nbsp;(null?&nbsp;s))&nbsp;(member-help?&nbsp;x&nbsp;s)))])))</tt>
<p>The next library, <tt>(more-setops)</tt>, defines a few additional
set operations in terms of the <tt>(list-tools&nbsp;setops)</tt> operations.
No version is included in the library reference to
<tt>(list-tools&nbsp;setops)</tt>; this is equivalent to an empty version
reference, which matches any version.
The <tt>quoted-set</tt> keyword is interesting because its transformer
references <tt>list-&gt;set</tt> from <tt>(list-tools&nbsp;setops)</tt> at
expansion time.
As a result, if another library or top-level program that imports from
<tt>(more-setops)</tt> references <tt>quoted-set</tt>, the run-time
expressions of the <tt>(list-tools&nbsp;setops)</tt> library will have to
be evaluated when the other library or top-level program is expanded.
On the other hand, the run-time expressions of the
<tt>(list-tools&nbsp;setops)</tt> library need not be evaluated when
the <tt>(more-setops)</tt> library is itself expanded.

<p>

<p><tt>(library&nbsp;(more-setops)<br>

&nbsp;&nbsp;(export&nbsp;quoted-set&nbsp;set-cons&nbsp;set-remove)<br>

&nbsp;&nbsp;(import&nbsp;(list-tools&nbsp;setops)&nbsp;(rnrs&nbsp;base)&nbsp;(rnrs&nbsp;syntax-case))
<br>
<br>
&nbsp;&nbsp;(define-syntax&nbsp;quoted-set<br>

&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(syntax-case&nbsp;x&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(k&nbsp;elt&nbsp;...)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#`(quote<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#,(datum-&gt;syntax&nbsp;#'k<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(list-&gt;set<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(syntax-&gt;datum&nbsp;#'(elt&nbsp;...)))))])))
<br>
<br>
&nbsp;&nbsp;(define&nbsp;set-cons<br>

&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(opt&nbsp;optset)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(union&nbsp;(set&nbsp;opt)&nbsp;optset)))
<br>
<br>
&nbsp;&nbsp;(define&nbsp;set-remove<br>

&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(opt&nbsp;optset)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(difference&nbsp;optset&nbsp;(set&nbsp;opt)))))</tt>
<p>If the implementation does not automatically infer when bindings need to
be made available, the <tt>import</tt> form in the <tt>(more-setops)</tt>
library must be modified to specify at which meta levels the bindings it
imports are used via the <tt>for</tt> <tt><i>import-spec</i></tt> syntax as follows:

<p>

<p><tt>(import<br>

&nbsp;&nbsp;(for&nbsp;(list-tools&nbsp;setops)&nbsp;expand&nbsp;run)<br>

&nbsp;&nbsp;(for&nbsp;(rnrs&nbsp;base)&nbsp;expand&nbsp;run)<br>

&nbsp;&nbsp;(for&nbsp;(rnrs&nbsp;syntax-case)&nbsp;expand))</tt>
<p>To complete the example, the short top-level program below exercises
several of the <tt>(list-tools&nbsp;setops)</tt> and <tt>(more-setops)</tt>
exports.

<p>

<p><tt>(import&nbsp;(list-tools&nbsp;setops)&nbsp;(more-setops)&nbsp;(rnrs))<br>

(define-syntax&nbsp;pr<br>

&nbsp;&nbsp;(syntax-rules&nbsp;()&nbsp;<br>

&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;obj)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(begin<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(write&nbsp;'obj)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(display&nbsp;"&nbsp;;=&gt;&nbsp;")<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(write&nbsp;obj)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(newline))]))<br>

(define&nbsp;get-set1<br>

&nbsp;&nbsp;(lambda&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;(quoted-set&nbsp;a&nbsp;b&nbsp;c&nbsp;d)))<br>

(define&nbsp;set1&nbsp;(get-set1))<br>

(define&nbsp;set2&nbsp;(quoted-set&nbsp;a&nbsp;c&nbsp;e))
<br>
<br>
(pr&nbsp;(list&nbsp;set1&nbsp;set2))<br>

(pr&nbsp;(eq?&nbsp;(get-set1)&nbsp;(get-set1)))<br>

(pr&nbsp;(eq?&nbsp;(get-set1)&nbsp;(set&nbsp;'a&nbsp;'b&nbsp;'c&nbsp;'d)))<br>

(pr&nbsp;(union&nbsp;set1&nbsp;set2))<br>

(pr&nbsp;(intersection&nbsp;set1&nbsp;set2))<br>

(pr&nbsp;(difference&nbsp;set1&nbsp;set2))<br>

(pr&nbsp;(set-cons&nbsp;'a&nbsp;set2))<br>

(pr&nbsp;(set-cons&nbsp;'b&nbsp;set2))<br>

(pr&nbsp;(set-remove&nbsp;'a&nbsp;set2))</tt>
<p>What running this program should print is left as an exercise for the
reader.

<p>
Additional library and top-level program examples are given in
Chapter&nbsp;<a href="./examples.html#g151">12</a>.




<hr class=copyright align=left>
<p>
R. Kent Dybvig / <it>The Scheme Programming Language, Fourth Edition</it><br>
Copyright &copy; 2009 <a class=plain href="http://mitpress.mit.edu/catalog/item/default.asp?ttype=2&tid=11984">The MIT Press</a>.  Electronically reproduced by permission.<br>
Illustrations &copy; 2009 <a class=plain href="http://hebert.kitp.ucsb.edu/">Jean-Pierre H&eacute;bert</a><br>
ISBN 978-0-262-51298-5 / LOC QA76.73.S34D93<br>
<a class=plain href="http://mitpress.mit.edu/catalog/item/default.asp?ttype=2&tid=11984">to order this book</a> / <a class=plain href="canned/about.html">about this book</a>
</p>
<p><a class=plain href="http://www.scheme.com">http://www.scheme.com</a></p>
</body>
</html>
