<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
  "http://www.w3.org/TR/html4/loose.dtd"><!-- DO NOT EDIT THIS FILE-->
<!-- Edit the .tex version instead-->

<html>
<head>
<title>继续深入</title>
<link href="tspl.css" rel="stylesheet" type="text/css">
</head>
<body>
<a name="g49"></a>
<a name="./further:h0"></a>

<div style="font-size: 12px; width: 500px; height: 500px; border: solid thin">
<img style="padding: 20px 10px 20px 20px" src="canned/ch3.png"><img src="canned/jph.png">
</div>
<h1>第三章. 继续深入<a name="CHPTGOINGFURTHER"></a></h1>





<p>前一章已经提供了一组少量且非常有用的原始语法形式和过程，运用它们你已经可以开始编写Scheme程序。
这一章将介绍一些编写更复杂、更有效率的程序所需的附加特性和编程技术。

<p>

<h3><a name="g50"></a><a name="./further:h1"></a>3.1. 语法扩展<a name="SECTGFSYNTAX"></a></h3>



<p>
  在第<a href="./start.html#g21">2.5</a>节我们看到，<tt>let</tt> 语法形式只是一个 <i>语法扩展</i>，
  它是由两个<a name="./further:s0"></a>核心语法形式：“<tt>lambda</tt>表达式”、“过程应用”构成的。
  现在你可能想了解，哪些 <a name="./further:s1"></a>语法形式时核心语法形式，哪些是 <a name="./further:s2"></a>语法扩展，并且新的语法扩展是如何定义出来的。这一节会回答这些问题。

<p>
  实际上，并没有必要严格区分核心语法形式和语法扩展，因为一旦定义了一个语法扩展，它和核心语法形式就没有什么区别了。
尽管如此，划清界限能让我们更容易理解这门语言，因为这样我们能够集中注意力在核心形式上，并且理解其它所有由它们产生出来的（语法扩展）。
  
<p>
  作为一个Scheme的实现，是<i>有必要</i>区分核心形式和语法扩展的。
  
  Scheme实现在编译或解释时的第一个步骤就是 <a name="./further:s3"></a>展开语法扩展成为核心形式，
  以使编译器或者解释器去专心应对核心形式。
  但是展开之后剩下的被编译器或解释器直接处理的核心形式集合，是实现相关的，
  所以可能会和这里所描述的核心形式集合有所出入。

<p>
  虽然选定任何一组声明作为核心形式，都可能能够导出其他所有的语法形式，
  我们还是来讨论一下这个语言特定的一组核心形式。
  这组核心形式是在满足条件的组合中选出的最简组合。

<p>
  这组核心语法形式包括：顶层 <tt>define</tt> 形式、
  常量、变量、过程应用、
  <a name="./further:s4"></a><a name="./further:s5"></a><tt>引用（quote）</tt> 表达式、
<a name="./further:s6"></a><tt>lambda</tt> 表达式、
<a name="./further:s7"></a><tt>if</tt> 表达式、
和 <a name="./further:s8"></a><tt>set!</tt> 表达式。
下面描述的语法就是这些定义和表达式的核心语法。
在语法描述中，竖线 (&nbsp;|&nbsp;) 分割可选项；
星号 (&nbsp;*&nbsp;) 表示后面的内容会出现0次或多次；
&lt;variable&gt; 是任意的Scheme标识符；
&lt;datum&gt; 是任意的Scheme对象，比如数值、列表、符号或向量；
&lt;boolean&gt; 是 <tt>#t</tt> 或 <tt>#f</tt>；
&lt;number&gt; 是任意数值；
&lt;character&gt; 是任意字符
&lt;string&gt; 是任意字符串。
数值、字符串、列表、符号和布尔值的示例我们都见过了。
关于这些对象和更多其他对象的对象级语法可以参考<a href="./objects.html#g106">第六章</a>或者<a href="./grammar.html#APPENDIXFORMALSYNTAX">第455页</a>开头的形式语法描述。

<p>

  <table><tr><td nowrap>
&lt;program&gt;</td><td align=center><img src="math/tspl/8.gif" alt="<graphic>"></td><td nowrap>&lt;form&gt;*</td></tr><tr><td nowrap>
&lt;form&gt;</td><td align=center><img src="math/tspl/8.gif" alt="<graphic>"></td><td nowrap>&lt;definition&gt; | &lt;expression&gt; </td></tr><tr><td nowrap>
&lt;definition&gt;</td><td align=center><img src="math/tspl/8.gif" alt="<graphic>"></td><td nowrap>&lt;variable definition&gt; | <tt>(begin</tt> &lt;definition&gt;*<tt>)</tt> </td></tr><tr><td nowrap>
&lt;variable definition&gt;</td><td align=center><img src="math/tspl/8.gif" alt="<graphic>"></td><td nowrap><tt>(define</tt> &lt;variable&gt; &lt;expression&gt;<tt>)</tt> </td></tr><tr><td nowrap>
&lt;expression&gt;</td><td align=center><img src="math/tspl/8.gif" alt="<graphic>"></td><td nowrap>&lt;constant&gt; </td></tr><tr><td nowrap>
      </td><td align=center>|</td><td nowrap>&lt;variable&gt; </td></tr><tr><td nowrap>
      </td><td align=center>|</td><td nowrap><tt>(quote</tt> &lt;datum&gt;<tt>)</tt> </td></tr><tr><td nowrap>
      </td><td align=center>|</td><td nowrap><tt>(lambda</tt> &lt;formals&gt; &lt;expression&gt; &lt;expression&gt;*<tt>)</tt> </td></tr><tr><td nowrap>
      </td><td align=center>|</td><td nowrap><tt>(if</tt> &lt;expression&gt; &lt;expression&gt; &lt;expression&gt;<tt>)</tt> </td></tr><tr><td nowrap>
      </td><td align=center>|</td><td nowrap><tt>(set!</tt> &lt;variable&gt; &lt;expression&gt;<tt>)</tt> </td></tr><tr><td nowrap>
      </td><td align=center>|</td><td nowrap>&lt;application&gt; </td></tr><tr><td nowrap>
&lt;constant&gt;</td><td align=center><img src="math/tspl/8.gif" alt="<graphic>"></td><td nowrap>&lt;boolean&gt; | &lt;number&gt; | &lt;character&gt; | &lt;string&gt; </td></tr><tr><td nowrap>
&lt;formals&gt;</td><td align=center><img src="math/tspl/8.gif" alt="<graphic>"></td><td nowrap>&lt;variable&gt; </td></tr><tr><td nowrap>
       </td><td align=center>|</td><td nowrap><tt>(</tt>&lt;variable&gt;*<tt>)</tt> </td></tr><tr><td nowrap>
       </td><td align=center>|</td><td nowrap><tt>(</tt>&lt;variable&gt; &lt;variable&gt;* <tt>.</tt> &lt;variable&gt;<tt>)</tt> </td></tr><tr><td nowrap>
&lt;application&gt;</td><td align=center><img src="math/tspl/8.gif" alt="<graphic>"></td><td nowrap><tt>(</tt>&lt;expression&gt; &lt;expression&gt;*<tt>)</tt>
</td></tr></table>

<p>
这套语法是有歧义的，过程应用(application)和<tt>quote</tt>、<tt>lambda</tt>、
<tt>if</tt>、<tt>set!</tt>表达式的语法形式会产生冲突。

因此作为(对过程应用application的)限制，第一个 &lt;expression&gt;必须是这些关键词之外的表达式，
除非这个关键词被重定义或局部绑定(locally bound)过。

<p>
The <a name="./further:s9"></a>"defun" syntax for <tt>define</tt> given in
Section&nbsp;<a href="./start.html#g25">2.6</a>
is not included in the core, since definitions in that form are
straightforwardly translated into the simpler <tt>define</tt> syntax.
Similarly, the core syntax for <tt>if</tt> does not permit the
<tt><i>alternative</i></tt> to be omitted, as did one example in
Section&nbsp;<a href="./start.html#g40">2.9</a>.
An <tt>if</tt> expression lacking an <tt><i>alternative</i></tt> can be translated
into the core syntax for <tt>if</tt> merely by replacing the missing
subexpression with an arbitrary constant, such as <tt>#f</tt>.

<p>
A <a name="./further:s10"></a><tt>begin</tt> that contains only definitions
is considered to be a
definition in the grammar; this is permitted in order to allow
syntactic extensions to expand into more than one definition.
<tt>begin</tt> expressions, i.e., <tt>begin</tt> forms containing expressions,
are not considered core forms.
A <tt>begin</tt> expression of the form

<p>

<p><tt>(begin&nbsp;<i>e<sub>1</sub></i>&nbsp;<i>e<sub>2</sub></i>&nbsp;...)</tt>
<p>is equivalent to the <tt>lambda</tt> application

<p>

<p><tt>((lambda&nbsp;()&nbsp;<i>e<sub>1</sub></i>&nbsp;<i>e<sub>2</sub></i>&nbsp;...))</tt>
<p>and hence need not be considered core.

<p>
<a name="./further:s11"></a>Now that we have established
a set of core syntactic forms, let's turn to a discussion of
<a name="./further:s12"></a>syntactic extensions.
Syntactic extensions are so called because they extend the syntax of Scheme
beyond the core syntax.
All syntactic extensions in a Scheme program must ultimately
be derived from the core forms.
One syntactic extension, however, may be defined
in terms of another syntactic extension, as long as the latter
is in some sense "closer" to the core syntax.
Syntactic forms may appear anywhere an expression or definition is
expected, as long as the extended form expands into a definition or
expression as appropriate.

<p>
Syntactic extensions are defined with <a name="./further:s13"></a><tt>define-syntax</tt>.
<tt>define-syntax</tt> is similar to <tt>define</tt>, except that <tt>define-syntax</tt> associates
a syntactic transformation procedure, or <a name="./further:s14"></a><i>transformer</i>, with
a <a name="./further:s15"></a>keyword (such as <tt>let</tt>), rather than associating a value with
a variable.
Here is how we might define <tt>let</tt> with <tt>define-syntax</tt>.

<p>

<p><tt>(define-syntax&nbsp;let<br>

&nbsp;&nbsp;(syntax-rules&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;((x&nbsp;e)&nbsp;...)&nbsp;b1&nbsp;b2&nbsp;...)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((lambda&nbsp;(x&nbsp;...)&nbsp;b1&nbsp;b2&nbsp;...)&nbsp;e&nbsp;...)]))</tt>
<p>The identifier appearing after <tt>define-syntax</tt> is the name, or keyword,
of the syntactic extension being defined, in this case <tt>let</tt>.
The <tt>syntax-rules</tt> form is an expression that evaluates to a
transformer.
The item following <tt>syntax-rules</tt> is a list of
<a name="./further:s16"></a><i>auxiliary keywords</i> and is nearly always <tt>()</tt>.
An example of an auxiliary keyword is the <tt>else</tt> of <tt>cond</tt>.
(Other examples requiring the use of auxiliary keywords are given in
Chapter&nbsp;<a href="./syntax.html#g133">8</a>.)
Following the list of auxiliary keywords is a sequence of one or more
<i>rules</i>, or <i>pattern/template</i> pairs.
Only one rule appears in our definition of <tt>let</tt>.
The pattern part of a rule specifies the form that the input must take,
and the template specifies to what the input should be transformed.

<p>
The pattern should always be a structured expression whose first element
is an <a name="./further:s17"></a>underscore (&nbsp;<tt>_</tt>&nbsp;)<a name="./further:s18"></a>.
(As we will see in Chapter&nbsp;<a href="./syntax.html#g133">8</a>, the use of <tt>_</tt> is only a
convention, but it is a good one to follow.)
If more than one rule is present, the appropriate one
is chosen by matching the patterns, in order, against the input during
expansion.
It is a syntax violation if none of the patterns match the input.

<p>
Identifiers other than an underscore or ellipsis appearing within a
pattern are <a name="./further:s19"></a><i>pattern variables</i>, unless they
are listed as auxiliary keywords.
Pattern variables match any substructure and are bound to that
substructure within the corresponding template.
<a name="./further:s20"></a><a name="./further:s21"></a>The notation
<tt><i>pat</i>&nbsp;...</tt> in the pattern allows for zero or more
expressions matching the ellipsis prototype <tt><i>pat</i></tt> in the input.
Similarly, the notation <tt><i>expr</i>&nbsp;...</tt> in the template produces
zero or more expressions from the ellipsis prototype <tt><i>expr</i></tt> in the output.
The number of <tt><i>pat</i></tt>s in the input determines the number of <tt><i>expr</i></tt>s
in the output; in order for this to work, any ellipsis prototype in the
template must contain at least one pattern variable from an ellipsis
prototype in the pattern.

<p>
The single rule in our definition of <tt>let</tt> should be fairly
self-explanatory, but a few points are worth mentioning.
First, the syntax of <tt>let</tt> requires that the body contain at least one
form; hence, we have specified <tt>b1&nbsp;b2&nbsp;...</tt> instead of
<tt>b&nbsp;...</tt>, which might seem more natural.
On the other hand, <tt>let</tt> does not require that there be at least one
variable/value pair, so we were able to use, simply, <tt>(x&nbsp;e)&nbsp;...</tt>.
Second, the pattern variables <tt>x</tt> and <tt>e</tt>, though together within
the same prototype in the pattern, are separated in the template; any sort
of rearrangement or recombination is possible.
Finally, the three pattern variables <tt>x</tt>, <tt>e</tt>, and <tt>b2</tt> that
appear in ellipsis prototypes in the pattern also appear in ellipsis
prototypes in the template.
This is not a coincidence; it is a requirement.
In general, if a pattern variable appears within an ellipsis prototype in
the pattern, it cannot appear outside an ellipsis prototype in the template.

<p>
The definition of <a name="./further:s22"></a><tt>and</tt> below is somewhat more complex than the
one for <tt>let</tt>.

<p>

<p><tt>(define-syntax&nbsp;and<a name="defn:and"></a><br>

&nbsp;&nbsp;(syntax-rules&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;[(_)&nbsp;#t]<br>

&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;e)&nbsp;e]<br>

&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;e1&nbsp;e2&nbsp;e3&nbsp;...)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;e1&nbsp;(and&nbsp;e2&nbsp;e3&nbsp;...)&nbsp;#f)]))</tt>
<p>This definition is recursive and involves more than one rule.
Recall that <tt>(and)</tt> evaluates to <tt>#t</tt>; the first rule takes care of
this case.
The second and third rules specify the base case and recursion steps
of the recursion and together translate <tt>and</tt> expressions with
two or more subexpressions into nested <tt>if</tt> expressions.
For example, <tt>(and&nbsp;a&nbsp;b&nbsp;c)</tt> expands first into

<p>

<p><tt>(if&nbsp;a&nbsp;(and&nbsp;b&nbsp;c)&nbsp;#f)</tt>
<p>then

<p>

<p><tt>(if&nbsp;a&nbsp;(if&nbsp;b&nbsp;(and&nbsp;c)&nbsp;#f)&nbsp;#f)</tt>
<p>and finally

<p>

<p><tt>(if&nbsp;a&nbsp;(if&nbsp;b&nbsp;c&nbsp;#f)&nbsp;#f)</tt>
<p>With this expansion, if <tt>a</tt> and <tt>b</tt> evaluate to a true value, then the value
is the value of <tt>c</tt>, otherwise <tt>#f</tt>, as desired.

<p>
The version of <tt>and</tt> below is simpler but, unfortunately,
incorrect.

<p>

<p><tt>(define-syntax&nbsp;and&nbsp;;&nbsp;incorrect!<br>

&nbsp;&nbsp;(syntax-rules&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;[(_)&nbsp;#t]<br>

&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;e1&nbsp;e2&nbsp;...)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;e1&nbsp;(and&nbsp;e2&nbsp;...)&nbsp;#f)]))</tt>
<p>The expression

<p>

<p><tt>(and&nbsp;(not&nbsp;(=&nbsp;x&nbsp;0))&nbsp;(/&nbsp;1&nbsp;x))</tt>
<p>should return the value of <tt>(/&nbsp;1&nbsp;x)</tt> when <tt>x</tt>
is not zero.
With the incorrect version of <tt>and</tt>, the expression expands
as follows.

<p>

<p><tt>(if&nbsp;(not&nbsp;(=&nbsp;x&nbsp;0))&nbsp;(and&nbsp;(/&nbsp;1&nbsp;x))&nbsp;#f)&nbsp;<img src="math/tspl/9.gif" alt="<graphic>"><br>

&nbsp;&nbsp;(if&nbsp;(not&nbsp;(=&nbsp;x&nbsp;0))&nbsp;(if&nbsp;(/&nbsp;1&nbsp;x)&nbsp;(and)&nbsp;#f)&nbsp;#f)&nbsp;<img src="math/tspl/9.gif" alt="<graphic>"><br>

&nbsp;&nbsp;(if&nbsp;(not&nbsp;(=&nbsp;x&nbsp;0))&nbsp;(if&nbsp;(/&nbsp;1&nbsp;x)&nbsp;#t&nbsp;#f)&nbsp;#f)</tt>
<p>The final answer if <tt>x</tt> is not zero is <tt>#t</tt>, not the
value of <tt>(/&nbsp;1&nbsp;x)</tt>.

<p>
The definition of <a name="./further:s23"></a><tt>or</tt> below is similar to the one for <tt>and</tt> except
that a temporary variable must be introduced for each intermediate
value so that we can both test the value and return it if it is a
true value.
(A temporary variable is not needed for <tt>and</tt> since there is only one
false value, <tt>#f</tt>.)

<p>

<p><tt>(define-syntax&nbsp;or<a name="defn:or"></a><br>

&nbsp;&nbsp;(syntax-rules&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;[(_)&nbsp;#f]<br>

&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;e)&nbsp;e]<br>

&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;e1&nbsp;e2&nbsp;e3&nbsp;...)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([t&nbsp;e1])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;t&nbsp;t&nbsp;(or&nbsp;e2&nbsp;e3&nbsp;...)))]))</tt>
<p>Like variables bound by <tt>lambda</tt> or <tt>let</tt>, identifiers introduced
by a template are <a name="./further:s24"></a>lexically scoped, i.e., visible only within
expressions introduced by the template.
Thus, even if one of the expressions <tt>e2&nbsp;e3&nbsp;...</tt> contains a reference
to <tt>t</tt>, the introduced binding for <tt>t</tt> does not "capture" those
references.
This is typically accomplished via automatic renaming of introduced
identifiers.

<p>
As with the simpler version of <tt>and</tt> given above, the simpler
version of <tt>or</tt> below is incorrect.

<p>

<p><tt>(define-syntax&nbsp;or&nbsp;;&nbsp;incorrect!<br>

&nbsp;&nbsp;(syntax-rules&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;[(_)&nbsp;#f]<br>

&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;e1&nbsp;e2&nbsp;...)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([t&nbsp;e1])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;t&nbsp;t&nbsp;(or&nbsp;e2&nbsp;...)))]))</tt>
<p>The reason is more subtle, however, and is the subject of
Exercise&nbsp;<a href="./further.html#g61">3.2.6</a>.

<p>

<h4>Exercise <a name="g51"></a>3.1.1</h4>
<a name="./further:s25"></a>Write out the expansion steps necessary to expand

<p>

<p><tt>(let&nbsp;([x&nbsp;(memv&nbsp;'a&nbsp;ls)])<br>

&nbsp;&nbsp;(and&nbsp;x&nbsp;(memv&nbsp;'b&nbsp;x)))</tt>
<p>into core forms.

<p>


<p>

<h4>Exercise <a name="g52"></a>3.1.2</h4>
<a name="./further:s26"></a>Write out the expansion steps necessary to expand

<p>

<p><tt>(or&nbsp;(memv&nbsp;x&nbsp;'(a&nbsp;b&nbsp;c))&nbsp;(list&nbsp;x))</tt>
<p>

<p>
into core forms.

<p>

<h4>Exercise <a name="g53"></a>3.1.3</h4>
<a name="./further:s27"></a><a name="./further:s28"></a><tt>let*</tt> is similar to <tt>let</tt> but evaluates its bindings
in sequence.
Each of the right-hand-side expressions is within the scope of
the earlier bindings.

<p>

<p><tt>(let*&nbsp;([a&nbsp;5]&nbsp;[b&nbsp;(+&nbsp;a&nbsp;a)]&nbsp;[c&nbsp;(+&nbsp;a&nbsp;b)])<br>

&nbsp;&nbsp;(list&nbsp;a&nbsp;b&nbsp;c))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(5&nbsp;10&nbsp;15)</tt>
<p><tt>let*</tt> can be implemented as nested <tt>let</tt> expressions.
For example, the <tt>let*</tt> expression above is equivalent to the nested
<tt>let</tt> expressions below.

<p>

<p><tt>(let&nbsp;([a&nbsp;5])<br>

&nbsp;&nbsp;(let&nbsp;([b&nbsp;(+&nbsp;a&nbsp;a)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([c&nbsp;(+&nbsp;a&nbsp;b)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(list&nbsp;a&nbsp;b&nbsp;c))))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(5&nbsp;10&nbsp;15)</tt>
<p>Define <tt>let*</tt> with <tt>define-syntax</tt>.

<p>


<p>

<h4>Exercise <a name="g54"></a>3.1.4</h4>
<a name="./further:s29"></a>As we saw in Section&nbsp;<a href="./start.html#g40">2.9</a>,
it is legal to omit the third, or <i>alternative</i>, subexpression
of an <tt>if</tt> expression.
Doing so, however, often leads to confusion.
Scheme provides two syntactic forms,
<a name="./further:s30"></a><tt>when</tt> and <a name="./further:s31"></a><tt>unless</tt>,
that may be used in place of
such "one-armed" <tt>if</tt> expressions.

<p>

<p><tt>(when&nbsp;<i>test</i>&nbsp;<i>expr<sub>1</sub></i>&nbsp;<i>expr<sub>2</sub></i>&nbsp;...)<br>

(unless&nbsp;<i>test</i>&nbsp;<i>expr<sub>1</sub></i>&nbsp;<i>expr<sub>2</sub></i>&nbsp;...)</tt>
<p>With both forms, <tt>test</tt> is evaluated first.
For <tt>when</tt>, if <tt>test</tt> evaluates to true, the remaining
forms are evaluated in sequence as if enclosed in an implicit
<tt>begin</tt> expression.
If <tt>test</tt> evaluates to false, the remaining forms are not
evaluated, and the result is unspecified.
<tt>unless</tt> is similar except that
the remaining forms are evaluated only if <tt>test</tt>
evaluates to false.

<p>

<p><tt>(let&nbsp;([x&nbsp;3])<br>

&nbsp;&nbsp;(unless&nbsp;(=&nbsp;x&nbsp;0)&nbsp;(set!&nbsp;x&nbsp;(+&nbsp;x&nbsp;1)))<br>

&nbsp;&nbsp;(when&nbsp;(=&nbsp;x&nbsp;4)&nbsp;(set!&nbsp;x&nbsp;(*&nbsp;x&nbsp;2)))<br>

&nbsp;&nbsp;x)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;8</tt>
<p>Define <tt>when</tt> as a syntactic extension in terms of <tt>if</tt>
and <tt>begin</tt>, and define <tt>unless</tt>
in terms of <tt>when</tt>.

<p>


<p>

<h3><a name="g55"></a><a name="./further:h2"></a>Section 3.2. More Recursion<a name="SECTGFMORERECURSION"></a></h3>



<p>
<a name="./further:s32"></a>In Section&nbsp;<a href="./start.html#g32">2.8</a>, we saw how
to define recursive procedures using top-level definitions.
Before that, we saw how to create local bindings for procedures using
<a name="./further:s33"></a><tt>let</tt>.
It is natural to wonder whether a <tt>let</tt>-bound procedure can be
recursive.
The answer is no, at least not in a straightforward way.
If you try to evaluate the <a name="./further:s34"></a>expression

<p>

<p><tt>(let&nbsp;([sum&nbsp;(lambda&nbsp;(ls)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(null?&nbsp;ls)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(+&nbsp;(car&nbsp;ls)&nbsp;(sum&nbsp;(cdr&nbsp;ls)))))])<br>

&nbsp;&nbsp;(sum&nbsp;'(1&nbsp;2&nbsp;3&nbsp;4&nbsp;5)))</tt>
<p>it will probably raise an exception with a message to the effect that <tt>sum</tt> is
undefined.
This is because the variable <tt>sum</tt> is visible only within the body
of the <tt>let</tt> expression and not within the <tt>lambda</tt> expression
whose value is bound to <tt>sum</tt>.
We can get around this problem by passing the procedure <tt>sum</tt> to itself
as follows.

<p>

<p><tt>(let&nbsp;([sum&nbsp;(lambda&nbsp;(sum&nbsp;ls)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(null?&nbsp;ls)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(+&nbsp;(car&nbsp;ls)&nbsp;(sum&nbsp;sum&nbsp;(cdr&nbsp;ls)))))])<br>

&nbsp;&nbsp;(sum&nbsp;sum&nbsp;'(1&nbsp;2&nbsp;3&nbsp;4&nbsp;5)))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;15</tt>
<p>This works and is a clever solution, but there is an easier way,
using <a name="./further:s35"></a><tt>letrec</tt>.
Like <tt>let</tt>, the
<tt>letrec</tt> syntactic form includes a set of variable-value pairs,
along with a sequence of expressions referred to as the <i>body</i> of the
<tt>letrec</tt>.

<p>

<p><tt>(letrec&nbsp;((<i>var</i>&nbsp;<i>expr</i>)&nbsp;...)&nbsp;<i>body<sub>1</sub></i>&nbsp;<i>body<sub>2</sub></i>&nbsp;...)</tt>
<p>Unlike <tt>let</tt>, the variables <tt><i>var</i>&nbsp;...</tt> are visible not
only within the body of the <tt>letrec</tt> but also within
<tt><i>expr</i>&nbsp;...</tt>.
Thus, we can rewrite the expression above as follows.

<p>

<p><tt>(letrec&nbsp;([sum&nbsp;(lambda&nbsp;(ls)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(null?&nbsp;ls)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(+&nbsp;(car&nbsp;ls)&nbsp;(sum&nbsp;(cdr&nbsp;ls)))))])<br>

&nbsp;&nbsp;(sum&nbsp;'(1&nbsp;2&nbsp;3&nbsp;4&nbsp;5)))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;15</tt>
<p>Using <tt>letrec</tt>, we can also define <a name="./further:s36"></a>mutually recursive procedures, such
as the procedures <a name="./further:s37"></a><tt>even?</tt> and <a name="./further:s38"></a><tt>odd?</tt> that were the subject of
Exercise&nbsp;<a href="./start.html#g38">2.8.6</a>.

<p>

<p><tt>(letrec&nbsp;([even?<a name="defn:even?/odd?"></a><br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(or&nbsp;(=&nbsp;x&nbsp;0)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(odd?&nbsp;(-&nbsp;x&nbsp;1))))]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[odd?<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(and&nbsp;(not&nbsp;(=&nbsp;x&nbsp;0))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(even?&nbsp;(-&nbsp;x&nbsp;1))))])<br>

&nbsp;&nbsp;(list&nbsp;(even?&nbsp;20)&nbsp;(odd?&nbsp;20)))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(#t&nbsp;#f)</tt>
<p>In a <tt>letrec</tt> expression,
<tt><i>expr</i>&nbsp;...</tt> are most often <tt>lambda</tt> expressions,
though this need not be the case.
One restriction on the expressions must be obeyed, however.
It must be possible to evaluate each <tt><i>expr</i></tt> without
evaluating any of the variables <tt><i>var</i>&nbsp;...</tt>.
This restriction is always satisfied if the expressions are all
<tt>lambda</tt> expressions, since even though the variables may appear
within the <tt>lambda</tt> expressions, they cannot be evaluated until
the resulting procedures are invoked in the body of the <tt>letrec</tt>.
The following <tt>letrec</tt> expression obeys this restriction.

<p>

<p><tt>(letrec&nbsp;([f&nbsp;(lambda&nbsp;()&nbsp;(+&nbsp;x&nbsp;2))]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[x&nbsp;1])<br>

&nbsp;&nbsp;(f))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;3</tt>
<p>while the following does not.

<p>

<p><tt>(letrec&nbsp;([y&nbsp;(+&nbsp;x&nbsp;2)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[x&nbsp;1])<br>

&nbsp;&nbsp;y)</tt>
<p>In this case, an exception is raised indicating that <tt>x</tt> is not
defined where it is referenced.

<p>
We can use <tt>letrec</tt> to hide the definitions of "help" procedures
so that they do not clutter the top-level namespace.
This is demonstrated by the definition of <a name="./further:s39"></a><tt>list?</tt> below, which
follows the "<a name="./further:s40"></a>hare and tortoise" algorithm
outlined in Exercise&nbsp;<a href="./start.html#g48">2.9.8</a>.

<p>

<p><tt>(define&nbsp;list?<a name="defn:list?"></a><br>

&nbsp;&nbsp;(lambda&nbsp;(x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(letrec&nbsp;([race<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(h&nbsp;t)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(pair?&nbsp;h)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([h&nbsp;(cdr&nbsp;h)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(pair?&nbsp;h)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(and&nbsp;(not&nbsp;(eq?&nbsp;h&nbsp;t))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(race&nbsp;(cdr&nbsp;h)&nbsp;(cdr&nbsp;t)))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(null?&nbsp;h)))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(null?&nbsp;h)))])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(race&nbsp;x&nbsp;x))))</tt>
<p>When a recursive procedure is called in only one place outside
the procedure, as in the example above, it is often clearer to use
a <a name="./further:s41"></a><i>named</i> <tt>let</tt> expression.
Named <tt>let</tt> expressions take the following form.

<p>

<p><tt>(let&nbsp;<i>name</i>&nbsp;((<i>var</i>&nbsp;<i>expr</i>)&nbsp;...)<br>

&nbsp;&nbsp;<i>body<sub>1</sub></i>&nbsp;<i>body<sub>2</sub></i>&nbsp;...)</tt>
<p>Named <tt>let</tt> is similar to unnamed <tt>let</tt> in that it binds
the variables <tt><i>var</i>&nbsp;...</tt> to the values of
<tt><i>expr</i>&nbsp;...</tt> within
the body <tt><i>body<sub>1</sub></i>&nbsp;<i>body<sub>2</sub></i>&nbsp;...</tt>.
As with unnamed <tt>let</tt>, the variables are visible only within the
body and not within <tt><i>expr</i>&nbsp;...</tt>.
In addition, the variable <tt><i>name</i></tt> is bound within the body to
a procedure that may be called to recur; the arguments to
the procedure become the new values for the variables
<tt><i>var</i>&nbsp;...</tt>.

<p>
The definition of <a name="./further:s42"></a><tt>list?</tt> has been rewritten below to use named
<tt>let</tt>.

<p>

<p><tt>(define&nbsp;list?<br>

&nbsp;&nbsp;(lambda&nbsp;(x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;race&nbsp;([h&nbsp;x]&nbsp;[t&nbsp;x])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(pair?&nbsp;h)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([h&nbsp;(cdr&nbsp;h)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(pair?&nbsp;h)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(and&nbsp;(not&nbsp;(eq?&nbsp;h&nbsp;t))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(race&nbsp;(cdr&nbsp;h)&nbsp;(cdr&nbsp;t)))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(null?&nbsp;h)))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(null?&nbsp;h)))))</tt>
<p>Just as <tt>let</tt> can be expressed as a simple direct application
of a <tt>lambda</tt> expression to arguments, named <tt>let</tt> can be expressed
as the application of a recursive procedure to arguments.
A named <tt>let</tt> of the form

<p>

<p><tt>(let&nbsp;<i>name</i>&nbsp;((<i>var</i>&nbsp;<i>expr</i>)&nbsp;...)<br>

&nbsp;&nbsp;<i>body<sub>1</sub></i>&nbsp;<i>body<sub>2</sub></i>&nbsp;...)</tt>
<p>can be rewritten in terms of <tt>letrec</tt> as follows.

<p>

<p><tt>((letrec&nbsp;((<i>name</i>&nbsp;(lambda&nbsp;(<i>var</i>&nbsp;...)&nbsp;<i>body<sub>1</sub></i>&nbsp;<i>body<sub>2</sub></i>&nbsp;...)))<br>

&nbsp;&nbsp;&nbsp;<i>name</i>)<br>

&nbsp;<i>expr</i>&nbsp;...)</tt>
<p>Alternatively, it can be rewritten as

<p>

<p><tt>(letrec&nbsp;((<i>name</i>&nbsp;(lambda&nbsp;(<i>var</i>&nbsp;...)&nbsp;<i>body<sub>1</sub></i>&nbsp;<i>body<sub>2</sub></i>&nbsp;...)))<br>

&nbsp;&nbsp;(<i>name</i>&nbsp;<i>expr</i>&nbsp;...))</tt>
<p>provided that the variable <tt><i>name</i></tt> does not appear free within
<tt><i>expr</i>&nbsp;...</tt>.

<p>
As we discussed in Section&nbsp;<a href="./start.html#g32">2.8</a>, some recursion is
essentially <a name="./further:s43"></a>iteration and executes as such.
When a procedure call is in tail position (see below) with respect to
a <tt>lambda</tt>
expression, it is considered to be a <a name="./further:s44"></a><i>tail call</i>, and
Scheme systems must treat it <i>properly</i>, as a "goto"
or jump.
When a procedure tail-calls itself or calls itself indirectly
through a series of tail calls, the result is <a name="./further:s45"></a><i>tail recursion</i>.
Because tail calls are treated as jumps, tail recursion can be used
for indefinite iteration in place of the more restrictive iteration
constructs provided by other programming languages, without fear of
overflowing any sort of recursion stack.

<p>
A call is in tail position with respect to a <tt>lambda</tt> expression
if its value is returned directly from the <tt>lambda</tt> expression,
i.e., if nothing is left to do after the call but to return from the
<tt>lambda</tt> expression.
For example, a call is in tail position if
it is the last expression in the body of a <tt>lambda</tt> expression,
the <i>consequent</i> or <i>alternative</i> part of an <tt>if</tt> expression
in tail position,
the last subexpression of an <tt>and</tt> or <tt>or</tt> expression in tail
position,
the last expression in the body of a <tt>let</tt> or <tt>letrec</tt>
in tail position, etc.
Each of the calls to <tt>f</tt> in the expressions below
are tail calls, but the calls to <tt>g</tt> are not.

<p>

<p><tt>(lambda&nbsp;()&nbsp;(f&nbsp;(g)))<br>

(lambda&nbsp;()&nbsp;(if&nbsp;(g)&nbsp;(f)&nbsp;(f)))<br>

(lambda&nbsp;()&nbsp;(let&nbsp;([x&nbsp;4])&nbsp;(f)))<br>

(lambda&nbsp;()&nbsp;(or&nbsp;(g)&nbsp;(f)))</tt>
<p>In each case, the values of the calls to <tt>f</tt> are returned directly,
whereas the calls to <tt>g</tt> are not.

<p>
Recursion in general and named <tt>let</tt> in particular provide a natural
way to implement many algorithms, whether iterative, recursive, or
partly iterative and partly recursive; the programmer is not burdened
with two distinct mechanisms.

<p>
The following two definitions of <a name="./further:s46"></a><tt>factorial</tt> use named <tt>let</tt>
expressions to compute the factorial, <i>n</i>!, of a nonnegative integer <i>n</i>.
The first employs the recursive definition <i>n</i>! = <i>n</i> &times; (<i>n</i> - 1)!,
where 0! is defined to be 1.

<p>

<p><tt>(define&nbsp;factorial<br>

&nbsp;&nbsp;(lambda&nbsp;(n)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;fact&nbsp;([i&nbsp;n])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(=&nbsp;i&nbsp;0)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;i&nbsp;(fact&nbsp;(-&nbsp;i&nbsp;1)))))))</tt>
<p>
<p><tt>(factorial&nbsp;0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;1<br>

(factorial&nbsp;1)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;1<br>

(factorial&nbsp;2)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;2<br>

(factorial&nbsp;3)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;6<br>

(factorial&nbsp;10)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;3628800</tt>
<p>The second is an iterative version that employs the iterative definition
<i>n</i>! = <i>n</i> &times; (<i>n</i> - 1) &times; (<i>n</i> - 2) &times; ... &times; 1, using an accumulator,
<tt>a</tt>, to hold the intermediate products.

<p>

<p><tt>(define&nbsp;factorial<br>

&nbsp;&nbsp;(lambda&nbsp;(n)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;fact&nbsp;([i&nbsp;n]&nbsp;[a&nbsp;1])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(=&nbsp;i&nbsp;0)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(fact&nbsp;(-&nbsp;i&nbsp;1)&nbsp;(*&nbsp;a&nbsp;i))))))</tt>
<p><a name="fibonacci"></a>A similar problem is to compute the <i>n</i>th Fibonacci number for a given
<i>n</i>.
<a name="./further:s47"></a>The <a name="./further:s48"></a><i>Fibonacci numbers</i> are an infinite sequence of
integers, 0, 1, 1, 2, 3, 5, 8, etc., in which each
number is the sum of the two preceding numbers in the sequence.
A procedure to compute the <i>n</i>th Fibonacci number is most naturally
defined recursively as follows.

<p>

<p><tt>(define&nbsp;fibonacci<br>

&nbsp;&nbsp;(lambda&nbsp;(n)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;fib&nbsp;([i&nbsp;n])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cond<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(=&nbsp;i&nbsp;0)&nbsp;0]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(=&nbsp;i&nbsp;1)&nbsp;1]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[else&nbsp;(+&nbsp;(fib&nbsp;(-&nbsp;i&nbsp;1))&nbsp;(fib&nbsp;(-&nbsp;i&nbsp;2)))]))))
<br>
<br>
(fibonacci&nbsp;0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;0<br>

(fibonacci&nbsp;1)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;1<br>

(fibonacci&nbsp;2)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;1<br>

(fibonacci&nbsp;3)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;2<br>

(fibonacci&nbsp;4)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;3<br>

(fibonacci&nbsp;5)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;5<br>

(fibonacci&nbsp;6)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;8<br>

(fibonacci&nbsp;20)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;6765<br>

(fibonacci&nbsp;30)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;832040</tt>
<p>This solution requires the computation of the two preceding Fibonacci
numbers at each step and hence is <a name="./further:s49"></a><i>doubly recursive</i>.
For example, to compute <tt>(fibonacci&nbsp;4)</tt> requires the computation of both
<tt>(fib&nbsp;3)</tt> and <tt>(fib&nbsp;2)</tt>, to compute <tt>(fib&nbsp;3)</tt> requires computing
both <tt>(fib&nbsp;2)</tt> and <tt>(fib&nbsp;1)</tt>, and to compute <tt>(fib&nbsp;2)</tt> requires
computing both <tt>(fib&nbsp;1)</tt> and <tt>(fib&nbsp;0)</tt>.
This is very inefficient, and it becomes more inefficient as <tt>n</tt> grows.
A more efficient solution is to adapt the accumulator solution of the
<tt>factorial</tt> example above to use two accumulators, <tt>a1</tt> for the
current Fibonacci number and <tt>a2</tt> for the preceding one.

<p>

<p><tt>(define&nbsp;fibonacci<br>

&nbsp;&nbsp;(lambda&nbsp;(n)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(=&nbsp;n&nbsp;0)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;fib&nbsp;([i&nbsp;n]&nbsp;[a1&nbsp;1]&nbsp;[a2&nbsp;0])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(=&nbsp;i&nbsp;1)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a1<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(fib&nbsp;(-&nbsp;i&nbsp;1)&nbsp;(+&nbsp;a1&nbsp;a2)&nbsp;a1))))))</tt>
<p>Here, zero is treated as a special case, since there is no preceding value.
This allows us to use the single base case <tt>(=&nbsp;i&nbsp;1)</tt>.
The time it takes to compute the <i>n</i>th Fibonacci number using this
iterative solution grows linearly with <i>n</i>, which makes a
significant difference when compared to the doubly recursive version.
To get a feel for the difference, try computing <tt>(fibonacci&nbsp;35)</tt> and
<tt>(fibonacci&nbsp;40)</tt> using
both definitions to see how long each takes.

<p>
We can also get a feel for the difference by looking at a trace for
each on small inputs.
The first trace below shows the calls to <tt>fib</tt> in the non-tail-recursive
version of <tt>fibonacci</tt>, with input 5.

<p>

<p><tt>|(fib&nbsp;5)<br>

|&nbsp;(fib&nbsp;4)<br>

|&nbsp;|(fib&nbsp;3)<br>

|&nbsp;|&nbsp;(fib&nbsp;2)<br>

|&nbsp;|&nbsp;|(fib&nbsp;1)<br>

|&nbsp;|&nbsp;|1<br>

|&nbsp;|&nbsp;|(fib&nbsp;0)<br>

|&nbsp;|&nbsp;|0<br>

|&nbsp;|&nbsp;1<br>

|&nbsp;|&nbsp;(fib&nbsp;1)<br>

|&nbsp;|&nbsp;1<br>

|&nbsp;|2<br>

|&nbsp;|(fib&nbsp;2)<br>

|&nbsp;|&nbsp;(fib&nbsp;1)<br>

|&nbsp;|&nbsp;1<br>

|&nbsp;|&nbsp;(fib&nbsp;0)<br>

|&nbsp;|&nbsp;0<br>

|&nbsp;|1<br>

|&nbsp;3<br>

|&nbsp;(fib&nbsp;3)<br>

|&nbsp;|(fib&nbsp;2)<br>

|&nbsp;|&nbsp;(fib&nbsp;1)<br>

|&nbsp;|&nbsp;1<br>

|&nbsp;|&nbsp;(fib&nbsp;0)<br>

|&nbsp;|&nbsp;0<br>

|&nbsp;|1<br>

|&nbsp;|(fib&nbsp;1)<br>

|&nbsp;|1<br>

|&nbsp;2<br>

|5</tt>
<p>Notice how there are several calls to <tt>fib</tt> with arguments 2, 1, and 0.
The second trace shows the calls to <tt>fib</tt> in the tail-recursive version,
again with input 5.

<p>

<p><tt>|(fib&nbsp;5&nbsp;1&nbsp;0)<br>

|(fib&nbsp;4&nbsp;1&nbsp;1)<br>

|(fib&nbsp;3&nbsp;2&nbsp;1)<br>

|(fib&nbsp;2&nbsp;3&nbsp;2)<br>

|(fib&nbsp;1&nbsp;5&nbsp;3)<br>

|5</tt>
<p>Clearly, there is quite a difference.

<p>
<p>The <a name="./further:s50"></a>named <tt>let</tt> examples shown so far are either tail-recursive or not
tail-recursive.
It often happens that one recursive call within the same expression is
tail-recursive while another is not.
The definition of <a name="./further:s51"></a><tt>factor</tt> below computes the prime factors of its
nonnegative integer argument.
The first call to <tt>f</tt> is not
tail-recursive, but the second one is.

<p>

<p><tt>(define&nbsp;factor<br>

&nbsp;&nbsp;(lambda&nbsp;(n)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;f&nbsp;([n&nbsp;n]&nbsp;[i&nbsp;2])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cond<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(&gt;=&nbsp;i&nbsp;n)&nbsp;(list&nbsp;n)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(integer?&nbsp;(/&nbsp;n&nbsp;i))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cons&nbsp;i&nbsp;(f&nbsp;(/&nbsp;n&nbsp;i)&nbsp;i))]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[else&nbsp;(f&nbsp;n&nbsp;(+&nbsp;i&nbsp;1))]))))
<br>
<br>
(factor&nbsp;0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(0)<br>

(factor&nbsp;1)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(1)<br>

(factor&nbsp;12)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(2&nbsp;2&nbsp;3)<br>

(factor&nbsp;3628800)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(2&nbsp;2&nbsp;2&nbsp;2&nbsp;2&nbsp;2&nbsp;2&nbsp;2&nbsp;3&nbsp;3&nbsp;3&nbsp;3&nbsp;5&nbsp;5&nbsp;7)<br>

(factor&nbsp;9239)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(9239)</tt>
<p>A trace of the calls to <tt>f</tt>, produced in Chez&nbsp;Scheme by
replacing <tt>let</tt> with <tt>trace-let</tt>,
in the evaluation of <tt>(factor&nbsp;120)</tt>
below highlights the difference between the nontail calls and the
tail calls.

<p>

<p><tt>|(f&nbsp;120&nbsp;2)<br>

|&nbsp;(f&nbsp;60&nbsp;2)<br>

|&nbsp;|(f&nbsp;30&nbsp;2)<br>

|&nbsp;|&nbsp;(f&nbsp;15&nbsp;2)<br>

|&nbsp;|&nbsp;(f&nbsp;15&nbsp;3)<br>

|&nbsp;|&nbsp;|(f&nbsp;5&nbsp;3)<br>

|&nbsp;|&nbsp;|(f&nbsp;5&nbsp;4)<br>

|&nbsp;|&nbsp;|(f&nbsp;5&nbsp;5)<br>

|&nbsp;|&nbsp;|(5)<br>

|&nbsp;|&nbsp;(3&nbsp;5)<br>

|&nbsp;|(2&nbsp;3&nbsp;5)<br>

|&nbsp;(2&nbsp;2&nbsp;3&nbsp;5)<br>

|(2&nbsp;2&nbsp;2&nbsp;3&nbsp;5)</tt>
<p>A nontail call to <tt>f</tt> is shown indented relative to its caller,
since the caller is still active, whereas tail calls appear at
the same level of indentation.

<p>

<h4>Exercise <a name="g56"></a>3.2.1</h4>
<a name="./further:s52"></a>Which of the recursive procedures defined in Section&nbsp;<a href="./further.html#g55">3.2</a> are
tail-recursive, and which are not?

<p>


<p>

<h4>Exercise <a name="g57"></a>3.2.2</h4>
<a name="./further:s53"></a>Rewrite <a name="./further:s54"></a><tt>factor</tt> using <tt>letrec</tt> to bind <tt>f</tt> in place of named <tt>let</tt>.
Which version do you prefer?

<p>


<p>

<h4>Exercise <a name="g58"></a>3.2.3</h4>
<a name="./further:s55"></a>Can the <tt>letrec</tt> expression below
be rewritten using named <tt>let</tt>?
If not, why not?
If so, do it.

<p>

<p><tt>(letrec&nbsp;([even?<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(or&nbsp;(=&nbsp;x&nbsp;0)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(odd?&nbsp;(-&nbsp;x&nbsp;1))))]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[odd?<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(and&nbsp;(not&nbsp;(=&nbsp;x&nbsp;0))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(even?&nbsp;(-&nbsp;x&nbsp;1))))])<br>

&nbsp;&nbsp;(even?&nbsp;20))</tt>
<p>

<p>

<h4>Exercise <a name="g59"></a>3.2.4</h4>
<a name="./further:s56"></a>Rewrite both definitions of <tt>fibonacci</tt> given in this section to count
the number of recursive calls to <tt>fib</tt>, using a counter similar to the
one used in the <tt>cons-count</tt> example of Section&nbsp;<a href="./start.html#g40">2.9</a>.
Count the number of recursive calls made in each case for several
input values.
What do you notice?

<p>


<p>

<h4>Exercise <a name="g60"></a>3.2.5</h4>
<a name="./further:s57"></a>Augment the definition of <tt>let</tt> given in Section&nbsp;<a href="./further.html#g50">3.1</a> to
handle named <tt>let</tt> as well as unnamed <tt>let</tt>, using two rules.

<p>


<p>

<h4>Exercise <a name="g61"></a>3.2.6</h4>
<a name="./further:s58"></a><a name="ex:incorrect-or"></a>The following definition of <tt>or</tt> is simpler than the one given
in Section&nbsp;<a href="./further.html#g50">3.1</a>.

<p>

<p><tt>(define-syntax&nbsp;or&nbsp;;&nbsp;incorrect!<br>

&nbsp;&nbsp;(syntax-rules&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;[(_)&nbsp;#f]<br>

&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;e1&nbsp;e2&nbsp;...)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([t&nbsp;e1])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;t&nbsp;t&nbsp;(or&nbsp;e2&nbsp;...)))]))</tt>
<p>Say why it is not correct.
[<i>Hint</i>: Think about what would happen if this version of <tt>or</tt>
were used in the <tt>even?</tt> and <tt>odd?</tt> example given
on page&nbsp;<a href="./further.html#defn:even?/odd?">66</a> for very large inputs.]

<p>


<p>

<h4>Exercise <a name="g62"></a>3.2.7</h4>
<a name="./further:s59"></a>The definition of <a name="./further:s60"></a><tt>factor</tt> is not the most efficient possible.
First, no factors of <i>n</i> besides <i>n</i> itself can possibly be found
beyond <img src="math/tspl/10.gif" alt="<graphic>">.
Second, the division <tt>(/&nbsp;n&nbsp;i)</tt> is performed twice when a factor is
found.
Third, after 2, no even factors can possibly be found.
Recode <tt>factor</tt> to correct all three problems.
Which is the most important problem to solve?
Are there any additional improvements you can make?

<p>



<p>

<h3><a name="g63"></a><a name="./further:h3"></a>Section 3.3. Continuations<a name="SECTGFCONTINUATIONS"></a></h3>



<p>
<a name="./further:s61"></a>During the evaluation of a Scheme expression, the
implementation must keep track of two things:
(1) what to evaluate and (2) what to do with the value.
Consider the evaluation of <tt>(null?&nbsp;x)</tt> within the expression
below.

<p>

<p><tt>(if&nbsp;(null?&nbsp;x)&nbsp;(quote&nbsp;())&nbsp;(cdr&nbsp;x))</tt>
<p>The implementation must first evaluate <tt>(null?&nbsp;x)</tt> and, based on its value,
evaluate either <tt>(quote&nbsp;())</tt> or <tt>(cdr&nbsp;x)</tt>.
"What to evaluate" is <tt>(null?&nbsp;x)</tt>, and "what to do with the value"
is to make the decision which of <tt>(quote&nbsp;())</tt> and <tt>(cdr&nbsp;x)</tt> to
evaluate and to do so.
We call "what to do with the value" the <i>continuation</i> of a
computation.

<p>
Thus, at any point during the evaluation of any expression, there is a
continuation ready to complete, or at least <i>continue</i>, the computation
from that point.
Let's assume that <tt>x</tt> has the value <tt>(a&nbsp;b&nbsp;c)</tt>.
We can isolate six continuations during the evaluation of
<tt>(if&nbsp;(null?&nbsp;x)&nbsp;(quote&nbsp;())&nbsp;(cdr&nbsp;x))</tt>, the continuations waiting for

<p>
<ol>
<a name="g64"></a><li>the value of <tt>(if&nbsp;(null?&nbsp;x)&nbsp;(quote&nbsp;())&nbsp;(cdr&nbsp;x))</tt>,
<a name="g65"></a><li>the value of <tt>(null?&nbsp;x)</tt>,
<a name="g66"></a><li>the value of <tt>null?</tt>,
<a name="g67"></a><li>the value of <tt>x</tt>,
<a name="g68"></a><li>the value of <tt>cdr</tt>, and
<a name="g69"></a><li>the value of <tt>x</tt> (again).
</ol>
<p>

<p>
The continuation of <tt>(cdr&nbsp;x)</tt> is not listed because it is the same
as the one waiting for <tt>(if&nbsp;(null?&nbsp;x)&nbsp;(quote&nbsp;())&nbsp;(cdr&nbsp;x))</tt>.

<p>
Scheme allows the continuation of any expression to be captured with
the procedure
<a name="./further:s62"></a><tt>call/cc</tt>.
<tt>call/cc</tt> must be passed a procedure <tt><i>p</i></tt> of
one argument.
<tt>call/cc</tt> constructs a concrete representation of the
current continuation and passes it to <tt><i>p</i></tt>.
The continuation itself is represented by a procedure <tt><i>k</i></tt>.
Each time <tt><i>k</i></tt> is applied to a value, it returns
the value to the continuation of the <tt>call/cc</tt> application.
This value becomes, in essence, the value of the application of
<tt>call/cc</tt>.

<p>
If <tt><i>p</i></tt> returns without invoking <tt><i>k</i></tt>,
the value returned by the procedure becomes the value of the
application of <tt>call/cc</tt>.

<p>
Consider the simple examples below.

<p>

<p><tt>(call/cc<br>

&nbsp;&nbsp;(lambda&nbsp;(k)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;5&nbsp;4)))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;20
<br>
<br>
(call/cc<br>

&nbsp;&nbsp;(lambda&nbsp;(k)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;5&nbsp;(k&nbsp;4))))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;4
<br>
<br>
(+&nbsp;2<br>

&nbsp;&nbsp;&nbsp;(call/cc<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(k)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;5&nbsp;(k&nbsp;4)))))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;6</tt>
<p>In the first example, the continuation is captured and bound to <tt>k</tt>,
but <tt>k</tt> is never used, so the value is simply the product
of 5 and 4.
In the second, the continuation is invoked before the multiplication, so
the value is the value passed to the continuation, 4.
In the third, the continuation includes the addition by 2; thus, the
value is the value passed to the continuation, 4, plus 2.

<p>
<a name="./further:s63"></a>Here is a less trivial example, showing the use of
<tt>call/cc</tt> to provide a nonlocal exit from a recursion.

<p>

<p><tt>(define&nbsp;product<a name="defn:product-call/cc"></a><br>

&nbsp;&nbsp;(lambda&nbsp;(ls)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(call/cc<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(break)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;f&nbsp;([ls&nbsp;ls])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cond<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(null?&nbsp;ls)&nbsp;1]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(=&nbsp;(car&nbsp;ls)&nbsp;0)&nbsp;(break&nbsp;0)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[else&nbsp;(*&nbsp;(car&nbsp;ls)&nbsp;(f&nbsp;(cdr&nbsp;ls)))]))))))</tt>
<p>
<p><tt>(product&nbsp;'(1&nbsp;2&nbsp;3&nbsp;4&nbsp;5))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;120<br>

(product&nbsp;'(7&nbsp;3&nbsp;8&nbsp;0&nbsp;1&nbsp;9&nbsp;5))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;0</tt>
<p>The nonlocal exit allows <tt>product</tt> to return immediately,
without performing the pending multiplications,
when a zero value is detected.

<p>
Each of the continuation invocations above returns to the continuation
while control remains within the procedure passed to <tt>call/cc</tt>.
The following example uses the continuation after this procedure
has already returned.

<p>

<p><tt>(let&nbsp;([x&nbsp;(call/cc&nbsp;(lambda&nbsp;(k)&nbsp;k))])<br>

&nbsp;&nbsp;(x&nbsp;(lambda&nbsp;(ignore)&nbsp;"hi")))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;"hi"</tt>
<p>The continuation captured by this invocation of <tt>call/cc</tt> may be described as
"Take the value, bind it to <tt>x</tt>, and apply the value of <tt>x</tt> to
the value of <tt>(lambda&nbsp;(ignore)&nbsp;"hi")</tt>."
Since <tt>(lambda&nbsp;(k)&nbsp;k)</tt> returns its argument, <tt>x</tt> is bound to the
continuation itself; this continuation is applied to the procedure resulting
from the evaluation of <tt>(lambda&nbsp;(ignore)&nbsp;"hi")</tt>.
This has the effect of binding <tt>x</tt> (again!) to this procedure and
applying the procedure to itself.
The procedure ignores its argument and returns <tt>"hi"</tt>.

<p>
The following variation of the example above is probably the most confusing
Scheme program of its size; it might be easy to guess what it returns,
but it takes some thought to figure out why.

<p>

<p><tt>(((call/cc&nbsp;(lambda&nbsp;(k)&nbsp;k))&nbsp;(lambda&nbsp;(x)&nbsp;x))&nbsp;"HEY!")&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;"HEY!"</tt>
<p>The value of the <tt>call/cc</tt> is its own continuation, as in the preceding
example.
This is applied to the identity procedure <tt>(lambda&nbsp;(x)&nbsp;x)</tt>, so the
<tt>call/cc</tt> returns a second time with this value.
Then, the identity procedure is applied to itself, yielding the identity
procedure.
This is finally applied to <tt>"HEY!"</tt>, yielding <tt>"HEY!"</tt>.

<p>
Continuations used in this manner are not always so puzzling.
Consider the following definition of <a name="./further:s64"></a><tt>factorial</tt> that saves the
continuation at the base of the recursion before returning 1, by
assigning the top-level variable <a name="./further:s65"></a><tt>retry</tt><a name="retry"></a>.

<p>

<p><tt>(define&nbsp;retry&nbsp;#f)
<br>
<br>
(define&nbsp;factorial<br>

&nbsp;&nbsp;(lambda&nbsp;(x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(=&nbsp;x&nbsp;0)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(call/cc&nbsp;(lambda&nbsp;(k)&nbsp;(set!&nbsp;retry&nbsp;k)&nbsp;1))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;x&nbsp;(factorial&nbsp;(-&nbsp;x&nbsp;1))))))</tt>
<p>With this definition, <tt>factorial</tt> works as we expect
<tt>factorial</tt> to work, except it has the side effect of assigning
<tt>retry</tt>.

<p>

<p><tt>(factorial&nbsp;4)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;24<br>

(retry&nbsp;1)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;24<br>

(retry&nbsp;2)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;48</tt>
<p>The continuation bound to <tt>retry</tt> might be described as "Multiply
the value by 1, then multiply this result by 2, then multiply
this result by 3, then multiply this result by 4."
If we pass the continuation a different value, i.e., not 1, we will
cause the base value to be something other than 1 and hence change
the end result.

<p>

<p><tt>(retry&nbsp;2)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;48<br>

(retry&nbsp;5)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;120</tt>
<p>This mechanism could be the basis for a breakpoint package implemented with
<tt>call/cc</tt>; each time a breakpoint is encountered, the continuation of
the breakpoint is saved so that the computation may be restarted from the
breakpoint (more than once, if desired).

<p>
Continuations may be used to implement various forms of multitasking.
The simple "light-weight process" mechanism defined below allows
multiple computations to be interleaved.
Since it is <i>nonpreemptive</i>, it requires that each process voluntarily
"pause" from time to time in order to allow the others to run.

<p>

<p><tt>(define&nbsp;lwp-list&nbsp;'())<br>

(define&nbsp;lwp<br>

&nbsp;&nbsp;(lambda&nbsp;(thunk)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(set!&nbsp;lwp-list&nbsp;(append&nbsp;lwp-list&nbsp;(list&nbsp;thunk)))))
<br>
<br>
(define&nbsp;start<br>

&nbsp;&nbsp;(lambda&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([p&nbsp;(car&nbsp;lwp-list)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set!&nbsp;lwp-list&nbsp;(cdr&nbsp;lwp-list))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(p))))</tt>
<p>
<p><tt>(define&nbsp;pause<br>

&nbsp;&nbsp;(lambda&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;(call/cc<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(k)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lwp&nbsp;(lambda&nbsp;()&nbsp;(k&nbsp;#f)))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(start)))))</tt>
<p>The following light-weight processes cooperate to print an
infinite sequence of lines containing <tt>"hey!"</tt>.

<p>

<p><tt>(lwp&nbsp;(lambda&nbsp;()&nbsp;(let&nbsp;f&nbsp;()&nbsp;(pause)&nbsp;(display&nbsp;"h")&nbsp;(f))))<br>

(lwp&nbsp;(lambda&nbsp;()&nbsp;(let&nbsp;f&nbsp;()&nbsp;(pause)&nbsp;(display&nbsp;"e")&nbsp;(f))))<br>

(lwp&nbsp;(lambda&nbsp;()&nbsp;(let&nbsp;f&nbsp;()&nbsp;(pause)&nbsp;(display&nbsp;"y")&nbsp;(f))))<br>

(lwp&nbsp;(lambda&nbsp;()&nbsp;(let&nbsp;f&nbsp;()&nbsp;(pause)&nbsp;(display&nbsp;"!")&nbsp;(f))))<br>

(lwp&nbsp;(lambda&nbsp;()&nbsp;(let&nbsp;f&nbsp;()&nbsp;(pause)&nbsp;(newline)&nbsp;(f))))<br>

(start)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;<i>hey!</i><br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="gifs/ghostRightarrow.gif">&nbsp;<i>hey!</i><br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="gifs/ghostRightarrow.gif">&nbsp;<i>hey!</i><br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="gifs/ghostRightarrow.gif">&nbsp;<i>hey!</i><br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="gifs/ghostRightarrow.gif">&nbsp;<img src="math/tspl/3.gif" alt="<graphic>"></tt>
<p>See Section&nbsp;<a href="./examples.html#g208">12.11</a> for an implementation of <i>engines</i>,
which support preemptive multitasking, with <tt>call/cc</tt>.

<p>

<h4>Exercise <a name="g70"></a>3.3.1</h4>
<a name="./further:s66"></a>Use <tt>call/cc</tt> to write a program that loops indefinitely, printing
a sequence of numbers beginning at zero.
Do not use any recursive procedures, and do not use any assignments.

<p>


<p>

<h4>Exercise <a name="g71"></a>3.3.2</h4>
<a name="./further:s67"></a>Rewrite <tt>product</tt> without <tt>call/cc</tt>, retaining the feature that no
multiplications are performed if any of the list elements are zero.

<p>


<p>

<h4>Exercise <a name="g72"></a>3.3.3</h4>
<a name="./further:s68"></a>What would happen if a process created by <tt>lwp</tt> as defined above
were to terminate, i.e., simply return without calling
<tt>pause</tt>?
Define a <tt>quit</tt> procedure that allows a process to terminate
without otherwise affecting the <tt>lwp</tt> system.
Be sure to handle the case in which the only remaining process
terminates.

<p>



<p>

<h4>Exercise <a name="g73"></a>3.3.4</h4>
<a name="./further:s69"></a>Each time <tt>lwp</tt> is called, the list of processes is copied
because <tt>lwp</tt> uses <tt>append</tt> to add its argument to the
end of the process list.
Modify the original <tt>lwp</tt> code to
use the queue data type developed in Section&nbsp;<a href="./start.html#g40">2.9</a>
to avoid this problem.

<p>


<p>

<h4>Exercise <a name="g74"></a>3.3.5</h4>
<a name="./further:s70"></a>The light-weight process mechanism allows new processes to be created
dynamically, although the example given in this section does not
do so.
Design an application that requires new processes to be created
dynamically and implement it using the light-weight process mechanism.


<p>

<h3><a name="g75"></a><a name="./further:h4"></a>Section 3.4. Continuation Passing Style<a name="SECTGFCPS"></a></h3>



<p>
<a name="./further:s71"></a><a name="./further:s72"></a>As we discussed in the
preceding section, a continuation
waits for the value of each expression.
In particular, a continuation is associated with each procedure call.
When one procedure invokes another via a nontail call, the called
procedure receives an implicit continuation that is responsible for
completing what is left of the calling procedure's body plus returning
to the calling procedure's continuation.
If the call is a tail call, the called procedure simply receives
the continuation of the calling procedure.

<p>
We can make the continuations explicit by encapsulating "what to do"
in an explicit procedural argument passed along on each call.
For example, the continuation of the call to <tt>f</tt> in

<p>

<p><tt>(letrec&nbsp;([f&nbsp;(lambda&nbsp;(x)&nbsp;(cons&nbsp;'a&nbsp;x))]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[g&nbsp;(lambda&nbsp;(x)&nbsp;(cons&nbsp;'b&nbsp;(f&nbsp;x)))]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[h&nbsp;(lambda&nbsp;(x)&nbsp;(g&nbsp;(cons&nbsp;'c&nbsp;x)))])<br>

&nbsp;&nbsp;(cons&nbsp;'d&nbsp;(h&nbsp;'())))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(d&nbsp;b&nbsp;a&nbsp;c)</tt>
<p>conses the symbol <tt>b</tt> onto the value returned to it, then returns
the result of this cons to the continuation of the call to <tt>g</tt>.
This continuation is the same as the continuation of the call to
<tt>h</tt>, which conses the symbol <tt>d</tt> onto the value returned to
it.
We can rewrite this in <i>continuation-passing style</i>, or CPS,
by replacing these implicit continuations with explicit procedures.

<p>

<p><tt>(letrec&nbsp;([f&nbsp;(lambda&nbsp;(x&nbsp;k)&nbsp;(k&nbsp;(cons&nbsp;'a&nbsp;x)))]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[g&nbsp;(lambda&nbsp;(x&nbsp;k)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(f&nbsp;x&nbsp;(lambda&nbsp;(v)&nbsp;(k&nbsp;(cons&nbsp;'b&nbsp;v)))))]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[h&nbsp;(lambda&nbsp;(x&nbsp;k)&nbsp;(g&nbsp;(cons&nbsp;'c&nbsp;x)&nbsp;k))])<br>

&nbsp;&nbsp;(h&nbsp;'()&nbsp;(lambda&nbsp;(v)&nbsp;(cons&nbsp;'d&nbsp;v))))</tt>
<p>Like the implicit continuation of <tt>h</tt> and <tt>g</tt> in the preceding
example, the explicit continuation passed to <tt>h</tt> and on to <tt>g</tt>,

<p>

<p><tt>(lambda&nbsp;(v)&nbsp;(cons&nbsp;'d&nbsp;v))</tt>
<p>conses the symbol <tt>d</tt> onto the value passed to it.
Similarly,
the continuation passed to <tt>f</tt>,

<p>

<p><tt>(lambda&nbsp;(v)&nbsp;(k&nbsp;(cons&nbsp;'b&nbsp;v)))</tt>
<p>conses <tt>b</tt> onto the value passed to it, then passes this on to the
continuation of <tt>g</tt>.

<p>
Expressions written in CPS are more complicated, of course, but
this style of programming has some useful applications.
CPS allows
a procedure to pass more than one result to its continuation,
because the procedure that implements the continuation can
take any number of arguments.

<p>

<p><tt>(define&nbsp;car&amp;cdr<br>

&nbsp;&nbsp;(lambda&nbsp;(p&nbsp;k)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(k&nbsp;(car&nbsp;p)&nbsp;(cdr&nbsp;p))))
<br>
<br>
(car&amp;cdr&nbsp;'(a&nbsp;b&nbsp;c)<br>

&nbsp;&nbsp;(lambda&nbsp;(x&nbsp;y)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(list&nbsp;y&nbsp;x)))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;((b&nbsp;c)&nbsp;a)<br>

(car&amp;cdr&nbsp;'(a&nbsp;b&nbsp;c)&nbsp;cons)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(a&nbsp;b&nbsp;c)<br>

(car&amp;cdr&nbsp;'(a&nbsp;b&nbsp;c&nbsp;a&nbsp;d)&nbsp;memv)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(a&nbsp;d)</tt>
<p>(This can be done with multiple values as well; see Section&nbsp;<a href="./control.html#g104">5.8</a>.)
CPS also allows a procedure to take separate "success" and
"failure" continuations, which may accept different numbers of arguments.
An example is <a name="./further:s73"></a><tt>integer-divide</tt> below, which passes the quotient
and remainder of its first two arguments to its third, unless the
second argument (the divisor) is zero, in which case it passes an
error message to its fourth argument.

<p>

<p><tt>(define&nbsp;integer-divide<br>

&nbsp;&nbsp;(lambda&nbsp;(x&nbsp;y&nbsp;success&nbsp;failure)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(=&nbsp;y&nbsp;0)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(failure&nbsp;"divide&nbsp;by&nbsp;zero")<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([q&nbsp;(quotient&nbsp;x&nbsp;y)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(success&nbsp;q&nbsp;(-&nbsp;x&nbsp;(*&nbsp;q&nbsp;y)))))))
<br>
<br>
(integer-divide&nbsp;10&nbsp;3&nbsp;list&nbsp;(lambda&nbsp;(x)&nbsp;x))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(3&nbsp;1)<br>

(integer-divide&nbsp;10&nbsp;0&nbsp;list&nbsp;(lambda&nbsp;(x)&nbsp;x))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;"divide&nbsp;by&nbsp;zero"</tt>
<p>The procedure <tt>quotient</tt>, employed by <tt>integer-divide</tt>,
returns the quotient of its two arguments,
truncated toward zero.

<p>
Explicit success and failure continuations can sometimes
help to avoid the extra communication necessary to separate successful
execution of a procedure from unsuccessful execution.
Furthermore, it is possible to have multiple success or failure
continuations for different flavors of success or failure, each
possibly taking different numbers and types of arguments.
See Sections&nbsp;<a href="./examples.html#g204">12.10</a> and&nbsp;<a href="./examples.html#g208">12.11</a> for extended examples
that employ continuation-passing style.

<p>
At this point you might be wondering about the relationship between
CPS and the continuations captured via <tt>call/cc</tt>.
It turns out that any program that uses <tt>call/cc</tt> can be rewritten
in CPS without <tt>call/cc</tt>, but a total rewrite of the program
(sometimes including even system-defined primitives) might be
necessary.
Try to convert the <a name="./further:s74"></a><tt>product</tt> example on
page&nbsp;<a href="./further.html#defn:product-call/cc">75</a>
into CPS before looking at the version below.

<p>

<p><tt>(define&nbsp;product<br>

&nbsp;&nbsp;(lambda&nbsp;(ls&nbsp;k)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([break&nbsp;k])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;f&nbsp;([ls&nbsp;ls]&nbsp;[k&nbsp;k])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cond<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(null?&nbsp;ls)&nbsp;(k&nbsp;1)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(=&nbsp;(car&nbsp;ls)&nbsp;0)&nbsp;(break&nbsp;0)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[else&nbsp;(f&nbsp;(cdr&nbsp;ls)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(k&nbsp;(*&nbsp;(car&nbsp;ls)&nbsp;x))))])))))</tt>
<p>
<p><tt>(product&nbsp;'(1&nbsp;2&nbsp;3&nbsp;4&nbsp;5)&nbsp;(lambda&nbsp;(x)&nbsp;x))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;120<br>

(product&nbsp;'(7&nbsp;3&nbsp;8&nbsp;0&nbsp;1&nbsp;9&nbsp;5)&nbsp;(lambda&nbsp;(x)&nbsp;x))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;0</tt>
<p>
<h4>Exercise <a name="g76"></a>3.4.1</h4>
<a name="./further:s75"></a>Rewrite the <a name="./further:s76"></a><tt>reciprocal</tt> example first given in
Section&nbsp;<a href="./start.html#g5">2.1</a> to accept both success and failure
continuations, like <tt>integer-divide</tt> above.

<p>


<p>

<h4>Exercise <a name="g77"></a>3.4.2</h4>
<a name="./further:s77"></a>Rewrite the <a name="./further:s78"></a><tt>retry</tt> example from page&nbsp;<a href="./further.html#retry">75</a> to use CPS.

<p>


<p>

<h4>Exercise <a name="g78"></a>3.4.3</h4>
<a name="./further:s79"></a>Rewrite the following expression in CPS to avoid using <tt>call/cc</tt>.

<p>

<p><tt>(define&nbsp;reciprocals<br>

&nbsp;&nbsp;(lambda&nbsp;(ls)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(call/cc<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(k)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(map&nbsp;(lambda&nbsp;(x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(=&nbsp;x&nbsp;0)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(k&nbsp;"zero&nbsp;found")<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(/&nbsp;1&nbsp;x)))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ls)))))</tt>
<p>
<p><tt>(reciprocals&nbsp;'(2&nbsp;1/3&nbsp;5&nbsp;1/4))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(1/2&nbsp;3&nbsp;1/5&nbsp;4)<br>

(reciprocals&nbsp;'(2&nbsp;1/3&nbsp;0&nbsp;5&nbsp;1/4))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;"zero&nbsp;found"</tt>
<p>[<i>Hint</i>: A single-list version of <tt>map</tt> is
defined on page&nbsp;<a href="./start.html#defn:map1">46</a>.]

<p>



<p>

<h3><a name="g79"></a><a name="./further:h5"></a>Section 3.5. Internal Definitions<a name="SECTGFINTERNAL"></a></h3>



<p>
<a name="./further:s80"></a><a name="./further:s81"></a>In Section&nbsp;<a href="./start.html#g25">2.6</a>, we
discussed top-level definitions.
Definitions may also appear at the front of a <tt>lambda</tt>, <tt>let</tt>,
or <tt>letrec</tt> body, in which case the bindings they create are local
to the body.

<p>

<p><tt>(define&nbsp;f&nbsp;(lambda&nbsp;(x)&nbsp;(*&nbsp;x&nbsp;x)))<br>

(let&nbsp;([x&nbsp;3])<br>

&nbsp;&nbsp;(define&nbsp;f&nbsp;(lambda&nbsp;(y)&nbsp;(+&nbsp;y&nbsp;x)))<br>

&nbsp;&nbsp;(f&nbsp;4))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;7<br>

(f&nbsp;4)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;16</tt>
<p>Procedures bound by internal definitions can be mutually recursive,
as with <tt>letrec</tt>.
For example, we can rewrite the <a name="./further:s82"></a><tt>even?</tt> and <a name="./further:s83"></a><tt>odd?</tt> example
from Section&nbsp;<a href="./further.html#g55">3.2</a>
using internal definitions as follows.

<p>

<p><tt>(let&nbsp;()<br>

&nbsp;&nbsp;(define&nbsp;even?<br>

&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(or&nbsp;(=&nbsp;x&nbsp;0)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(odd?&nbsp;(-&nbsp;x&nbsp;1)))))<br>

&nbsp;&nbsp;(define&nbsp;odd?<br>

&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(and&nbsp;(not&nbsp;(=&nbsp;x&nbsp;0))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(even?&nbsp;(-&nbsp;x&nbsp;1)))))<br>

&nbsp;&nbsp;(even?&nbsp;20))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t</tt>
<p>Similarly, we can replace the use of <a name="./further:s84"></a><tt>letrec</tt> to bind <tt>race</tt>
with an internal definition of <tt>race</tt> in our first definition of
<a name="./further:s85"></a><tt>list?</tt>.

<p>

<p><tt>(define&nbsp;list?<br>

&nbsp;&nbsp;(lambda&nbsp;(x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(define&nbsp;race<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(h&nbsp;t)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(pair?&nbsp;h)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([h&nbsp;(cdr&nbsp;h)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(pair?&nbsp;h)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(and&nbsp;(not&nbsp;(eq?&nbsp;h&nbsp;t))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(race&nbsp;(cdr&nbsp;h)&nbsp;(cdr&nbsp;t)))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(null?&nbsp;h)))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(null?&nbsp;h))))<br>

&nbsp;&nbsp;&nbsp;&nbsp;(race&nbsp;x&nbsp;x)))</tt>
<p>In fact, internal variable definitions and <tt>letrec</tt> are practically interchangeable.
The only difference, other than the obvious difference in syntax, is that
variable definitions are guaranteed to be evaluated from left to right,
while the bindings of a letrec may be evaluated in any order.
So we cannot quite replace a
<tt>lambda</tt>, <tt>let</tt>, or
<tt>letrec</tt> body containing internal definitions with a <tt>letrec</tt> expression.
We can, however, use <tt>letrec*</tt>, which, like
<tt>let*</tt>, guarantees left-to-right evaluation order.
A body of the form

<p>

<p><tt>(define&nbsp;<i>var</i>&nbsp;<i>expr<sub>0</sub></i>)<br>

&nbsp;&nbsp;<img src="math/tspl/3.gif" alt="<graphic>"><br>

<i>expr<sub>1</sub></i><br>

<i>expr<sub>2</sub></i><br>

&nbsp;&nbsp;<img src="math/tspl/3.gif" alt="<graphic>"></tt>
<p>is equivalent to a <tt>letrec*</tt>
expression binding the defined variables to the associated values
in a body comprising the expressions.

<p>

<p><tt>(letrec*&nbsp;((<i>var</i>&nbsp;<i>expr<sub>0</sub></i>)&nbsp;...)&nbsp;<i>expr<sub>1</sub></i>&nbsp;<i>expr<sub>2</sub></i>&nbsp;...)</tt>
<p>Conversely, a <tt>letrec*</tt> of the form

<p>

<p><tt>(letrec*&nbsp;((<i>var</i>&nbsp;<i>expr<sub>0</sub></i>)&nbsp;...)&nbsp;<i>expr<sub>1</sub></i>&nbsp;<i>expr<sub>2</sub></i>&nbsp;...)</tt>
<p>can be replaced with a <tt>let</tt> expression containing internal definitions
and the expressions from the body as follows.

<p>

<p><tt>(let&nbsp;()<br>

&nbsp;&nbsp;(define&nbsp;<i>var</i>&nbsp;<i>expr<sub>0</sub></i>)<br>

&nbsp;&nbsp;&nbsp;&nbsp;<img src="math/tspl/3.gif" alt="<graphic>"><br>

&nbsp;&nbsp;<i>expr<sub>1</sub></i><br>

&nbsp;&nbsp;<i>expr<sub>2</sub></i><br>

&nbsp;&nbsp;&nbsp;&nbsp;<img src="math/tspl/3.gif" alt="<graphic>"><br>

)</tt>
<p>The seeming lack of symmetry between these transformations is due to
the fact that <tt>letrec*</tt> expressions can appear anywhere an expression
is valid, whereas internal definitions can appear only at the front
of a body.
Thus, in replacing a <tt>letrec*</tt> with internal definitions, we must generally
introduce a <tt>let</tt> expression to hold the definitions.

<p>
Another difference between internal definitions and <tt>letrec</tt> or
<tt>letrec*</tt> is that syntax definitions may appear among the internal
definitions, while <tt>letrec</tt> and <tt>letrec*</tt> bind only
variables.

<p>

<p><tt>(let&nbsp;([x&nbsp;3])<br>

&nbsp;&nbsp;(define-syntax&nbsp;set-x!<br>

&nbsp;&nbsp;&nbsp;&nbsp;(syntax-rules&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;e)&nbsp;(set!&nbsp;x&nbsp;e)]))<br>

&nbsp;&nbsp;(set-x!&nbsp;(+&nbsp;x&nbsp;x))<br>

&nbsp;&nbsp;x)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;6</tt>
<p>The scope of a syntactic extension established by an internal syntax
definition, as with an internal variable definition, is limited to
the body in which the syntax definition appears.

<p>
Internal definitions may be used in conjunction with top-level
definitions and assignments to help modularize programs.
Each module of a program should make visible only those bindings
that are needed by other modules, while hiding other bindings that
would otherwise clutter the top-level namespace and possibly
result in unintended use or redefinition of those bindings.
A common way of structuring a module is shown below.

<p>

<p><tt>(define&nbsp;<i>export-var</i>&nbsp;#f)<br>

&nbsp;&nbsp;<img src="math/tspl/3.gif" alt="<graphic>"><br>

(let&nbsp;()<br>

&nbsp;&nbsp;(define&nbsp;<i>var</i>&nbsp;<i>expr</i>)<br>

&nbsp;&nbsp;&nbsp;&nbsp;<img src="math/tspl/3.gif" alt="<graphic>"><br>

&nbsp;&nbsp;<i>init-expr</i><br>

&nbsp;&nbsp;&nbsp;&nbsp;<img src="math/tspl/3.gif" alt="<graphic>"><br>

&nbsp;&nbsp;(set!&nbsp;<i>export-var</i>&nbsp;<i>export-val</i>)<br>

&nbsp;&nbsp;&nbsp;&nbsp;<img src="math/tspl/3.gif" alt="<graphic>"><br>

)</tt>
<p>The first set of definitions establish top-level bindings for the
variables we desire to export (make visible globally).
The second set of definitions establish local bindings visible only
within the module.
The expressions <tt><i>init-expr</i>&nbsp;...</tt> perform any initialization that
must occur after the local bindings have been established.
Finally, the <tt>set!</tt> expressions assign the exported variables to
the appropriate values.

<p>
An advantage of this form of modularization is that the bracketing
<tt>let</tt> expression may be removed or "commented out" during
program development, making the internal definitions top-level to
facilitate interactive testing.
This form of modularization also has several disadvantages, as we
discuss in the next section.

<p>
The following module exports a single variable, <tt>calc</tt>, which is
bound to a procedure that implements a simple four-function
calculator.

<p>

<p><tt>(define&nbsp;calc&nbsp;#f)<br>

(let&nbsp;()<br>

&nbsp;&nbsp;(define&nbsp;do-calc<br>

&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(ek&nbsp;expr)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cond<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(number?&nbsp;expr)&nbsp;expr]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(and&nbsp;(list?&nbsp;expr)&nbsp;(=&nbsp;(length&nbsp;expr)&nbsp;3))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([op&nbsp;(car&nbsp;expr)]&nbsp;[args&nbsp;(cdr&nbsp;expr)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(case&nbsp;op<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(add)&nbsp;(apply-op&nbsp;ek&nbsp;+&nbsp;args)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(sub)&nbsp;(apply-op&nbsp;ek&nbsp;-&nbsp;args)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(mul)&nbsp;(apply-op&nbsp;ek&nbsp;*&nbsp;args)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(div)&nbsp;(apply-op&nbsp;ek&nbsp;/&nbsp;args)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[else&nbsp;(complain&nbsp;ek&nbsp;"invalid&nbsp;operator"&nbsp;op)]))]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[else&nbsp;(complain&nbsp;ek&nbsp;"invalid&nbsp;expression"&nbsp;expr)])))<br>

&nbsp;&nbsp;(define&nbsp;apply-op<br>

&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(ek&nbsp;op&nbsp;args)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(op&nbsp;(do-calc&nbsp;ek&nbsp;(car&nbsp;args))&nbsp;(do-calc&nbsp;ek&nbsp;(cadr&nbsp;args)))))<br>

&nbsp;&nbsp;(define&nbsp;complain<br>

&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(ek&nbsp;msg&nbsp;expr)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(ek&nbsp;(list&nbsp;msg&nbsp;expr))))<br>

&nbsp;&nbsp;(set!&nbsp;calc<br>

&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(expr)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;grab&nbsp;an&nbsp;error&nbsp;continuation&nbsp;ek<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(call/cc<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(ek)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(do-calc&nbsp;ek&nbsp;expr))))))
<br>
<br>
(calc&nbsp;'(add&nbsp;(mul&nbsp;3&nbsp;2)&nbsp;-4))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;2<br>

(calc&nbsp;'(div&nbsp;1/2&nbsp;1/6))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;3<br>

(calc&nbsp;'(add&nbsp;(mul&nbsp;3&nbsp;2)&nbsp;(div&nbsp;4)))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;("invalid&nbsp;expression"&nbsp;(div&nbsp;4))<br>

(calc&nbsp;'(mul&nbsp;(add&nbsp;1&nbsp;-2)&nbsp;(pow&nbsp;2&nbsp;7)))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;("invalid&nbsp;operator"&nbsp;pow)</tt>
<p>This example uses a <tt>case</tt> expression to determine which operator
to apply.
<tt>case</tt> is similar to <tt>cond</tt> except that the test is always the
same: <tt>(memv&nbsp;<i>val</i>&nbsp;(<i>key</i>&nbsp;...))</tt>, where <tt><i>val</i></tt>
is the value of the first <tt>case</tt> subform and <tt>(<i>key</i>&nbsp;...)</tt>
is the list of items at the front of each <tt>case</tt> clause.
The <tt>case</tt> expression in the example above could be rewritten
using <tt>cond</tt> as follows.

<p>

<p><tt>(let&nbsp;([temp&nbsp;op])<br>

&nbsp;&nbsp;(cond<br>

&nbsp;&nbsp;&nbsp;&nbsp;[(memv&nbsp;temp&nbsp;'(add))&nbsp;(apply-op&nbsp;ek&nbsp;+&nbsp;args)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;[(memv&nbsp;temp&nbsp;'(sub))&nbsp;(apply-op&nbsp;ek&nbsp;-&nbsp;args)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;[(memv&nbsp;temp&nbsp;'(mul))&nbsp;(apply-op&nbsp;ek&nbsp;*&nbsp;args)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;[(memv&nbsp;temp&nbsp;'(div))&nbsp;(apply-op&nbsp;ek&nbsp;/&nbsp;args)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;[else&nbsp;(complain&nbsp;ek&nbsp;"invalid&nbsp;operator"&nbsp;op)]))</tt>
<p>
<h4>Exercise <a name="g80"></a>3.5.1</h4>
<a name="./further:s86"></a>Redefine <tt>complain</tt> in the <tt>calc</tt> example as an equivalent syntactic
extension.

<p>


<p>

<h4>Exercise <a name="g81"></a>3.5.2</h4>
<a name="./further:s87"></a>In the <tt>calc</tt> example, the error continuation <tt>ek</tt> is passed
along on
each call to <tt>apply-op</tt>, <tt>complain</tt>, and <tt>do-calc</tt>.
Move the definitions of <tt>apply-op</tt>, <tt>complain</tt>, and
<tt>do-calc</tt> inward as far as necessary to eliminate the
<tt>ek</tt> argument from the definitions and applications
of these procedures.

<p>


<p>

<h4>Exercise <a name="g82"></a>3.5.3</h4>
<a name="./further:s88"></a>Eliminate the <tt>call/cc</tt> from <tt>calc</tt> and rewrite <tt>complain</tt> to
raise an exception using <tt>assertion-violation</tt>.

<p>


<p>

<h4>Exercise <a name="g83"></a>3.5.4</h4>
<a name="./further:s89"></a>Extend <tt>calc</tt> to handle unary minus expressions, e.g.,

<p>

<p><tt>(calc&nbsp;'(minus&nbsp;(add&nbsp;2&nbsp;3)))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;-5</tt>
<p>and other operators of your choice.

<p>



<p>

<h3><a name="g84"></a><a name="./further:h6"></a>Section 3.6. Libraries<a name="SECTGFLIBRARIES"></a></h3>



<p>
At the end of the preceding section, we discussed a form of modularization
that involves assigning a set of top-level variables from within a <tt>let</tt>
while keeping unpublished helpers local to the <tt>let</tt>.
This form of modularization has several drawbacks:

<p>
<ul>
  <li>It is unportable, because the behavior and even existence of an
        interactive top level is not guaranteed by the Revised<sup>6</sup> Report.
  <li>It requires assignments, which make the code appear somewhat awkward
        and may inhibit compiler analyses and optimizations.
  <li>It does not support the publication of keyword bindings, since
        there is no analogue to <tt>set!</tt> for keywords.
</ul>
<p>

<p>
An alternative that does not share these drawbacks is to create a library.
A library exports a set of identifiers, each defined within the library
or imported from some other library.
An exported identifier need not be bound as a variable; it may be bound
as a keyword instead.

<p>
The following library exports two identifiers: the variable
<tt>gpa-&gt;grade</tt> and the keyword <tt>gpa</tt>.
The variable <tt>gpa-&gt;grade</tt> is bound to a procedure that
takes a grade-point average (GPA), represented as a number, and returns
the corresponding letter grade, based on a four-point scale.
The keyword <tt>gpa</tt> names a syntactic extension whose
subforms must all be letter grades and whose value is the GPA
computed from those letter grades.

<p>

<p><tt>(library&nbsp;(grades)<br>

&nbsp;&nbsp;(export&nbsp;gpa-&gt;grade&nbsp;gpa)<br>

&nbsp;&nbsp;(import&nbsp;(rnrs))
<br>
<br>
&nbsp;&nbsp;(define&nbsp;in-range?<br>

&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(x&nbsp;n&nbsp;y)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(and&nbsp;(&gt;=&nbsp;n&nbsp;x)&nbsp;(&lt;&nbsp;n&nbsp;y))))
<br>
<br>
&nbsp;&nbsp;(define-syntax&nbsp;range-case&nbsp;<br>

&nbsp;&nbsp;&nbsp;&nbsp;(syntax-rules&nbsp;(-&nbsp;else)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;expr&nbsp;((x&nbsp;-&nbsp;y)&nbsp;e1&nbsp;e2&nbsp;...)&nbsp;...&nbsp;[else&nbsp;ee1&nbsp;ee2&nbsp;...])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([tmp&nbsp;expr])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cond<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(in-range?&nbsp;x&nbsp;tmp&nbsp;y)&nbsp;e1&nbsp;e2&nbsp;...]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[else&nbsp;ee1&nbsp;ee2&nbsp;...]))]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;expr&nbsp;((x&nbsp;-&nbsp;y)&nbsp;e1&nbsp;e2&nbsp;...)&nbsp;...)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([tmp&nbsp;expr])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cond<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(in-range?&nbsp;x&nbsp;tmp&nbsp;y)&nbsp;e1&nbsp;e2&nbsp;...]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...))]))
<br>
<br>
&nbsp;&nbsp;(define&nbsp;letter-&gt;number<br>

&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(case&nbsp;x<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(a)&nbsp;&nbsp;4.0]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(b)&nbsp;&nbsp;3.0]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(c)&nbsp;&nbsp;2.0]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(d)&nbsp;&nbsp;1.0]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(f)&nbsp;&nbsp;0.0]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[else&nbsp;(assertion-violation&nbsp;'grade&nbsp;"invalid&nbsp;letter&nbsp;grade"&nbsp;x)])))
<br>
<br>
&nbsp;&nbsp;(define&nbsp;gpa-&gt;grade<br>

&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(range-case&nbsp;x<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(0.0&nbsp;-&nbsp;0.5)&nbsp;'f]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(0.5&nbsp;-&nbsp;1.5)&nbsp;'d]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(1.5&nbsp;-&nbsp;2.5)&nbsp;'c]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(2.5&nbsp;-&nbsp;3.5)&nbsp;'b]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[else&nbsp;'a])))
<br>
<br>
&nbsp;&nbsp;(define-syntax&nbsp;gpa<br>

&nbsp;&nbsp;&nbsp;&nbsp;(syntax-rules&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;g1&nbsp;g2&nbsp;...)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([ls&nbsp;(map&nbsp;letter-&gt;number&nbsp;'(g1&nbsp;g2&nbsp;...))])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(/&nbsp;(apply&nbsp;+&nbsp;ls)&nbsp;(length&nbsp;ls)))])))</tt>
<p>The name of the library is <tt>(grades)</tt>.
This may seem like a funny kind of name, but all library names are
parenthesized.
The library imports from the standard <tt>(rnrs)</tt> library,
which contains most of the primitive and keyword bindings we have
used in this chapter and the last, and everything we need to
implement <tt>gpa-&gt;grade</tt> and <tt>gpa</tt>.

<p>
Along with <tt>gpa-&gt;grade</tt> and <tt>gpa</tt>, several other
syntactic extensions and procedures are defined within the library,
but none of the others are exported.
The ones that aren't exported are simply helpers for the ones
that are.
Everything used within the library should be familiar, except
for the <tt>apply</tt> procedure, which is described on
page&nbsp;<a href="./control.html#desc:apply">107</a>.

<p>
If your Scheme implementation supports <tt>import</tt> in the interactive
top level, you can test the two exports as shown below.

<p>

<p><tt>(import&nbsp;(grades))<br>

(gpa&nbsp;c&nbsp;a&nbsp;c&nbsp;b&nbsp;b)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;2.8<br>

(gpa-&gt;grade&nbsp;2.8)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;b</tt>
<p>Chapter&nbsp;<a href="./libraries.html#g142">10</a> describes libraries in more detail and
provides additional examples of their use.

<p>

<h4>Exercise <a name="g85"></a>3.6.1</h4>
<a name="./further:s90"></a>Modify <tt>gpa</tt> to handle "<tt>x</tt>" grades, which do not
count in the grade-point average.
Be careful to handle gracefully the situation where each grade is <tt>x</tt>.

<p>

<p><tt>(import&nbsp;(grades))<br>

(gpa&nbsp;a&nbsp;x&nbsp;b&nbsp;c)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;3.0</tt>
<p>


<p>

<h4>Exercise <a name="g86"></a>3.6.2</h4>
<a name="./further:s91"></a>Export from <tt>(grades)</tt> a new syntactic form, <tt>distribution</tt>,
that takes a set of grades, like <tt>gpa</tt>, but returns a list of the
form <tt>((<i>n</i>&nbsp;<i>g</i>)&nbsp;...)</tt>, where <tt><i>n</i></tt> is the number of
times <tt><i>g</i></tt> appears in the set, with one entry for each <tt><i>g</i></tt>.
Have <tt>distribution</tt> call an unexported procedure to do the actual
work.

<p>

<p><tt>(import&nbsp;(grades))<br>

(distribution&nbsp;a&nbsp;b&nbsp;a&nbsp;c&nbsp;c&nbsp;c&nbsp;a&nbsp;f&nbsp;b&nbsp;a)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;((4&nbsp;a)&nbsp;(2&nbsp;b)&nbsp;(3&nbsp;c)&nbsp;(0&nbsp;d)&nbsp;(1&nbsp;f))</tt>
<p>

<p>

<h4>Exercise <a name="g87"></a>3.6.3</h4>
<a name="./further:s92"></a>Now read about output operations in Section&nbsp;<a href="./io.html#g129">7.8</a> and define
a new export, <tt>histogram</tt>, as a procedure that takes a
<tt><i>textual output port</i></tt> and a distribution, such as might be
produced by <tt>distribution</tt>, and prints a histogram in the style
illustrated by the example below.

<p>

<p><tt>(import&nbsp;(grades))<br>

(histogram<br>

&nbsp;&nbsp;(current-output-port)<br>

&nbsp;&nbsp;(distribution&nbsp;a&nbsp;b&nbsp;a&nbsp;c&nbsp;c&nbsp;a&nbsp;c&nbsp;a&nbsp;f&nbsp;b&nbsp;a))
<br>
<br>
<i>prints:</i><br>

&nbsp;&nbsp;a:&nbsp;*****<br>

&nbsp;&nbsp;b:&nbsp;**<br>

&nbsp;&nbsp;c:&nbsp;***<br>

&nbsp;&nbsp;d:&nbsp;<br>

&nbsp;&nbsp;f:&nbsp;*</tt>
<p>




<hr class=copyright align=left>
<p>
R. Kent Dybvig / <it>The Scheme Programming Language, Fourth Edition</it><br>
Copyright &copy; 2009 <a class=plain href="http://mitpress.mit.edu/catalog/item/default.asp?ttype=2&tid=11984">The MIT Press</a>.  Electronically reproduced by permission.<br>
Illustrations &copy; 2009 <a class=plain href="http://hebert.kitp.ucsb.edu/">Jean-Pierre H&eacute;bert</a><br>
ISBN 978-0-262-51298-5 / LOC QA76.73.S34D93<br>
<a class=plain href="http://mitpress.mit.edu/catalog/item/default.asp?ttype=2&tid=11984">to order this book</a> / <a class=plain href="canned/about.html">about this book</a>
</p>
<p><a class=plain href="http://www.scheme.com">http://www.scheme.com</a></p>
</body>
</html>
