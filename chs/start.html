<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
  "http://www.w3.org/TR/html4/loose.dtd"><!-- DO NOT EDIT THIS FILE-->
<!-- Edit the .tex version instead-->

<html>
<head>
<title>开始体验</title>
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta charset="UTF-8" http-equiv="X-UA-Compatible" content="IE=EmulateIE8">
<link href="tspl.css" rel="stylesheet" type="text/css">
</head>
<body>
<a name="g4"></a>
<a name="./start:h0"></a>

<div style="font-size: 12px; width: 500px; height: 500px; border: solid thin">
<img style="padding: 20px 10px 20px 20px" src="canned/ch2.png"><img src="canned/jph.png">
</div>
<h1>第二章. 开始体验<a name="CHPTGETTINGSTARTED"></a></h1>





<p>
  这章是为Scheme语言新手准备的入门引导。
  从本章开始，如果你坐在电脑前对着Scheme交互式系统，跟着示例代码做实验，你会学到更多的东西。
  
<p>
  当你完成了本章的阅读和练习，你就应该可以开始使用Scheme语言了。
  你将学到Scheme程序的语法，和它是如何运行的，并且了解简单的数据结构和控制机制。
  

<p>

<h3><a name="g5"></a><a name="./start:h1"></a>2.1. 和Scheme进行交互<a name="SECTGSINTERACTING"></a></h3>



<p>
  大多数Scheme系统提供一个交互式编程环境，用来简化程序的开发和实验。
  最简单的Scheme交互遵循“读取-求值-打印”循环。
  一个程序（通常叫做<i>读取-求值-打印循环（read-evaluate-print loop）</i>或者REPL）
  读取每一个你从键盘输入的表达式，对它求值，然后打印出这个值。

<p>
  通过使用Scheme交互系统，你可以输入一个表达式并且立刻查看到它的值。
  你可以定义一个过程并且把它应用在参数上看它如何工作。
  你可以输入由一组过程定义组成的整个程序，并且测试它，不需要切换出这个系统。
  当你写的程序开始变长的时候，更方便的做法是，
  把它写在文件里（用文本编辑器），
  然后在交互式系统中加载这个文件，并交互式测试这个程序。
  在大多数Scheme系统中，使用一个未标准化的过程来加载一个文件，
  这个过程叫做<a name="./start:s0"></a><tt>load</tt>，接受一个字符串参数用来指示要加载的文件。
  把你的程序写在文件中有很多好处：你有机会更仔细的构造你的程序，
  你可以不用重新输入整个程序就修改其中的错误，并且你可以保存一个副本留待以后使用。
  大多数Scheme的实现对待从文件中加载的表达式和从键盘录入的表达式是一样的。
  
<p>
  虽然Scheme提供了多种输入输出的过程，但REPL能够负责读取表达式和打印它们的值。
  这能够让你把注意力集中在写程序上而不需要担心他们的结果将会如何显示。

  
<p>
  这一章和本书之后的示例遵循统一格式。
  你需要从键盘输入的内容将首先给出，可能扩展成多行。
  这个表达式的值将在<img src="math/tspl/0.gif" alt="<graphic>">后面给出，读作“求值得：”。
  定义和返回“未确定值”的表达式后面的<img src="math/tspl/0.gif" alt="<graphic>">将会被省略。


<p>
  示例代码使用了漂亮并能传达程序结构的风格进行格式化。
  由于每个表达式和它的子表达式的关系都很清晰的呈现出来，代码会非常易于阅读。
  Scheme忽略缩进和断行，所以不需要遵循某个特定的风格。

  重要的是建立一个风格并且坚持下去。
  Scheme实际上把每个程序都视为一行，子表达式从左到右依次排列。

<p>
<p>
  如果可以，你最好现在就打开一个Scheme交互系统并且键入你阅读到的代码。
  最简单的Scheme表达式之一是<a name="./start:s1"></a>常量字符串。
  试试在提示符后面输入<tt>"Hi&nbsp;Mom!"</tt>（包括双引号）。
  系统应该回应你<tt>"Hi&nbsp;Mom!"</tt>；任何常量的值都是它自己。

<p>

<p><tt>"Hi&nbsp;Mom!"&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;"Hi&nbsp;Mom!"</tt>

  
<p>这里有一组表达式，和Scheme给出的反馈。
  本章后面的小节将会解释它们，但是现在用它们来练习一下Scheme交互模式。

<p>

<p><tt>"hello"&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;"hello"<br>

42&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;42<br>

22/7&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;22/7<br>

3.141592653&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;3.141592653<br>

+&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#&lt;procedure&gt;<br>

(+&nbsp;76&nbsp;31)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;107<br>

(*&nbsp;-12&nbsp;10)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;-120<br>

'(a&nbsp;b&nbsp;c&nbsp;d)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(a&nbsp;b&nbsp;c&nbsp;d)</tt>

<p>
  小心不要漏掉任何单引号（&nbsp;<tt>'</tt>&nbsp;）、双引号和小括号。
  如果你在最后一个表达式中漏掉了一个单引号，你可能会收到一个代表异常发生的信息。
  你只需要再试一次即可。
  如果你漏掉的是一个配对的小括号或者双引号，系统将还在等待你输入。


<p>
  这里有更多的表达式，你可以尝试想出每个表达式的意思，或者等之后的章节来揭示答案。

<p>

<p><tt>(car&nbsp;'(a&nbsp;b&nbsp;c))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;a<br>

(cdr&nbsp;'(a&nbsp;b&nbsp;c))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(b&nbsp;c)<br>

(cons&nbsp;'a&nbsp;'(b&nbsp;c))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(a&nbsp;b&nbsp;c)<br>

(cons&nbsp;(car&nbsp;'(a&nbsp;b&nbsp;c))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cdr&nbsp;'(d&nbsp;e&nbsp;f)))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(a&nbsp;e&nbsp;f)</tt>
  
<p>
  如你所见，Scheme表达式可以被扩展到多行。
  Scheme系统通过括号和引号配对了解它是否得到了整个表达式。

<p>
  下面，我们尝试定义一些过程<a name="./start:s2"></a>。

<p>

<p><tt>(define&nbsp;square<br>

&nbsp;&nbsp;(lambda&nbsp;(n)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;n&nbsp;n)))</tt>
  
<p>
  过程<tt>square</tt>计算任意数<i>n</i>的平方<i>n</i><sup>2</sup> <i>n</i>。
  在本章的稍后部分我们将对组成这个表定义的表达式进行更多的解释。
  现在我们可以说，<tt>define</tt>建立变量绑定，<tt>lambda</tt>创建过程。<tt>*</tt>是乘法过程的名字。
  注意这些表达式的形式。
  所有结构化形式都用小括号包围起来，并且使用<a name="./start:s3"></a><i>前缀表达式记法</i>，就是说，一个操作符后面跟着它的参数。
  如你所见，连简单的算术运算乘法<tt>*</tt>也是如此。

<p>
来试着用一下<tt>square</tt>过程。

<p>

<p><tt>(square&nbsp;5)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;25<br>

(square&nbsp;-200)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;40000<br>

(square&nbsp;0.5)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;0.25<br>

(square&nbsp;-1/2)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;1/4</tt>
  
<p>
  虽然下一个定义很简单，你还是把它输入到一个文件中。我们假设你把这个文件命名为"reciprocal.ss"。

<p>

<p><tt>(define&nbsp;reciprocal<br>

&nbsp;&nbsp;(lambda&nbsp;(n)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(=&nbsp;n&nbsp;0)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"oops!"<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(/&nbsp;1&nbsp;n))))</tt>
<p>
  这个过程<a name="./start:s4"></a><tt>reciprocal</tt>，对任意的<i>n</i> &ne; 0计算1/<i>n</i>。
  对于<i>n</i> = 0，<tt>reciprocal</tt>返回字符串<tt>"oops!"</tt>。
  回到Scheme中用<tt>load</tt>过程加载你的文件。
  
<p>

<p><tt>(load&nbsp;"reciprocal.ss")</tt>
<p>最后，尝试使用我们刚刚定义的这个过程。

<p>

<p><tt>(reciprocal&nbsp;10)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;1/10<br>

(reciprocal&nbsp;1/10)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;10<br>

(reciprocal&nbsp;0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;"oops!"<br>

(reciprocal&nbsp;(reciprocal&nbsp;1/10))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;1/10</tt>
<p>
  下一小节我们将深入讨论Scheme表达式的细节。
  学习本章的过程中要时刻记住，你的Scheme解释器是学习Scheme最有用的工具。
  每做一个书上的示例练习，都紧跟着做一些自己的练习。
  在一个交互式的Scheme系统中，尝试练习的代价真的很小，通常也就是键入代码的时间花销而已。

<p>

<h3><a name="g6"></a><a name="./start:h2"></a>2.2. 简单表达式<a name="SECTGSSIMPLE"></a></h3>



<p>
  最简单的Scheme表达式是常量数据对象，例如字符串、数值、符号和列表。
  Scheme支持其他的对象类型，但是这些大多数情况下够用了。
  之前章节中我们见过了一些关于字符串和数值的示例。

<p>
  我们稍微进一步讨论一下<a name="./start:s5"></a>数值类型。
  数值是常量。如果你输入了一个数值，Scheme直接把它原样反馈给你。
  下面的例子展示Scheme支持多种类型的数值。

<p>

<p><tt>123456789987654321&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;123456789987654321<br>

3/4&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;3/4<br>

2.718281828&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;2.718281828<br>

2.2+1.1i&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;2.2+1.1i</tt>
  
<p>
  Scheme数值包括精确和不精确整数、有理数、实数，和复数。
  精确整数和有理数拥有任意的精度，就是说它们可以是任意大小的。
  不精确整数通常在内部用IEEE标准浮点数表现形式来表示。

<p>
  Scheme提供了 <a name="./start:s6"></a><tt>+</tt>, <a name="./start:s7"></a><tt>-</tt>, <a name="./start:s8"></a><tt>*</tt>, <a name="./start:s9"></a><tt>/</tt> 来对应算术过程。
  每个过程都接受两个参数。
  下面的表达式称作<a name="./start:s10"></a><i>过程应用</i>,
  因为它们把一个过程应用于一组参数之上。
  
<p>

<p><tt>(+&nbsp;1/2&nbsp;1/2)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;1<br>

(-&nbsp;1.5&nbsp;1/2)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;1.0
<br>
<br>
(*&nbsp;3&nbsp;1/2)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;3/2<br>

(/&nbsp;1.5&nbsp;3/4)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;2.0</tt>
  
<p>
  Scheme即使对普通的算术操作也采用了<a name="./start:s11"></a>前缀表达式记。
  任何过程应用，不管这个过程接受0、1或更多参数，都写作这种形式：<tt>(<i>procedure</i>&nbsp;<i>arg</i>&nbsp;...)</tt>。
  这个规则简化了表达式的语法，无论什么操作都使用同一种记法，
  并且操作的<a name="./start:s12"></a>优先级和结合性方面没有任何复杂的规则。

<p>
  过程的应用可以嵌套，这种情况下最内层的值被最先求出。
  所以我们可以把上面给出的算术过程嵌套起来应用，来计算更复杂的公式。

<p>

<p><tt>(+&nbsp;(+&nbsp;2&nbsp;2)&nbsp;(+&nbsp;2&nbsp;2))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;8<br>

(-&nbsp;2&nbsp;(*&nbsp;4&nbsp;1/3))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;2/3<br>

(*&nbsp;2&nbsp;(*&nbsp;2&nbsp;(*&nbsp;2&nbsp;(*&nbsp;2&nbsp;2))))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;32<br>

(/&nbsp;(*&nbsp;6/7&nbsp;7/2)&nbsp;(-&nbsp;4.5&nbsp;1.5))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;1.0</tt>
  
<p>
  这些示例演示了如何把Scheme当做四则运算计算器来使用。
  Scheme支持更多其他的算术过程，但我们不打算在这章里进行讨论。
  现在可能是一个去<a href="./objects.html#g110">6.4</a>节体验一下的好时机。

<p>
<p>
  
  <a name="./start:s13"></a>简单数值对象在大多数任务中已经足够用了，
  但是有时候我们会需要包含两个或多个值的复合数据结构。
  在很多语言中，最基础的复合数据结构是数组。在Scheme中，是<i>列表</i>。
  列表写作一个用小括号包围起来的对象序列。例如：<tt>(1&nbsp;2&nbsp;3&nbsp;4&nbsp;5)</tt> 是一个数值列表，
  <tt>("this"&nbsp;"is"&nbsp;"a"&nbsp;"list")</tt> 是一个字符串列表。
  列表不需要只包含同一种对象，所以<tt>(4.2&nbsp;"hi")</tt>这样包含一个数值和一个字符串的列表也是合法的。
  列表可以嵌套（可以包含其他的列表），所以<tt>((1&nbsp;2)&nbsp;(3&nbsp;4))</tt>也是个合法的列表，它包含两个元素，每个元素都是一个包含两个元素的列表。

<p>
  你可能注意到列表很像过程应用，并且想知道Scheme如何区分他们。
  换句话说，Scheme如何区分一个对象列表<tt>(<i>obj<sub>1</sub></i>&nbsp;<i>obj<sub>2</sub></i>&nbsp;...)</tt>
  和一个 <a name="./start:s14"></a>过程调用<tt>(<i>procedure</i>&nbsp;<i>arg</i>&nbsp;...)</tt>？

<p>
  在某些情况下，区分是比较明显的。
  一个数值列表 <tt>(1&nbsp;2&nbsp;3&nbsp;4&nbsp;5)</tt> 很难和一个过程应用搞混，
  因为1是一个数值，不是一个过程。
  所以答案可能是Scheme查看列表或过程应用的第一个元素，并且根据它是不是一个过程来做决定。
  这个回答并不够好，因为我们可能真的想要把一个合法的过程应用比如 <tt>(+&nbsp;3&nbsp;4)</tt> 当做列表数据而不当做过程应用。
  我们用 <a name="./start:s15"></a><a name="./start:s16"></a><tt>quote</tt>来实现这个目的。
  
<p>

<p><tt>(quote&nbsp;(1&nbsp;2&nbsp;3&nbsp;4&nbsp;5))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(1&nbsp;2&nbsp;3&nbsp;4&nbsp;5)<br>

(quote&nbsp;("this"&nbsp;"is"&nbsp;"a"&nbsp;"list"))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;("this"&nbsp;"is"&nbsp;"a"&nbsp;"list")<br>

(quote&nbsp;(+&nbsp;3&nbsp;4))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(+&nbsp;3&nbsp;4)</tt>
<p>
  
  <tt>quote</tt> 强制把一个列表当做数据来看待。尝试把上面表达式中的quote去掉，前两个表达式你会收到一个异常消息，
  第三个你会得到一个不正确的结果（<tt>7</tt>）。

<p>
  由于 <tt>quote</tt> 在Scheme中使用的太过频繁，Scheme规定一个单引号（&nbsp;<tt>'</tt>&nbsp;）放在一个表达式前面来作为 <tt>quote</tt>的简写形式。

<p>

<p><tt>'(1&nbsp;2&nbsp;3&nbsp;4)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(1&nbsp;2&nbsp;3&nbsp;4)<br>

'((1&nbsp;2)&nbsp;(3&nbsp;4))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;((1&nbsp;2)&nbsp;(3&nbsp;4))<br>

'(/&nbsp;(*&nbsp;2&nbsp;-1)&nbsp;3)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(/&nbsp;(*&nbsp;2&nbsp;-1)&nbsp;3)</tt>
  
<p>
  两种形式都代表 <tt>quote</tt> 表达式。
  我们通常称一个在<tt>quote</tt>中包围着的表达式是被 <i>引用（quoted）</i> 的。

<p>
  <tt>quote</tt> 表达式<i>不是</i> 过程应用，因为它的子表达式被禁止求值。
  这是一个完全不同的语法形式。
  除了过程应用和<tt>quote</tt>表达式外，Scheme还支持一些其它的 <a name="./start:s17"></a>语法形式。
  每一种语法形式的求值都是不同的。
  还好语法形式的数量并不太多。我们将会在这一章的后续部分看到更多的其他语法形式。

<p>
  不是所有的 <tt>quote</tt> 表达式都包含列表。试一下下面这个表达式，加或者不加 <tt>quote</tt> 。

<p>

<p><tt>(quote&nbsp;hello)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;hello</tt>
  
<p>
  符号 <tt>hello</tt>必须加上quote以防Scheme把 <tt>hello</tt> 当做一个 <i>变量</i>。
  Scheme中的符号和 <a name="./start:s18"></a>变量和数学表达式、方程中的<a name="./start:s19"></a>符号和变量很类似。
  当我们计算一个数学表达式 1 - <i>x</i> 在<i>x</i>取某值时的结果时，我们把 <i>x</i> 当做一个变量。
  而对于<i>x</i><sup>2</sup> - 1 = (<i>x</i> - 1)(<i>x</i> + 1)代数方程来说，我们把 <i>x</i> 视作符号（事实整个方程都视为符号）。
  如同quote让Scheme把一个小括号形式视为列表而非过程调用一样，quote能让Scheme把一个标识符视为符号而非变量。
  符号不仅用来在方程或程序的符号表示中代表变量，还经常用来表示自然语言的句子中的单词。

<p>
  你可能想知道为什么过程应用和变量要与列表和符号公用同一套记法。
  这是因为这样能让Scheme把程序表示成Scheme数据，简化Scheme的解释器、编译器、编辑器和其他工具的书写。
  在<a href="./examples.html#g187">12.7</a>节有一个Scheme解释器的演示程序，是由Scheme自身编写的。
  很多人相信这是Scheme最重要的特性之一。

<p>
  数值和字符串也可以被quote。

<p>

<p><tt>'2&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;2<br>

'2/3&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;2/3<br>

(quote&nbsp;"Hi&nbsp;Mom!")&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;"Hi&nbsp;Mom!"</tt>
<p>
  数值和字符串反正也会被当成常量对待，所以对它们的quote是不必要的。

<p>
<p>
  现在我们来讨论一些操作 <a name="./start:s20"></a>列表的Scheme过程。
  有两个基础过程用来拆分列表 <a name="./start:s21"></a><tt>car</tt> 和<a name="./start:s22"></a><tt>cdr</tt> (读作 <i>could-er</i>)。
  <tt>car</tt>返回一个列表的第一项，<tt>cdr</tt> 返回列表余下的部分。
  （car和cdr这两个名字是从实现了Lisp语言的第一台电脑IBM 704上支持的操作继承而来的）。
  它们都要求参数是一个非空列表。

<p>

<p><tt>(car&nbsp;'(a&nbsp;b&nbsp;c))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;a<br>

(cdr&nbsp;'(a&nbsp;b&nbsp;c))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(b&nbsp;c)<br>

(cdr&nbsp;'(a))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;()
<br>
<br>
(car&nbsp;(cdr&nbsp;'(a&nbsp;b&nbsp;c)))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;b<br>

(cdr&nbsp;(cdr&nbsp;'(a&nbsp;b&nbsp;c)))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(c)
<br>
<br>
(car&nbsp;'((a&nbsp;b)&nbsp;(c&nbsp;d)))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(a&nbsp;b)<br>

(cdr&nbsp;'((a&nbsp;b)&nbsp;(c&nbsp;d)))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;((c&nbsp;d))</tt>
<p>
  列表的第一项通常叫做这个列表的car， 余下的部分通常叫做这个列表的cdr。

  只有一个元素的列表的cdr是 <a name="./start:s23"></a><tt>()</tt>，<a name="./start:s24"></a><i>空表</i>。

<p>
  过程 <a name="./start:s25"></a><tt>cons</tt> 用来构建列表。
  它接受两个参数，第二个参数通常是一个列表，这种情况下 <tt>cons</tt>返回一个列表。

<p>

<p><tt>(cons&nbsp;'a&nbsp;'())&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(a)<br>

(cons&nbsp;'a&nbsp;'(b&nbsp;c))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(a&nbsp;b&nbsp;c)<br>

(cons&nbsp;'a&nbsp;(cons&nbsp;'b&nbsp;(cons&nbsp;'c&nbsp;'())))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(a&nbsp;b&nbsp;c)<br>

(cons&nbsp;'(a&nbsp;b)&nbsp;'(c&nbsp;d))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;((a&nbsp;b)&nbsp;c&nbsp;d)
<br>
<br>
(car&nbsp;(cons&nbsp;'a&nbsp;'(b&nbsp;c)))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;a<br>

(cdr&nbsp;(cons&nbsp;'a&nbsp;'(b&nbsp;c)))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(b&nbsp;c)<br>

(cons&nbsp;(car&nbsp;'(a&nbsp;b&nbsp;c))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cdr&nbsp;'(d&nbsp;e&nbsp;f)))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(a&nbsp;e&nbsp;f)<br>

(cons&nbsp;(car&nbsp;'(a&nbsp;b&nbsp;c))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cdr&nbsp;'(a&nbsp;b&nbsp;c)))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(a&nbsp;b&nbsp;c)</tt>
<p>
  car和cdr经常被用于名词，cons而经常被用于动词。
  把一个元素添加到一个列表的头部来创建一个新的列表，被称作 <a name="./start:s26"></a><i>consing</i> 这个元素到这个列表上。

<p>
  注意在 <tt>cons</tt>描述第二个参数时我们使用了“通常”这个词。
  <tt>cons</tt>实际上构建的是一个 <a name="./start:s27"></a><i>序对（pairs）</i>，而一个序对的cdr并不必是一个列表。
  一个列表是个序对的序列，每个序对的cdr都是序列中下一个序对。
<p>
  <img src="math/tspl/1.gif" alt="<graphic>"><p>
    
    
    一个<a name="./start:s28"></a><i>正规列表</i> 的最后一个序对的cdr应该是一个空表。
    否则，这个序对序列形成的叫做 <a name="./start:s29"></a><i>非正规列表</i>。
    更形式上来说，空表是正规列表，任何一个cdr为正规列表的序对都是一个正规列表。

<p>
  非正规列表用 <i>点对记法</i>来输出，用一个句号，或者 <a name="./start:s30"></a><a name="./start:s31"></a><i>点号</i>，
  放在列表的最后一个元素之前。

<p>

<p><tt>(cons&nbsp;'a&nbsp;'b)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(a&nbsp;.&nbsp;b)<br>

(cdr&nbsp;'(a&nbsp;.&nbsp;b))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;b<br>

(cons&nbsp;'a&nbsp;'(b&nbsp;.&nbsp;c))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(a&nbsp;b&nbsp;.&nbsp;c)</tt>
  
<p>
  由于这种打印方法，一个cdr不是列表的序对通常被称为 <a name="./start:s32"></a><i>点对</i>。
  实际上每个cdr是列表的序对都能写成点对的形式，虽然在打印正规列表的时候通常都是不带点号的。

<p>

<p><tt>'(a&nbsp;.&nbsp;(b&nbsp;.&nbsp;(c&nbsp;.&nbsp;())))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(a&nbsp;b&nbsp;c)</tt>
<p>
  <a name="./start:s33"></a><tt>list</tt>过程和 <tt>cons</tt>过程比较相似，除了它是接受任意数量的参数，并且总是构建一个正规列表。

<p>

<p><tt>(list&nbsp;'a&nbsp;'b&nbsp;'c)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(a&nbsp;b&nbsp;c)<br>

(list&nbsp;'a)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(a)<br>

(list)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;()</tt>
  
<p>
  <a href="./objects.html#g109">6.3</a>节提供了关于列表和操作列表的Scheme过程的更详尽信息。
  现在是一个很好的机会去那一节熟悉那里提到的其它过程。

<p>

<h4>Exercise <a name="g7"></a>2.2.1</h4>
<a name="./start:s34"></a>把下面的算术表达式转化成Scheme表达式并且求值。

<p>

 
 <table>
<tr valign=top><td><i>&nbsp;&nbsp;a</i>.</td><td>1.2 &times; (2 - 1/3) + -8.7
<tr valign=top><td><i>&nbsp;&nbsp;b</i>.</td><td>(2/3 + 4/9) &divide; (5/11 - 4/3)
<tr valign=top><td><i>&nbsp;&nbsp;c</i>.</td><td>1 + 1 &divide; (2 + 1 &divide; (1 + 1/2))
<tr valign=top><td><i>&nbsp;&nbsp;d</i>.</td><td>1 &times; -2 &times; 3 &times; -4 &times; 5 &times; -6 &times; 7
</table>

<p>


<p>

<h4>Exercise <a name="g8"></a>2.2.2</h4>
<a name="./start:s35"></a>尝试 <tt>+</tt>, <tt>-</tt>, <tt>*</tt>和<tt>/</tt>，确定一下当提供不同类型的数值参数时，
返回值类型依据什么规则来确定的。

<p>


<p>

<h4>Exercise <a name="g9"></a>2.2.3</h4>
<a name="./start:s36"></a><a name="EXEXPRVALUE"></a>确定下面这些表达式的值，用你的Scheme系统来验证你的答案。
<p>

 
 <table>
<tr valign=top><td><i>&nbsp;&nbsp;a</i>.</td><td><tt>(cons&nbsp;'car&nbsp;'cdr)</tt>
<tr valign=top><td><i>&nbsp;&nbsp;b</i>.</td><td><tt>(list&nbsp;'this&nbsp;'(is&nbsp;silly))</tt>
<tr valign=top><td><i>&nbsp;&nbsp;c</i>.</td><td><tt>(cons&nbsp;'is&nbsp;'(this&nbsp;silly?))</tt>
<tr valign=top><td><i>&nbsp;&nbsp;d</i>.</td><td><tt>(quote&nbsp;(+&nbsp;2&nbsp;3))</tt>
<tr valign=top><td><i>&nbsp;&nbsp;e</i>.</td><td><tt>(cons&nbsp;'+&nbsp;'(2&nbsp;3))</tt>
<tr valign=top><td><i>&nbsp;&nbsp;f</i>.</td><td><tt>(car&nbsp;'(+&nbsp;2&nbsp;3))</tt>
<tr valign=top><td><i>&nbsp;&nbsp;g</i>.</td><td><tt>(cdr&nbsp;'(+&nbsp;2&nbsp;3))</tt>
<tr valign=top><td><i>&nbsp;&nbsp;h</i>.</td><td><tt>cons</tt>
<tr valign=top><td><i>&nbsp;&nbsp;i</i>.</td><td><tt>(quote&nbsp;cons)</tt>
<tr valign=top><td><i>&nbsp;&nbsp;j</i>.</td><td><tt>(quote&nbsp;(quote&nbsp;cons))</tt>
<tr valign=top><td><i>&nbsp;&nbsp;k</i>.</td><td><tt>(car&nbsp;(quote&nbsp;(quote&nbsp;cons)))</tt>
<tr valign=top><td><i>&nbsp;&nbsp;l</i>.</td><td><tt>(+&nbsp;2&nbsp;3)</tt>
<tr valign=top><td><i>&nbsp;&nbsp;m</i>.</td><td><tt>(+&nbsp;'2&nbsp;'3)</tt>
<tr valign=top><td><i>&nbsp;&nbsp;n</i>.</td><td><tt>(+&nbsp;(car&nbsp;'(2&nbsp;3))&nbsp;(car&nbsp;(cdr&nbsp;'(2&nbsp;3))))</tt>
<tr valign=top><td><i>&nbsp;&nbsp;o</i>.</td><td><tt>((car&nbsp;(list&nbsp;+&nbsp;-&nbsp;*&nbsp;/))&nbsp;2&nbsp;3)</tt>
</table>

<p>


<p>

<h4>Exercise <a name="g10"></a>2.2.4</h4>
<a name="./start:s37"></a><tt>(car&nbsp;(car&nbsp;'((a&nbsp;b)&nbsp;(c&nbsp;d))))</tt>得到<tt>a</tt>.
确定什么样的 <tt>car</tt> 和<tt>cdr</tt> 的组合
应用<tt>((a&nbsp;b)&nbsp;(c&nbsp;d))</tt> 能得到 <tt>b</tt>, <tt>c</tt>和<tt>d</tt>。

<p>


<p>

<h4>Exercise <a name="g11"></a>2.2.5</h4>
<a name="./start:s38"></a>写出一个Scheme表达式，求值能得到下面这个列表结构。

<p>
<p>
<img src="math/tspl/2.gif" alt="<graphic>"><p>


<p>


<p>

<h4>Exercise <a name="g12"></a>2.2.6</h4>
<a name="./start:s39"></a>
画出下面这个表达式的内部列表结构。

<p>

<p><tt>(cons&nbsp;1&nbsp;(cons&nbsp;'(2&nbsp;.&nbsp;((3)&nbsp;.&nbsp;()))&nbsp;(cons&nbsp;'(())&nbsp;(cons&nbsp;4&nbsp;5))))</tt>
<p>


<p>

<h4>Exercise <a name="g13"></a>2.2.7</h4>
<a name="./start:s40"></a>
<tt>(car&nbsp;(car&nbsp;(car&nbsp;'((a&nbsp;b)&nbsp;(c&nbsp;d)))))</tt> 的行为是未定义的，因为
<tt>(car&nbsp;'((a&nbsp;b)&nbsp;(c&nbsp;d)))</tt> 是<tt>(a&nbsp;b)</tt>，
<tt>(car&nbsp;'(a&nbsp;b))</tt> 是 <tt>a</tt>，
而 <tt>(car&nbsp;'a)</tt> 是未定义的。
找出能应用于 <tt>((a&nbsp;b)&nbsp;(c&nbsp;d))</tt> 上的 <tt>car</tt> 和 <tt>cdr</tt> 的所有合法组合。

<p>


<p>

<h4>Exercise <a name="g14"></a>2.2.8</h4>
<a name="./start:s41"></a>尝试解释Scheme的表达式是如何求值的。
你的解释能覆盖Exercise&nbsp;<a href="./start.html#g9">2.2.3</a>的最后一项么？

<p>


<p>

<h3><a name="g15"></a><a name="./start:h3"></a>2.3. Scheme表达式求值<a name="SECTGSEVALUATING"></a></h3>



<p>
  我们来讨论一下Scheme是如何对你输入的表达式进行求值的。

  我们已经建立了 <a name="./start:s42"></a>常量对象的求值规则，例如字符串和数值：它们的值就是它们自身。
  你可能已经在心里想出了形如<tt>(<i>procedure</i>&nbsp;<i>arg<sub>1</sub></i>&nbsp;...&nbsp;<i>arg<sub>n</sub></i>)</tt>这样的
  <a name="./start:s43"></a>过程应用的求值规则，
  其中<tt><i>procedure</i></tt> 是一个表示Scheme过程的表达式，而 <tt><i>arg<sub>1</sub></i>&nbsp;...&nbsp;<i>arg<sub>n</sub></i></tt> 是它所需要的参数。一个可能的规则如下：

<p>
<ul>
<li>得到 <tt><i>procedure</i></tt>的值。

<p>
<li>得到<tt><i>arg<sub>1</sub></i></tt>的值。

<p>
<img src="math/tspl/3.gif" alt="<graphic>">

<p>
<li>得到 <tt><i>arg<sub>n</sub></i></tt>的值。

<p>
<li>把<tt><i>procedure</i></tt>的值应用于
<tt><i>arg<sub>1</sub></i>&nbsp;...&nbsp;<i>arg<sub>n</sub></i></tt>的值之上。
</ul>
<p>

<p>
  例如，考虑这个简单的过程应用： <tt>(+&nbsp;3&nbsp;4)</tt>。
  <tt>+</tt> 的值是加法过程，数值3的值是3，数值4的值是4。
  把加法过程应用于3和4上，得到7.所以求值结果是对象7。

<p>
  逐层的使用这个规则，我们能够得到嵌套表达式 <tt>(*&nbsp;(+&nbsp;3&nbsp;4)&nbsp;2)</tt>的值。
  <tt>*</tt>的值是乘法过程，<tt>(+&nbsp;3&nbsp;4)</tt>能够算出结果是7，数值2的值是2。
  7乘以2等于14，所以答案是14。

<p>
  这个规则对过程应用有效，但是对<a name="./start:s44"></a><a name="./start:s45"></a><tt>quote</tt>表达式无效。
  因为过程应用的子表达式会被求值，而 <tt>quote</tt> 表达式的子表达式不会求值。
  <tt>quote</tt> 表达式的求值甚至比常量对象的求值还简单。
  形如<tt>(quote&nbsp;<i>object</i>)</tt>这样的 <tt>quote</tt> 表达式的值就是 <tt><i>object</i></tt>。

<p>
  常量对象、过程应用和 <tt>quote</tt> 表达式只是Scheme提供的众多语法形式中的三种。
  幸运的是，只有少量的语法形式需要Scheme程序员直接理解，它们就是<i>核心（core）</i> 语法形式。
  其余的语法形式是 <a name="./start:s46"></a><i>syntactic extensions</i>定义的，
  本质上依赖于 <a name="./start:s47"></a>核心语法形式。
  我们将会在本章讨论剩下的核心语法形式和一些语法扩展。
  <a href="./further.html#g50">3.1</a>节将概要的介绍核心语法形式和语法扩展机制。


<p>
<p>
  在我们继续接触更多语法形式和过程之前，要提两点和过程应用求值相关的事情。
<a name="./start:s48"></a>首先，上面给出的求值过程是冗余的，它要求子表达式从左到右求值。就是说
<tt><i>procedure</i></tt>要在<tt><i>arg<sub>1</sub></i></tt>之前求值，
<tt><i>arg<sub>1</sub></i></tt>要在<tt><i>arg<sub>2</sub></i></tt>之前求值，以此类推。
但是实际上这是不必要的。
Scheme的求值器可以对表达式以任意顺序求值，从左到右、从右到左，或者其他任何顺序。
事实上，甚至在同一个实现的不同过程应用中，子表达式都有可能以不同的顺序求值。

<p>
第二点是<tt><i>procedure</i></tt>和<tt><i>arg<sub>1</sub></i>&nbsp;...&nbsp;<i>arg<sub>n</sub></i></tt>的求值方式是相同的。
虽然<tt><i>procedure</i></tt>经常是一个表示过程的变量，但并不总是这样。
Exercise&nbsp;<a href="./start.html#g9">2.2.3</a>让你求<tt>((car&nbsp;(list&nbsp;+&nbsp;-&nbsp;*&nbsp;/))&nbsp;2&nbsp;3)</tt>的值。
这里<tt><i>procedure</i></tt>是<tt>(car&nbsp;(list&nbsp;+&nbsp;-&nbsp;*&nbsp;/))</tt>。
<tt>(car&nbsp;(list&nbsp;+&nbsp;-&nbsp;*&nbsp;/))</tt>的值是加法过程，就跟<tt><i>procedure</i></tt>直接写成<tt>+</tt>一样。

<p>

<h4>Exercise <a name="g16"></a>2.3.1</h4>
<a name="./start:s49"></a>写出求值下面表达式所必须的步骤：

<p>

<p><tt>((car&nbsp;(cdr&nbsp;(list&nbsp;+&nbsp;-&nbsp;*&nbsp;/)))&nbsp;17&nbsp;5)</tt>
<p>

<p>

<h3><a name="g17"></a><a name="./start:h4"></a>2.4. 变量和Let表达式<a name="SECTGSIDENTIFIERS"></a></h3>



<p>
<a name="./start:s50"></a>假设<tt><i>expr</i></tt>是一个表达式，其中包含一个变量<tt><i>var</i></tt>。
再假设，当我们求值<tt><i>expr</i></tt>的时候，我们希望<tt><i>var</i></tt>的值为<tt><i>val</i></tt>。
例如，我们可能希望在求值<tt>(+&nbsp;x&nbsp;3)的时候让</tt><tt>x</tt>等于2，
或者希望在求值<tt>(+&nbsp;2&nbsp;y)</tt>的时候让<tt>y</tt>等于3。

下面的示例展示如何用<a name="./start:s51"></a><tt>let</tt>语法形式做到这一点

<p>

<p><tt>(let&nbsp;((x&nbsp;2))<br>

&nbsp;&nbsp;(+&nbsp;x&nbsp;3))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;5
<br>
<br>
(let&nbsp;((y&nbsp;3))<br>

&nbsp;&nbsp;(+&nbsp;2&nbsp;y))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;5
<br>
<br>
(let&nbsp;((x&nbsp;2)&nbsp;(y&nbsp;3))<br>

&nbsp;&nbsp;(+&nbsp;x&nbsp;y))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;5</tt>
<p>
  <tt>let</tt>语法形式包括一个变量-表达式对的列表，后面跟着一系列表达式作为<tt>let</tt>的<i>主体（body）</i>。
<tt>let</tt>表达式的一般形式如下：

<p>

<p><tt>(let&nbsp;((<i>var</i>&nbsp;<i>expr</i>)&nbsp;...)&nbsp;<i>body<sub>1</sub></i>&nbsp;<i>body<sub>2</sub></i>&nbsp;...)</tt>
<p><a name="./start:s52"></a>我们说通过<a name="./start:s53"></a><tt>let</tt>表达式，变量被<i>绑定（bound）</i>到值上。


<p>
<tt>let</tt>表达式通常用来简化包含两个相同子表达式的表达式。
这么做同时也保证了公共表达式只被计算一次。

<p>

<p><tt>(+&nbsp;(*&nbsp;4&nbsp;4)&nbsp;(*&nbsp;4&nbsp;4))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;32
<br>
<br>
(let&nbsp;((a&nbsp;(*&nbsp;4&nbsp;4)))&nbsp;(+&nbsp;a&nbsp;a))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;32</tt>
<p>
  
<tt>let</tt>表达式的绑定部分的小括号通常用中括号来代替。

<p>

<p><tt>(let&nbsp;([list1&nbsp;'(a&nbsp;b&nbsp;c)]&nbsp;[list2&nbsp;'(d&nbsp;e&nbsp;f)])<br>

&nbsp;&nbsp;(cons&nbsp;(cons&nbsp;(car&nbsp;list1)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(car&nbsp;list2))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cons&nbsp;(car&nbsp;(cdr&nbsp;list1))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(car&nbsp;(cdr&nbsp;list2)))))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;((a&nbsp;.&nbsp;d)&nbsp;b&nbsp;.&nbsp;e)</tt>
<p>
  Scheme对小括号和中括号的处理是一样的。
  中括号必须和中括号配对，小括号必须和小括号配对。
  我们在<tt>let</tt>（你将会看到还有其它的一些标准语法形式）中使用中括号，来提高可读性，
  尤其是如果不用它我们将会遇到两个或更多左小括号“（”连续出现的情况。
  

<p>
  由于过程应用中第一个位置的表达式求值实际上和其他表达式没有区别，因此<tt>let</tt>绑定的变量同样可以放在这个位置上。

<p>

<p><tt>(let&nbsp;([f&nbsp;+])<br>

&nbsp;&nbsp;(f&nbsp;2&nbsp;3))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;5
<br>
<br>
(let&nbsp;([f&nbsp;+]&nbsp;[x&nbsp;2])<br>

&nbsp;&nbsp;(f&nbsp;x&nbsp;3))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;5
<br>
<br>
(let&nbsp;([f&nbsp;+]&nbsp;[x&nbsp;2]&nbsp;[y&nbsp;3])<br>

&nbsp;&nbsp;(f&nbsp;x&nbsp;y))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;5</tt>
<p>由<tt>let</tt>绑定的变量只在<tt>let</tt>主体中可见。

<p>

<p><tt>(let&nbsp;([+&nbsp;*])<br>

&nbsp;&nbsp;(+&nbsp;2&nbsp;3))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;6
<br>
<br>
(+&nbsp;2&nbsp;3)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;5</tt>
<p>这样还算不错，因为我们并不想在所有地方让<tt>+</tt>取代乘法运算。

<p>
<tt>let</tt>表达式是可以嵌套的。

<p>

<p><tt>(let&nbsp;([a&nbsp;4]&nbsp;[b&nbsp;-3])<br>

&nbsp;&nbsp;(let&nbsp;([a-squared&nbsp;(*&nbsp;a&nbsp;a)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[b-squared&nbsp;(*&nbsp;b&nbsp;b)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;(+&nbsp;a-squared&nbsp;b-squared)))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;25</tt>
<p>
  我们用<tt>let</tt>表达式嵌套的绑定同一个变量，只有里面的<tt>let</tt>绑定的变量才在最里面的主体中可见。

<p>

<p><tt>(let&nbsp;([x&nbsp;1])<br>

&nbsp;&nbsp;(let&nbsp;([x&nbsp;(+&nbsp;x&nbsp;1)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;(+&nbsp;x&nbsp;x)))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;4</tt>


<p>外围的<tt>let</tt>表达式把<tt>x</tt>绑定成了1，范围限制在它的主体内，也就是内层的那个
<tt>let</tt>表达式。
内层的<tt>let</tt>表达式把<tt>x</tt> 绑定成了 <tt>(+&nbsp;x&nbsp;1)</tt>，范围限制在它的主体内，也就是
<tt>(+&nbsp;x&nbsp;x)</tt>这个表达式。
<tt>(+&nbsp;x&nbsp;1)</tt>值是什么？

虽然<tt>(+&nbsp;x&nbsp;1)</tt>出现在了外围<tt>let</tt>表达式的主体中，
但是不在内层<tt>let</tt>表达式的主体中, <tt>x</tt>的值应该是1，<tt>(+&nbsp;x&nbsp;1)</tt> 的值是2。

那么<tt>(+&nbsp;x&nbsp;x)</tt>呢？
它出现在内外两个<tt>let</tt>表达式的主体中。
只有内层的<tt>x</tt>绑定是可见的。所以<tt>x</tt>的值为2， 
<tt>(+&nbsp;x&nbsp;x)</tt>的值是4。


<p>
<a name="./start:s54"></a>我们称内层的<tt>x</tt> 绑定<i>遮蔽（shadow）</i>了外层绑定。
<tt>let</tt>绑定的变量在整个<tt>let</tt>范围内都可见，除非被遮蔽。
一个变量绑定能够可见的范围被称作<a name="./start:s55"></a><i>作用域（scope）</i>。
这个例子中外面这个<tt>x</tt>的作用域是外面这个<tt>let</tt>表达式的范围，
减去里面<tt>let</tt>表达式的作用域，因为在那里它被第二个<tt>x</tt>遮蔽了。

这种形式的作用域被称作 <a name="./start:s56"></a><i>词法作用域</i>，
因为每一个绑定的作用域都可以直接通过程序的字面分析直接得到。

<p>
  遮蔽可以通过给变量起不同的名字来避免。
  上面那个表达式可以重写，让内层<tt>let</tt>绑定的那个变量叫做<tt>new-x</tt>。

<p>

<p><tt>(let&nbsp;([x&nbsp;1])<br>

&nbsp;&nbsp;(let&nbsp;([new-x&nbsp;(+&nbsp;x&nbsp;1)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;(+&nbsp;new-x&nbsp;new-x)))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;4</tt>
<p>
  尽管起不同的名字有时候能够预防混乱产生，但是遮蔽其实在防止由“旧的”值造成的事故方面是非常有效的。
  比如，对于前面那个示例的最初版本而言，它能够阻止我们不小心在最内层的<tt>let</tt>中使用了最外层的<tt>x</tt>。
  
<p>

<h4>Exercise <a name="g18"></a>2.4.1</h4>
<a name="./start:s57"></a>重写下面的表达式，用<tt>let</tt>来去掉公共的子表达式，改善代码的结构。
不要做任何的代数化简。

<p>

 
 <table>
<tr valign=top><td><i>&nbsp;&nbsp;a</i>.</td><td><tt>(+&nbsp;(-&nbsp;(*&nbsp;3&nbsp;a)&nbsp;b)&nbsp;(+&nbsp;(*&nbsp;3&nbsp;a)&nbsp;b))</tt>
<tr valign=top><td><i>&nbsp;&nbsp;b</i>.</td><td><tt>(cons&nbsp;(car&nbsp;(list&nbsp;a&nbsp;b&nbsp;c))&nbsp;(cdr&nbsp;(list&nbsp;a&nbsp;b&nbsp;c)))</tt>
</table>

<p>


<p>

<h4>Exercise <a name="g19"></a>2.4.2</h4>
<a name="./start:s58"></a>确定下面这些表达式的值。解释你是如何得到这个值的。

<p>

<p><tt>(let&nbsp;([x&nbsp;9])<br>

&nbsp;&nbsp;(*&nbsp;x<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([x&nbsp;(/&nbsp;x&nbsp;3)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(+&nbsp;x&nbsp;x))))</tt>
<p>

<p>

<h4>Exercise <a name="g20"></a>2.4.3</h4>
<a name="./start:s59"></a>
重写下面的表达式，给每个<tt>let</tt>绑定的变量一个唯一的名字，来防止任何变量被遮蔽。
验证你得到的新表达式结果和原始表达式的结果一致。

<p>

 
 <table>
<tr valign=top><td><i>&nbsp;&nbsp;a</i>.</td><td>
<p><tt>(let&nbsp;([x&nbsp;'a]&nbsp;[y&nbsp;'b])<br>

&nbsp;&nbsp;(list&nbsp;(let&nbsp;([x&nbsp;'c])&nbsp;(cons&nbsp;x&nbsp;y))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([y&nbsp;'d])&nbsp;(cons&nbsp;x&nbsp;y))))</tt>
<p><tr valign=top><td><i>&nbsp;&nbsp;b</i>.</td><td>
<p><tt>(let&nbsp;([x&nbsp;'((a&nbsp;b)&nbsp;c)])<br>

&nbsp;&nbsp;(cons&nbsp;(let&nbsp;([x&nbsp;(cdr&nbsp;x)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(car&nbsp;x))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([x&nbsp;(car&nbsp;x)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cons&nbsp;(let&nbsp;([x&nbsp;(cdr&nbsp;x)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(car&nbsp;x))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cons&nbsp;(let&nbsp;([x&nbsp;(car&nbsp;x)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cdr&nbsp;x))))))</tt>
<p></table>

<p>



<p>

<h3><a name="g21"></a><a name="./start:h5"></a>2.5. Lambda表达式<a name="SECTGSLAMBDA"></a></h3>



<p>
  
  在表达式<tt>(let&nbsp;([x&nbsp;(*&nbsp;3&nbsp;4)])&nbsp;(+&nbsp;x&nbsp;x))</tt>中，变量
  <tt>x</tt>被绑定为<tt>(*&nbsp;3&nbsp;4)</tt>的值。
  如果我们想要<tt>x</tt>被绑定成<tt>(/&nbsp;99&nbsp;11)</tt>时<tt>(+&nbsp;x&nbsp;x)</tt>的值呢？
  这里我们需要一个新的<tt>let</tt>表达式。
  当<tt>let</tt>主体很复杂的时候，总是重复它显然不是很方便。
  
<p>
  我们可以用<a name="./start:s60"></a><tt>lambda</tt>语法形式取代之来创建新的
<a name="./start:s61"></a>过程，让<tt>x</tt>作为参数，并且主体和<tt>let</tt>表达式主体保持一致。

<p>

<p><tt>(lambda&nbsp;(x)&nbsp;(+&nbsp;x&nbsp;x))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#&lt;procedure&gt;</tt>
<p> <tt>lambda</tt>表达式的一般形式如下：

<p>

<p><tt>(lambda&nbsp;(<i>var</i>&nbsp;...)&nbsp;<i>body<sub>1</sub></i>&nbsp;<i>body<sub>2</sub></i>&nbsp;...)</tt>
<p>
  
  <tt><i>var</i>&nbsp;...</tt>是这个过程的<a name="./start:s62"></a><i>形式参数</i>，
  而那一系列表达式<tt><i>body<sub>1</sub></i>&nbsp;<i>body<sub>2</sub></i>&nbsp;...</tt>是这个过程的主体。
  （事实上，真正的一般形式比这个要更通用，你后面会看到）。

<p>
  过程和数值、字符串、符号、序对都差不多。但是它们不具备有意义的输出形式，
  所以本书使用了>#&lt;procedure&gt;</tt>这样的记法来代表一个表达式的值是个过程。

<p>
  对一个过程做的最常规的事情就是把它应用在一个或多个值上。

<p>

<p><tt>((lambda&nbsp;(x)&nbsp;(+&nbsp;x&nbsp;x))&nbsp;(*&nbsp;3&nbsp;4))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;24</tt>
<p>
  这和其他的<a name="./start:s63"></a>过程应用没有任何的区别。
  这个过程应用中，过程就是 <tt>(lambda&nbsp;(x)&nbsp;(+&nbsp;x&nbsp;x))</tt>的值，
  而唯一的参数则是<tt>(*&nbsp;3&nbsp;4)</tt>的值，也就是12。
  参数的值，或者称作<a name="./start:s64"></a><i>实参</i>，被绑定在<tt>lambda</tt>中的形参上，
  就如同<tt>lambda</tt>表达式绑定变量的值一样。
  在这个示例中，<tt>x</tt> 被绑定为12，于是<tt>(+&nbsp;x&nbsp;x)</tt>的值是24。
  因此把12作用在这个过程上的结果是24。

<p>
  因为过程就是对象，我们可以把一个过程当做一个变量的值，从而多次使用这个过程<a name="./start:s65"></a>。
  
<p>

<p><tt>(let&nbsp;([double&nbsp;(lambda&nbsp;(x)&nbsp;(+&nbsp;x&nbsp;x))])<br>

&nbsp;&nbsp;(list&nbsp;(double&nbsp;(*&nbsp;3&nbsp;4))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(double&nbsp;(/&nbsp;99&nbsp;11))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(double&nbsp;(-&nbsp;2&nbsp;7))))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(24&nbsp;18&nbsp;-10)</tt>
<p>这里，我们把变量<tt>double</tt>绑定到一个过程上，然后用这个过程给三个不同的值做了翻倍计算。

<p>
  由于这个过程要把实参传递给<tt>+</tt>，它期待的参数类型应该是数值型。
  一般来说，实参可以是任何类型的对象。例如我们考虑一个类似的过程，用<tt>cons</tt>替换了<tt>+</tt>。<a name="./start:s66"></a>
  
<p>

<p><tt>(let&nbsp;([double-cons&nbsp;(lambda&nbsp;(x)&nbsp;(cons&nbsp;x&nbsp;x))])<br>

&nbsp;&nbsp;(double-cons&nbsp;'a))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(a&nbsp;.&nbsp;a)</tt>
<p>
  留意<tt>double</tt>和<tt>double-cons</tt>的相似性，
  你应该不会太惊讶的发现，可以增加一个参数来让它们合成一个过程。

<p>

<p><tt>(let&nbsp;([double-any&nbsp;(lambda&nbsp;(f&nbsp;x)&nbsp;(f&nbsp;x&nbsp;x))])<br>

&nbsp;&nbsp;(list&nbsp;(double-any&nbsp;+&nbsp;13)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(double-any&nbsp;cons&nbsp;'a)))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(26&nbsp;(a&nbsp;.&nbsp;a))</tt>
<p>
  这个示例演示了一个过程可能接受超过一个参数，另外传递到一个过程中的参数本身可以是一个过程。

<p>
<p>
  和<tt>let</tt>表达式类似，<tt>lambda</tt>表达式在被嵌套于其它<tt>lambda</tt>或<tt>let</tt>表达式中的时候，
  甚至会更有趣一些。

<p>

<p><tt>(let&nbsp;([x&nbsp;'a])<br>

&nbsp;&nbsp;(let&nbsp;([f&nbsp;(lambda&nbsp;(y)&nbsp;(list&nbsp;x&nbsp;y))])<br>

&nbsp;&nbsp;&nbsp;&nbsp;(f&nbsp;'b)))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(a&nbsp;b)</tt>
<p>
  在<tt>lambda</tt>表达式中的那个<tt>x</tt>引用了在最外层的那个<tt>let</tt>中绑定的<tt>x</tt>。
  这个变量<tt>x</tt>被称为在这个<tt>lambda</tt>表达式中<a name="./start:s67"></a><i>自由存在</i>，
  或者称为这个<tt>lambda</tt>表达式中的<a name="./start:s68"></a><i>自由变量</i>。
  变量<tt>y</tt>并不是对这个<tt>lambda</tt>表达式自由存在的，因为它被这个<tt>lambda</tt>表达式绑定了。
  
  在一个<tt>lambda</tt>表达式中自由存在的变量应该被外层的<tt>lambda</tt>或
  <tt>let</tt>表达式绑定，除非这个变量是被这个表达式之外的某处绑定的，就像原始过程的名字一样。我们在本节后面会进行讨论。

<p>
  当一个过程在它的自由变量被绑定的作用域之外来调用的时候，例如下面的表达式，会发生什么呢？
  
<p>

<p><tt>(let&nbsp;([f&nbsp;(let&nbsp;([x&nbsp;'sam])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(y&nbsp;z)&nbsp;(list&nbsp;x&nbsp;y&nbsp;z)))])<br>

&nbsp;&nbsp;(f&nbsp;'i&nbsp;'am))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(sam&nbsp;i&nbsp;am)</tt>
<p>
  答案是，当这个过程被应用的时候，当初创建它时生效的那个（自由变量的）绑定依然有效。
  即使在过程应用时有另一个<tt>x</tt>的绑定可见，情况依然如此（译注：生效的是当初创建时的那个绑定）。

<p>

<p><tt>(let&nbsp;([f&nbsp;(let&nbsp;([x&nbsp;'sam])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(y&nbsp;z)&nbsp;(list&nbsp;x&nbsp;y&nbsp;z)))])<br>

&nbsp;&nbsp;(let&nbsp;([x&nbsp;'not-sam])<br>

&nbsp;&nbsp;&nbsp;&nbsp;(f&nbsp;'i&nbsp;'am)))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(sam&nbsp;i&nbsp;am)</tt>
<p>
  在这两种情况下，<tt>f</tt>过程内部的<tt>x</tt>的值都是<tt>sam</tt>。

<p>
<p>
  顺便提一下，一个<tt>let</tt>表达式和一个“把<tt>lambda</tt>表达式直接应用于一系列参数上”的表达式没有本质区别。
  例如，下面两个表达式是等价的。

<p>
<p><tt>(let&nbsp;([x&nbsp;'a])&nbsp;(cons&nbsp;x&nbsp;x))</tt>&nbsp;&equiv;&nbsp;<tt>((lambda&nbsp;(x)&nbsp;(cons&nbsp;x&nbsp;x))&nbsp;'a)</tt>

<p>
<p>
  试试上<a name="./start:s69"></a><tt>let</tt>就是由两个核心语法形式：<tt>lambda</tt>和过程应用所定义出来的语法扩展。

<p>

<p><tt>(let&nbsp;((<i>var</i>&nbsp;<i>expr</i>)&nbsp;...)&nbsp;<i>body<sub>1</sub></i>&nbsp;<i>body<sub>2</sub></i>&nbsp;...)</tt>
<p>和下面的表达式是等价的。

<p>

<p><tt>((lambda&nbsp;(<i>var</i>&nbsp;...)&nbsp;<i>body<sub>1</sub></i>&nbsp;<i>body<sub>2</sub></i>&nbsp;...)<br>

&nbsp;<i>expr</i>&nbsp;...)</tt>
<p>在&nbsp;<a href="./further.html#g50">3.1</a>节中有关于核心语法形式和语法扩展更详细的介绍。


<p>
<p>
  正如上面提到的，<a name="./start:s70"></a><a name="./start:s71"></a><tt>lambda</tt>的一般形式比之前我们见到的形式要更复杂一些，
  在形声明上，<tt>(<i>var</i>&nbsp;...)</tt>并不一定要求是一个确定的列表，甚至都不一定是一个列表。
  形参声明可以是下面三个形式中的任何一个：

<p>
<ul>
  <li>变量的正规列表<tt>(<i>var<sub>1</sub></i>&nbsp;...&nbsp;<i>var<sub>n</sub></i>)</tt>，就像我们之前见到的那样，

<p>
<li>一个单独的值 <tt><i>var<sub>r</sub></i></tt>（译注，没有括号），或者

<p>
<li>变量的非正规的列表<tt>(<i>var<sub>1</sub></i>&nbsp;...&nbsp;<i>var<sub>n</sub></i>&nbsp;.&nbsp;<i>var<sub>r</sub></i>)</tt>。
</ul>
<p>

<p>
  第一种情况下，必须提供恰好<i>n</i>个实参，并且每个变量绑定在对应的实参上。
  第二种情况下，任何数量的实参都是合法的；所有的实参被放在一个列表中，单个变量直接绑定这个列表。
  第三种情况是前两种情况的混合体。
  必须至少提供<i>n</i>个实参，变量 <tt><i>var<sub>1</sub></i>&nbsp;...&nbsp;<i>var<sub>n</sub></i></tt>被绑定到对应的实参上，
  而<tt><i>var<sub>r</sub></i></tt>则被绑定为剩下的所有实参组成的列表。
  在第二、三种情况下，<tt><i>var<sub>r</sub></i></tt>有时被称作“余项（rest）”参数，因为在单独命名的参数后面剩下的所有参数都绑定到它上面。

<p>
  为了弄清<tt>lambda</tt>表达式更一般语法的语法，我们考虑一些示例。

<p>

<p><tt>(let&nbsp;([f&nbsp;(lambda&nbsp;x&nbsp;x)])<br>

&nbsp;&nbsp;(f&nbsp;1&nbsp;2&nbsp;3&nbsp;4))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(1&nbsp;2&nbsp;3&nbsp;4)
<br>
<br>
(let&nbsp;([f&nbsp;(lambda&nbsp;x&nbsp;x)])<br>

&nbsp;&nbsp;(f))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;()
<br>
<br>
(let&nbsp;([g&nbsp;(lambda&nbsp;(x&nbsp;.&nbsp;y)&nbsp;(list&nbsp;x&nbsp;y))])<br>

&nbsp;&nbsp;(g&nbsp;1&nbsp;2&nbsp;3&nbsp;4))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(1&nbsp;(2&nbsp;3&nbsp;4))
<br>
<br>
(let&nbsp;([h&nbsp;(lambda&nbsp;(x&nbsp;y&nbsp;.&nbsp;z)&nbsp;(list&nbsp;x&nbsp;y&nbsp;z))])<br>

&nbsp;&nbsp;(h&nbsp;'a&nbsp;'b&nbsp;'c&nbsp;'d))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(a&nbsp;b&nbsp;(c&nbsp;d))</tt>
<p>
  在前两个示例中，过程 <tt>f</tt> 接受任意数量的参数。
  这些参数被自动组成一个列表并绑定给变量<tt>x</tt>，<tt>f</tt>的值就是这个车标。
  第一个示例中，参数是1, 2, 3, 4，所以结果就是 <tt>(1&nbsp;2&nbsp;3&nbsp;4)</tt> 。
  第二个示例中，没有参数，所以结果是一个空表 <tt>()</tt> 。
  在第三个示例中的过程 <tt>g</tt> 的值，是一个列表，它的第一个元素就是第一个参数，第二个元素则是参数表里剩下的所有元素组成的列表。
  过程 <tt>h</tt> 也是类似的，只是把第二个参数也区分出来了。
  <tt>f</tt> 接受任意数量的参数，<tt>g</tt> 必须接受至少一个参数，
  而 <tt>h</tt> 必须接受至少两个参数。

<p>

<h4>Exercise <a name="g22"></a>2.5.1</h4>
<a name="./start:s72"></a>确定下面这些表达式的值。

<p>

 
 <table>
<tr valign=top><td><i>&nbsp;&nbsp;a</i>.</td><td>
<p><tt>(let&nbsp;([f&nbsp;(lambda&nbsp;(x)&nbsp;x)])<br>

&nbsp;&nbsp;(f&nbsp;'a))</tt>
<p><tr valign=top><td><i>&nbsp;&nbsp;b</i>.</td><td>
<p><tt>(let&nbsp;([f&nbsp;(lambda&nbsp;x&nbsp;x)])<br>

&nbsp;&nbsp;(f&nbsp;'a))</tt>
<p><tr valign=top><td><i>&nbsp;&nbsp;c</i>.</td><td>
<p><tt>(let&nbsp;([f&nbsp;(lambda&nbsp;(x&nbsp;.&nbsp;y)&nbsp;x)])<br>

&nbsp;&nbsp;(f&nbsp;'a))</tt>
<p><tr valign=top><td><i>&nbsp;&nbsp;d</i>.</td><td>
<p><tt>(let&nbsp;([f&nbsp;(lambda&nbsp;(x&nbsp;.&nbsp;y)&nbsp;y)])<br>

&nbsp;&nbsp;(f&nbsp;'a))</tt>
<p></table>

<p>


<p>

<h4>Exercise <a name="g23"></a>2.5.2</h4>
<a name="./start:s73"></a>原始过程 <tt>list</tt> 可能是怎样定义的？

<p>


<p>

<h4>Exercise <a name="g24"></a>2.5.3</h4>
<a name="./start:s74"></a>列举出下面<tt>lambda</tt>表达式中所有的 <a name="./start:s75"></a>自由变量。
不要遗漏代表原始过程的变量例如 <tt>+</tt> 或 <tt>cons</tt> 。

<p>

 
 <table>
<tr valign=top><td><i>&nbsp;&nbsp;a</i>.</td><td><tt>(lambda&nbsp;(f&nbsp;x)&nbsp;(f&nbsp;x))</tt>
<tr valign=top><td><i>&nbsp;&nbsp;b</i>.</td><td><tt>(lambda&nbsp;(x)&nbsp;(+&nbsp;x&nbsp;x))</tt>
<tr valign=top><td><i>&nbsp;&nbsp;c</i>.</td><td><tt>(lambda&nbsp;(x&nbsp;y)&nbsp;(f&nbsp;x&nbsp;y))</tt>
<tr valign=top><td><i>&nbsp;&nbsp;d</i>.</td><td>
<p><tt>(lambda&nbsp;(x)<br>

&nbsp;&nbsp;(cons&nbsp;x&nbsp;(f&nbsp;x&nbsp;y)))</tt>
<p><tr valign=top><td><i>&nbsp;&nbsp;e</i>.</td><td>
<p><tt>(lambda&nbsp;(x)<br>

&nbsp;&nbsp;(let&nbsp;([z&nbsp;(cons&nbsp;x&nbsp;y)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;(x&nbsp;y&nbsp;z)))</tt>
<p><tr valign=top><td><i>&nbsp;&nbsp;f</i>.</td><td>
<p><tt>(lambda&nbsp;(x)<br>

&nbsp;&nbsp;(let&nbsp;([y&nbsp;(cons&nbsp;x&nbsp;y)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;(x&nbsp;y&nbsp;z)))</tt>
<p></table>

<p>


<p>

<h3><a name="g25"></a><a name="./start:h6"></a>2.6. 顶层定义<a name="SECTGSTOPLEVEL"></a></h3>



<p>
  <a name="./start:s76"></a>由 <a name="./start:s77"></a> <tt>let</tt> 和 <tt>lambda</tt>
  表达式绑定的变量在它们所在表达式的外部是不可见的。
  假设你创建了一个对象，比如是个过程，你想让它在任何地方都可以访问，就像 <tt>+</tt> 或 <tt>cons</tt> 那样。
  你需要的手段叫做 <i>顶层定义（top-level definition）</i>，可以用 <a name="./start:s78"></a><tt>define</tt> 来实现。
  大多数交互式的Scheme系统都提供对顶层定义的支持。顶层定义指的是在你输入的每一个表达式中都可见，除非被遮蔽（shadows）。

<p>
  让我们创建上一节提到的 <a name="./start:s79"></a><tt>double-any</tt> 过程的一个顶级定义。

<p>

<p><tt>(define&nbsp;double-any<br>

&nbsp;&nbsp;(lambda&nbsp;(f&nbsp;x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(f&nbsp;x&nbsp;x)))</tt>
<p>
  现在变量<tt>double-any</tt>和其他像<tt>cons</tt>这样的原始过程的状态是一致的。
  我们可以像使用原始过程一样使用 <tt>double-any</tt> 。

<p>

<p><tt>(double-any&nbsp;+&nbsp;10)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;20<br>

(double-any&nbsp;cons&nbsp;'a)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(a&nbsp;.&nbsp;a)</tt>
  
<p>
  顶层定义可以用来创建任何对象，并不只是过程。

<p>

<p><tt>(define&nbsp;sandwich&nbsp;"peanut-butter-and-jelly")
<br>
<br>
sandwich&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;"peanut-butter-and-jelly"</tt>
<p><a name="./start:s80"></a>但是，通常顶层定义都是用来定义过程的。

<p>
<a name="./start:s81"></a>如前面所述，顶层定义可能被 <tt>let</tt> 或 <tt>lambda</tt> 绑定所遮蔽。

<p>

<p><tt>(define&nbsp;xyz&nbsp;'(x&nbsp;y&nbsp;z))<br>

(let&nbsp;([xyz&nbsp;'(z&nbsp;y&nbsp;x)])<br>

&nbsp;&nbsp;xyz)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(z&nbsp;y&nbsp;x)</tt>
<p>
  顶层定义的变量就好像是被一个在你输入的所有表达式之外的 <tt>let</tt> 表达式所绑定一样。
<p>
  
  <a name="defn:list"></a>目前为止你阅读到的这些简单的工具，已经足以让你用来定义一些在本书后面才会提到的Scheme原始过程了。
  如果你完成了上一节的练习题，你应该已经知道了如何定义 <a name="./start:s82"></a><tt>list</tt> 。

<p>

<p><tt>(define&nbsp;list&nbsp;(lambda&nbsp;x&nbsp;x))</tt>
<p>
  另外，Scheme提供了一些缩写形式：<a name="./start:s83"></a><tt>cadr</tt> 和 <a name="./start:s84"></a><tt>cddr</tt>
  等，用来代替 <tt>car</tt> 与 <tt>cdr</tt> 的组合、<tt>cdr</tt> 与 <tt>cdr</tt> 的组合。
  <tt>(cadr&nbsp;<i>list</i>)</tt> 和 <tt>(car&nbsp;(cdr&nbsp;<i>list</i>))</tt> 是等价的，
  而<tt>(cddr&nbsp;<i>list</i>)</tt> 与 <tt>(cdr&nbsp;(cdr&nbsp;<i>list</i>))</tt> 是等价的。
  它们简单定义如下。

<p>

<p><tt>(define&nbsp;cadr<br>

&nbsp;&nbsp;(lambda&nbsp;(x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(car&nbsp;(cdr&nbsp;x))))
<br>
<br>
(define&nbsp;cddr<br>

&nbsp;&nbsp;(lambda&nbsp;(x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(cdr&nbsp;(cdr&nbsp;x))))</tt>
<p>
<p><tt>(cadr&nbsp;'(a&nbsp;b&nbsp;c))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;b<br>

(cddr&nbsp;'(a&nbsp;b&nbsp;c))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(c)</tt>
<p>
  任何型如 <tt>(define&nbsp;<i>var</i>&nbsp;<i>expr</i>)</tt> （其中 <tt><i>expr</i></tt> 是一个
  <tt>lambda</tt> 表达式）的定义，都可以被简化成把 <tt>lambda</tt> 去掉的形式。
  准确的语法取决于<tt>lambda</tt>表达式的形参样式，就是说，它是变量正规列表，一个单独的变量，
  还是变量的非正规列表。

<p>

<p><tt>(define&nbsp;<i>var<sub>0</sub></i><br>

&nbsp;&nbsp;(lambda&nbsp;(<i>var<sub>1</sub></i>&nbsp;...&nbsp;<i>var<sub>n</sub></i>)<br>

&nbsp;&nbsp;&nbsp;&nbsp;<i>e<sub>1</sub></i>&nbsp;<i>e<sub>2</sub></i>&nbsp;...))</tt>
<p>可以被简化成

<p>

<p><tt>(define&nbsp;(<i>var<sub>0</sub></i>&nbsp;<i>var<sub>1</sub></i>&nbsp;...&nbsp;<i>var<sub>n</sub></i>)<br>

&nbsp;&nbsp;<i>e<sub>1</sub></i>&nbsp;<i>e<sub>2</sub></i>&nbsp;...)</tt>
<p>而

<p>

<p><tt>(define&nbsp;<i>var<sub>0</sub></i><br>

&nbsp;&nbsp;(lambda&nbsp;<i>var<sub>r</sub></i><br>

&nbsp;&nbsp;&nbsp;&nbsp;<i>e<sub>1</sub></i>&nbsp;<i>e<sub>2</sub></i>&nbsp;...))</tt>
<p>可以被简化成

<p>

<p><tt>(define&nbsp;(<i>var<sub>0</sub></i>&nbsp;.&nbsp;<i>var<sub>r</sub></i>)<br>

&nbsp;&nbsp;<i>e<sub>1</sub></i>&nbsp;<i>e<sub>2</sub></i>&nbsp;...)</tt>
<p>，

<p>

<p><tt>(define&nbsp;<i>var<sub>0</sub></i><br>

&nbsp;&nbsp;(lambda&nbsp;(<i>var<sub>1</sub></i>&nbsp;...&nbsp;<i>var<sub>n</sub></i>&nbsp;.&nbsp;<i>var<sub>r</sub></i>)<br>

&nbsp;&nbsp;&nbsp;&nbsp;<i>e<sub>1</sub></i>&nbsp;<i>e<sub>2</sub></i>&nbsp;...))</tt>
<p>可以被简化成

<p>

<p><tt>(define&nbsp;(<i>var<sub>0</sub></i>&nbsp;<i>var<sub>1</sub></i>&nbsp;...&nbsp;<i>var<sub>n</sub></i>&nbsp;.&nbsp;<i>var<sub>r</sub></i>)<br>

&nbsp;&nbsp;<i>e<sub>1</sub></i>&nbsp;<i>e<sub>2</sub></i>&nbsp;...)</tt>
<p>
  例如，<a name="./start:s85"></a><tt>cadr</tt> 和 <a name="./start:s86"></a><tt>list</tt> 的定义可以被简化成如下形式。

<p>

<p><tt>(define&nbsp;(cadr&nbsp;x)<br>

&nbsp;&nbsp;(car&nbsp;(cdr&nbsp;x)))
<br>
<br>
(define&nbsp;(list&nbsp;.&nbsp;x)&nbsp;x)</tt>
<p>
  这本书并不经常采用这种语法。虽然它更短一些，但是它似乎倾向于掩饰这样一个事实：不同于很多其他语言，（Scheme的）过程并不是紧密关联到一个变量或者名字上的。
  
  这种语法通常被称为 <tt>define</tt> 的 <a name="./start:s87"></a>"defun"形式，
  <tt>defun</tt> 形式是由Lisp语言提供的，能够让过程和它们的名字更紧密地关联在一起。

<p>
<p>
  顶层定义让我们能够更容易的在交互式环境下针对某个过程做实验，因为我们不需要每次使用这个过程的时候都重新输入一次。
  让我们定义一个稍微复杂点的 <tt>double-any</tt> 的变种，把“普通”的双参数过程转换成一个“双重”的单参数<a name="./start:s88"></a>过程。

<p>

<p><tt>(define&nbsp;doubler<br>

&nbsp;&nbsp;(lambda&nbsp;(f)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(x)&nbsp;(f&nbsp;x&nbsp;x))))</tt>

<p>

  <tt>doubler</tt> 接受一个参数 <tt>f</tt>，这个参数 <tt>f</tt> 必须是一个能够接受两个参数的过程。
  <tt>doubler</tt> 返回的是一个过程，这个过程接受一个参数<tt>x</tt>，用在<tt>f</tt>被调用时那两个参数位置。
  我们可以利用 <tt>doubler</tt> 来定义上一节中的<a name="./start:s89"></a><tt>double</tt> 和
  <a name="./start:s90"></a><tt>double-cons</tt> 过程。

<p>

<p><tt>(define&nbsp;double&nbsp;(doubler&nbsp;+))<br>

(double&nbsp;13/2)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;13
<br>
<br>
(define&nbsp;double-cons&nbsp;(doubler&nbsp;cons))<br>

(double-cons&nbsp;'a)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(a&nbsp;.&nbsp;a)</tt>
<p>我们也可以用 <tt>doubler</tt> 来定义 <tt>double-any</tt>。

<p>

<p><tt>(define&nbsp;double-any<br>

&nbsp;&nbsp;(lambda&nbsp;(f&nbsp;x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;((doubler&nbsp;f)&nbsp;x)))</tt>
<p>在 <tt>double</tt> 和<tt>double-cons</tt> 中，<tt>f</tt> 都得到了合适的值，<tt>+</tt> 和 <tt>cons</tt>，
  即使它们毫无疑问会在 <tt>f</tt> 的作用域之外才被调用。


<p>
<p>
  如果你尝试去使用一个变量，它即没有被 <tt>let</tt> 或 <tt>lambda</tt> 表达式绑定，
  也没有在顶层定义，将会发生什么？
  尝试使用变量 <tt>i-am-not-defined</tt> 看看会发生什么。

<p>

<p><tt>(i-am-not-defined&nbsp;3)</tt>
<p>
  大多数Schene系统会打印一个消息提示说发生了一个未绑定或未定义变量的异常。

<p>
  直到作为结果的那个过程被应用的时候，系统才应该去抱怨 <tt>lambda</tt> 表达式中出现了未定义的变量。
  下面的示例 <i>不</i> 应该导致异常发生，即使我们的确还没有创建 <tt>proc2</tt> 的顶层定义。

<p>

<p><tt>(define&nbsp;proc1<br>

&nbsp;&nbsp;(lambda&nbsp;(x&nbsp;y)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(proc2&nbsp;y&nbsp;x)))</tt>
<p>
  如果你在定义 <tt>proc2</tt> 之前尝试调用 <tt>proc1</tt>，你将会得到一个未定义异常的信息。
  我们给 <tt>proc2</tt> 来一个顶层定义，然后再试一下 <tt>proc1</tt> 。

<p>

<p><tt>(define&nbsp;proc2&nbsp;cons)<br>

(proc1&nbsp;'a&nbsp;'b)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(b&nbsp;.&nbsp;a)</tt>
<p>
  当你定义 <tt>proc1</tt> 的时候，系统接受了你会定义 <tt>proc2</tt> 的承诺，
  并且只要你在使用 <tt>proc1</tt> 之前定义 <tt>proc2</tt>，系统就不会抱怨任何事情。
  这就允许你可以以你自己喜欢的任何顺序来定义过程。
  这在你想要通过排列你的过程定义来增加程序可读性的时候，尤为有用。
  在两个顶层定义的过程互相依赖对方的时候，这个特性是必须的；我们将会在后面看到一些示例。

<p>

<h4>Exercise <a name="g26"></a>2.6.1</h4>
<a name="./start:s91"></a>如果你键入了下面的代码，会发生什么？

<p>

<p><tt>(double-any&nbsp;double-any&nbsp;double-any)</tt>
<p>其中 <tt>double-any</tt> 采用本节开头给出的定义。

<p>


<p>

<h4>Exercise <a name="g27"></a>2.6.2</h4>

<a name="./start:s92"></a>有一个比本节中示例更优雅（虽然效率可能差一些）的方法用来定义 <a name="./start:s93"></a><tt>cadr</tt>
和 <a name="./start:s94"></a><tt>cddr</tt>，就是定义一个过程，来组合两个过程创建出第三个过程。
写出这个过程 <a name="./start:s95"></a><tt>compose</tt>， 让<tt>(compose&nbsp;<i>p<sub>1</sub></i>&nbsp;<i>p<sub>2</sub></i>)</tt>
是 <tt><i>p<sub>1</sub></i></tt> 和 <tt><i>p<sub>2</sub></i></tt> 的组合（假设两者都接受单个参数）。
就是说，<tt>(compose&nbsp;<i>p<sub>1</sub></i>&nbsp;<i>p<sub>2</sub></i>)</tt> 应该返回一个新的单参数过程，
这个过程把 <tt><i>p<sub>1</sub></i></tt> 应用在“把 <tt><i>p<sub>2</sub></i></tt> 应用在参数上得到的结果”之上。
用这个 <tt>compose</tt> 来定义 <tt>cadr</tt> 和 <tt>cddr</tt>。

<p>


<p>

<h4>Exercise <a name="g28"></a>2.6.3</h4>
<a name="./start:s96"></a>Scheme也提供了<a name="./start:s97"></a><tt>caar</tt>, <tt>cdar</tt>, <tt>caaar</tt>, <tt>caadr</tt>
，等等，最多到4个 <tt>a</tt> (代表 <tt>car</tt>) 和 <tt>d</tt> (代表 <tt>cdr</tt>) 放在 <tt>c</tt> 和
<tt>r</tt> 之间（参见&nbsp;<a href="./objects.html#g109">6.3</a>节）。
用之前一个练习中的 <tt>compose</tt> 把它们每一个都定义出来。


<p>


<p>

<h3><a name="g29"></a><a name="./start:h7"></a> 2.7. 条件表达式<a name="SECTGSCONDITIONALS"></a></h3>



<p>
  目前为止我们已经学习了很多无条件执行任务的表达式。
  假设我们想要写一个过程，叫做 <a name="./start:s98"></a><tt>abs</tt>。
  如果它的参数 <i>x</i> 是负数，<tt>abs</tt>就返回 -<i>x</i>；否则返回 <i>x</i>。
  写这个<tt>abs</tt>过程最直接的方式就是去检测这个参数是否是负数，如果是就取相反数，
  用<a name="./start:s99"></a><tt>if</tt> 语法形式。


<p>

<p><tt>(define&nbsp;abs<br>

&nbsp;&nbsp;(lambda&nbsp;(n)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(&lt;&nbsp;n&nbsp;0)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(-&nbsp;0&nbsp;n)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n)))
<br>
<br>
(abs&nbsp;77)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;77<br>

(abs&nbsp;-77)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;77</tt>
<p><tt>if</tt> 表达式有如下形式
<tt>(if&nbsp;<i>test</i>&nbsp;<i>consequent</i>&nbsp;<i>alternative</i>)</tt> 其中
<tt><i>consequent</i></tt> 是当 <tt><i>test</i></tt> 为真时进行求值的表达式，
而
<tt><i>alternative</i></tt> 是当 <tt><i>test</i></tt> 为假时进行求值的表达式。
在上面的表达式中，<tt><i>test</i></tt> 是 <tt>(&lt;&nbsp;n&nbsp;0)</tt>，<tt><i>consequent</i></tt>
是 <tt>(-&nbsp;0&nbsp;n)</tt>，而 <tt><i>alternative</i></tt> 是 <tt>n</tt>。

<p>
  过程 <tt>abs</tt> 可以写成很多变种。下面的每一个都是 <tt>abs</tt> 的有效定义。

<p>

<p><tt>(define&nbsp;abs<br>

&nbsp;&nbsp;(lambda&nbsp;(n)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(&gt;=&nbsp;n&nbsp;0)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(-&nbsp;0&nbsp;n))))
<br>
<br>
(define&nbsp;abs<br>

&nbsp;&nbsp;(lambda&nbsp;(n)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(not&nbsp;(&lt;&nbsp;n&nbsp;0))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(-&nbsp;0&nbsp;n))))
<br>
<br>
(define&nbsp;abs<br>

&nbsp;&nbsp;(lambda&nbsp;(n)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(or&nbsp;(&gt;&nbsp;n&nbsp;0)&nbsp;(=&nbsp;n&nbsp;0))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(-&nbsp;0&nbsp;n))))
<br>
<br>
(define&nbsp;abs<br>

&nbsp;&nbsp;(lambda&nbsp;(n)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(=&nbsp;n&nbsp;0)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(&lt;&nbsp;n&nbsp;0)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(-&nbsp;0&nbsp;n)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n))))
<br>
<br>
(define&nbsp;abs<br>

&nbsp;&nbsp;(lambda&nbsp;(n)<br>

&nbsp;&nbsp;&nbsp;&nbsp;((if&nbsp;(&gt;=&nbsp;n&nbsp;0)&nbsp;+&nbsp;-)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n)))</tt>
<p>
  第一个定义先查看 <tt>n</tt> 是否大于等于0，做和示例相反的检测。
  第二个定义先查看 <tt>n</tt> 是否不小于0，用到了<a name="./start:s100"></a><tt>not</tt> 和 <tt>&lt;</tt>。
  第三个定义先查看 <tt>n</tt> 是否比0大或者等于0，用到了 <a name="./start:s101"></a><tt>or</tt>语法形式。
  第四个单独处理了0的情况，虽然这样做并没有什么好处。
  第五个有一些狡猾，<tt>n</tt> 要么加到0上，要么从0上减去，取决于 <tt>n</tt> 是大于等于0还是小于零。

<p>
  为什么 <a name="./start:s102"></a><tt>if</tt> 是一个语法形式而不是一个过程呢？
  为了回答这个问题，让我们回顾一下本章第一节中 <tt>reciprocal</tt> 过程的定义。

<p>

<p><tt>(define&nbsp;reciprocal<br>

&nbsp;&nbsp;(lambda&nbsp;(n)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(=&nbsp;n&nbsp;0)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"oops!"<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(/&nbsp;1&nbsp;n))))</tt>
<p>
  传递给除法过程的第二个参数不应该是0，因为结果是数学上未定义的。
  我们的 <tt>reciprocal</tt> 定义通过检测是否为0，在除法之前避开了这个问题。
  如果 <tt>if</tt> 是一个过程，它的所有参数（包括 <tt>(/&nbsp;1&nbsp;n)</tt>）
  都将在作出选择之前进行求值。
  就像 <tt>quote</tt> 阻止它唯一的子表达式进行求值一样，<tt>if</tt> 阻止了它所有的子表达式进行求值，所以不能作为过程。
  
<p>
  <a name="./start:s103"></a><tt>or</tt> 语法形式拥有和 <tt>if</tt> 类似的行为。
  <tt>or</tt> 表达式的一般形式是 <tt>(or&nbsp;<i>expr</i>&nbsp;...)</tt>。
  如果没有任何子表达式，也就是这个表达式 <tt>(or)</tt> ，它的值是false。
  否则，每一个 <tt><i>expr</i></tt> 依次被求值，直到以下两个条件之一被触发：
  (a) 其中一个表达式的求值结果为true，或
  (b) 所有表达式都已经求值完毕。
  在 (a) 情况下，值为true，而在 (b) 情况下，值为false。

<p>
  更准确的说，在 (a) 情况下，<tt>or</tt> 表达式的值是最后一个被求值的子表达式的值。
  这一点澄清是有必要的，因为可能有很多求值为真的子表达式。
  通常，一个测试表达式的值是下面两个对象之一：为真时是 <a name="./start:s104"></a><tt>#t</tt>，
  为假时是 <a name="./start:s105"></a><tt>#f</tt>。

<p>

<p><tt>(&lt;&nbsp;-1&nbsp;0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(&gt;&nbsp;-1&nbsp;0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f</tt>
<p>
  在条件表达式和<tt>not</tt>过程中，每一个Scheme对象都会被看成要么 <a name="./start:s106"></a>true
  要么 <a name="./start:s107"></a>。
  只有 <tt>#f</tt> 被看成false，其他对象都被看成是true。

<p>

<p><tt>(if&nbsp;#t&nbsp;'true&nbsp;'false)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;true<br>

(if&nbsp;#f&nbsp;'true&nbsp;'false)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;false<br>

(if&nbsp;'()&nbsp;'true&nbsp;'false)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;true<br>

(if&nbsp;1&nbsp;'true&nbsp;'false)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;true<br>

(if&nbsp;'(a&nbsp;b&nbsp;c)&nbsp;'true&nbsp;'false)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;true
<br>
<br>
(not&nbsp;#t)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(not&nbsp;"false")&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(not&nbsp;#f)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t
<br>
<br>
(or)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(or&nbsp;#f)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(or&nbsp;#f&nbsp;#t)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(or&nbsp;#f&nbsp;'a&nbsp;#f)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;a</tt>
<p><p>
  <a name="./start:s108"></a><tt>and</tt> 语法形式上和 <tt>or</tt> 很类似，但<tt>and</tt>
  表达式只有在所有子表达式都为true的时候才等于true，否则等于false。
  在没有子表达式的情况下，就是说这个表达式  <tt>(and)</tt>，的值为true。
  否则，子表达式从左到右依次排列求值，直到全部子表达式求职完毕，或者其中一个表达式的值是false。
   <tt>and</tt> 的值是最后一个被求值的子表达式的值。


<p>
  我们可以用 <tt>and</tt> 来定义一个稍微不同一些的<a name="./start:s109"></a><tt>reciprocal</tt>的新版本。

<p>

<p><tt>(define&nbsp;reciprocal<br>

&nbsp;&nbsp;(lambda&nbsp;(n)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(and&nbsp;(not&nbsp;(=&nbsp;n&nbsp;0))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(/&nbsp;1&nbsp;n))))
<br>
<br>
(reciprocal&nbsp;3)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;1/3<br>

(reciprocal&nbsp;0.5)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;2.0<br>

(reciprocal&nbsp;0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f</tt>
<p>
  在这个版本中，<tt>n</tt>等于0时返回 <tt>#f</tt>，否则返回 <tt>1/n</tt>。

<p>
<p>
  <tt>=</tt>, <tt>&lt;</tt>, <tt>&gt;</tt>, <tt>&lt;=</tt> 和 <tt>&gt;=</tt> 这些过程被称为 <a name="./start:s110"></a><i><span class="todo">谓词</span>（predicates）</i>。<span class="todo">谓词</span>是指回答关于它的参数的一个特定问题，并且只返回 <tt>#t</tt> 和 <tt>#f</tt> 中的一个值，这样的过程。大多数谓词的名字都以 <a name="./start:s111"></a><a name="./start:s112"></a>问号 (&nbsp;<tt>?</tt>&nbsp;)结尾，除了下列这些一般的算术过程。
  当然，并不是所有的谓词都必须要数值参数。谓词 <a name="./start:s113"></a><tt>null?</tt> 当参数为空表 <tt>()</tt> 时返回true，否则返回false。

<p>

<p><tt>(null?&nbsp;'())&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(null?&nbsp;'abc)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(null?&nbsp;'(x&nbsp;y&nbsp;z))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(null?&nbsp;(cdddr&nbsp;'(x&nbsp;y&nbsp;z)))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t</tt>
  
<p>
  过程 <a name="./start:s114"></a><tt>cdr</tt> 的参数必须是一个序对，否则就会抛出异常。
  然而在Common Lisp中，定义 <tt>(cdr&nbsp;'())</tt> 为 <tt>()</tt>。
  下面的过程 <a name="./start:s115"></a><tt>lisp-cdr</tt> 用 <tt>null?</tt> 来定义了一个遇到参数 <tt>()</tt> 就返回 <tt>()</tt> 的过程。

<p>

<p><tt>(define&nbsp;lisp-cdr<br>

&nbsp;&nbsp;(lambda&nbsp;(x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(null?&nbsp;x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'()<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cdr&nbsp;x))))
<br>
<br>
(lisp-cdr&nbsp;'(a&nbsp;b&nbsp;c))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(b&nbsp;c)<br>

(lisp-cdr&nbsp;'(c))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;()<br>

(lisp-cdr&nbsp;'())&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;()</tt>
  
<p>
  另一个有用的谓词是 <a name="./start:s116"></a><tt>eqv?</tt>，它需要两个参数。
  当两个参数是相等的，<tt>eqv?</tt> 返回true，否则，<tt>eqv?</tt> 返回false。

<p>

<p><tt>(eqv?&nbsp;'a&nbsp;'a)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(eqv?&nbsp;'a&nbsp;'b)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(eqv?&nbsp;#f&nbsp;#f)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(eqv?&nbsp;#t&nbsp;#t)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(eqv?&nbsp;#f&nbsp;#t)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(eqv?&nbsp;3&nbsp;3)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(eqv?&nbsp;3&nbsp;2)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(let&nbsp;([x&nbsp;"Hi&nbsp;Mom!"])<br>

&nbsp;&nbsp;(eqv?&nbsp;x&nbsp;x))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(let&nbsp;([x&nbsp;(cons&nbsp;'a&nbsp;'b)])<br>

&nbsp;&nbsp;(eqv?&nbsp;x&nbsp;x))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(eqv?&nbsp;(cons&nbsp;'a&nbsp;'b)&nbsp;(cons&nbsp;'a&nbsp;'b))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f</tt>
  
<p>如你所见，<tt>eqv?</tt> 过程对相等的符号、布尔值、数值、序对或字符串返回true。
  对 <tt>eqv?</tt> 来说两个序对如果是不同的 <tt>cons</tt> 过程创建的，那么即使它们内容相同，也认为是不相等。
  关于 <tt>eqv?</tt> 相等的规则，将会在&nbsp;<a href="./objects.html#g108">6.2</a> 节详细介绍。

<p>Scheme也提供了一组 <a name="./start:s117"></a><i>类型谓词</i>，根据一个对象的类型返回true或false，例如
  <a name="./start:s118"></a><tt>pair?</tt>、<a name="./start:s119"></a><tt>symbol?</tt>、<a name="./start:s120"></a><tt>number?</tt> 和 <a name="./start:s121"></a><tt>string?</tt>。
  举例来说， <a name="./start:s122"></a><tt>pair?</tt> 只有在参数是一个序对的时候才会返回true。


<p>

<p><tt>(pair?&nbsp;'(a&nbsp;.&nbsp;c))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(pair?&nbsp;'(a&nbsp;b&nbsp;c))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(pair?&nbsp;'())&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(pair?&nbsp;'abc)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(pair?&nbsp;"Hi&nbsp;Mom!")&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(pair?&nbsp;1234567890)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f</tt>
<p>
  类型谓词在确定传递给一个过程的参数是否是合适类型的时候，非常有用。
  例如，下面一个版本的 <a name="./start:s123"></a><tt>reciprocal</tt> 先检查了它的参数是否是个数值，
  然后再去和0比较或者执行除法。
  
<p>

<p><tt>(define&nbsp;reciprocal<br>

&nbsp;&nbsp;(lambda&nbsp;(n)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(and&nbsp;(number?&nbsp;n)&nbsp;(not&nbsp;(=&nbsp;n&nbsp;0)))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(/&nbsp;1&nbsp;n)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"oops!")))
<br>
<br>
(reciprocal&nbsp;2/3)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;3/2<br>

(reciprocal&nbsp;'a)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;"oops!"</tt>
<p>
  另外，使用到 <tt>reciprocal</tt> 的代码必须检查返回值来确认是一个数值，而不是一个字符串。
  
  为了让代码调用者减轻检查返回值的负担，通常更好的做法是用 <tt>断言违例（assertion-violation）</tt> 直接报告一个错误，如下所示。

<p>

<p><tt>(define&nbsp;reciprocal<br>

&nbsp;&nbsp;(lambda&nbsp;(n)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(and&nbsp;(number?&nbsp;n)&nbsp;(not&nbsp;(=&nbsp;n&nbsp;0)))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(/&nbsp;1&nbsp;n)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(assertion-violation&nbsp;'reciprocal<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"improper&nbsp;argument"<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n))))
<br>
<br>
(reciprocal&nbsp;.25)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;4.0<br>

(reciprocal&nbsp;0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;<i>exception&nbsp;in&nbsp;reciprocal:&nbsp;improper&nbsp;argument&nbsp;0</i><br>

(reciprocal&nbsp;'a)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;<i>exception&nbsp;in&nbsp;reciprocal:&nbsp;improper&nbsp;argument&nbsp;a</i></tt>
<p>
  <tt>assertion-violation</tt> 的第一个参数是一个符号，表明这个消息的来源；
  第二个参数是一个字符串，用来描述这个错误；
  第三个之后的参数被包含在错误信息中。

<p>
  我们再看一个条件表达式： <a name="./start:s124"></a><tt>cond</tt>，这个表达式经常用来替换 <a name="./start:s125"></a><tt>if</tt>。
  <tt>cond</tt> 和 <tt>if</tt> 很像，只是它支持多个测试和选择表达式。
  来看下面的 <tt>sign</tt> 过程定义，在输入负数时返回 <tt>-1</tt>，整数时返回 <tt>+1</tt>，而输入0时返回 <tt>0</tt> 。
  

<p>

<p><tt>(define&nbsp;sign<br>

&nbsp;&nbsp;(lambda&nbsp;(n)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(&lt;&nbsp;n&nbsp;0)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-1<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(&gt;&nbsp;n&nbsp;0)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+1<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0))))</tt>
<p>
<p><tt>(sign&nbsp;-88.3)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;-1<br>

(sign&nbsp;0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;0<br>

(sign&nbsp;333333333333)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;1<br>

(*&nbsp;(sign&nbsp;-88.3)&nbsp;(abs&nbsp;-88.3))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;-88.3</tt>
<p>
  这两个 <tt>if</tt> 表达式可以用一个 <tt>cond</tt> 表达式替换如下。

<p>

<p><tt>(define&nbsp;sign<br>

&nbsp;&nbsp;(lambda&nbsp;(n)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(cond<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(&lt;&nbsp;n&nbsp;0)&nbsp;-1]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(&gt;&nbsp;n&nbsp;0)&nbsp;+1]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[else&nbsp;0])))</tt>
<p>A <tt>cond</tt> expression usually takes the form

<p>

<p><tt>(cond&nbsp;(<i>test</i>&nbsp;<i>expr</i>)&nbsp;...&nbsp;(else&nbsp;<i>expr</i>))</tt>
  
<p>
  其中 <tt>else</tt> 条目有时可以省略，但通常只在前面的条目不会全部失败的情况下才可以省略。例如下面新版本的
   <tt>sign</tt> 这样。

<p>

<p><tt>(define&nbsp;sign<br>

&nbsp;&nbsp;(lambda&nbsp;(n)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(cond<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(&lt;&nbsp;n&nbsp;0)&nbsp;-1]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(&gt;&nbsp;n&nbsp;0)&nbsp;+1]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(=&nbsp;n&nbsp;0)&nbsp;0])))</tt>
<p>
  这些 <tt>sign</tt> 的定义都和测试语句的顺序无关，对于每个<tt>n</tt>，
  所有测试语句中只可能有一个为true。
  下面这个过程使用阶梯计税系统计算一个给定收入总价的税金，其中的分段点是
   10,000, 20,000 和 30,000 美元。

<p>

<p><tt>(define&nbsp;income-tax<br>

&nbsp;&nbsp;(lambda&nbsp;(income)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(cond<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(&lt;=&nbsp;income&nbsp;10000)&nbsp;(*&nbsp;income&nbsp;.05)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(&lt;=&nbsp;income&nbsp;20000)&nbsp;(+&nbsp;(*&nbsp;(-&nbsp;income&nbsp;10000)&nbsp;.08)&nbsp;500.00)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(&lt;=&nbsp;income&nbsp;30000)&nbsp;(+&nbsp;(*&nbsp;(-&nbsp;income&nbsp;20000)&nbsp;.13)&nbsp;1300.00)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[else&nbsp;(+&nbsp;(*&nbsp;(-&nbsp;income&nbsp;30000)&nbsp;.21)&nbsp;2600.00)])))</tt>
<p>
<p><tt>(income-tax&nbsp;5000)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;250.0<br>

(income-tax&nbsp;15000)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;900.0<br>

(income-tax&nbsp;25000)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;1950.0<br>

(income-tax&nbsp;50000)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;6800.0</tt>
<p>
  在这个示例中，测试语句出现的顺序（从上到下、从左到右）是有意义的。


<p>

<h4>Exercise <a name="g30"></a>2.7.1</h4>
<a name="./start:s126"></a>定义谓词 <a name="./start:s127"></a><tt>atom?</tt>，当参数不是一个序对的时候返回true，否则返回false。

<p>


<p>

<h4>Exercise <a name="g31"></a>2.7.2</h4>
<a name="./start:s128"></a><a name="EXSHORTER1"></a>过程 <tt>length</tt> 的参数必须是个列表，<tt>length</tt> 返回它参数的长度，
例如： <tt>(length&nbsp;'(a&nbsp;b&nbsp;c))</tt> 是3。
使用 <tt>length</tt>，定义过程 <a name="./start:s129"></a><tt>shorter</tt>，返回两个列表参数中较短的一个。
如果两个参入长度相等，返回第一个。


<p>

<p><tt>(shorter&nbsp;'(a&nbsp;b)&nbsp;'(c&nbsp;d&nbsp;e))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(a&nbsp;b)<br>

(shorter&nbsp;'(a&nbsp;b)&nbsp;'(c&nbsp;d))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(a&nbsp;b)<br>

(shorter&nbsp;'(a&nbsp;b)&nbsp;'(c))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(c)</tt>
<p>

<p>

<h3><a name="g32"></a><a name="./start:h8"></a>Section 2.8. 简单递归<a name="SECTGSRECURSION"></a></h3>



<p>
  <a name="./start:s130"></a>我们见到了如何使用<tt>if</tt>、<tt>and</tt>、<tt>or</tt>和<tt>cond</tt>来控制是否对一个表达式求值。
  我们也知道了，创建并多次调用包含某表达式的过程，可以达到多次执行一个表达式的效果。
  如果我们想要重复执行一个表达式呢，比如列举一个列表的所有元素，或者从1到10的所有数值？
  我们可以用 <a name="./start:s131"></a>递归（recursion）来实现。
  递归是一个简单的概念：在一个过程中应用这个过程。
  一开始掌握递归是比较不容易的，但是一旦掌握了，它提供的表现力远远超过原始的循环结构。

<p>
  <a name="./start:s132"></a><i>递归过程</i> 是一个调用了自己本身的过程。
  也许最简单的递归过程就是下面的这个过程，我们将把它称为 <a name="./start:s133"></a><tt>goodbye</tt>。

<p>

<p><tt>(define&nbsp;goodbye<br>

&nbsp;&nbsp;(lambda&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;(goodbye)))
<br>
<br>
(goodbye)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>"></tt>
<p>
  这个过程不需要参数，并且马上调用了它自己。
  在 <img src="math/tspl/0.gif" alt="<graphic>"> 之后不会出现任何值，因为 <tt>goodbye</tt> 永远不会返回。

<p>
  显然，想要让递归过程有实际用途的话，我们必须找到结束递归的一个方法。
  大多数递归过程都包含至少两个基本部分，一个<a name="./start:s134"></a><i>基本情形</i> 和一个 <a name="./start:s135"></a><i>递归步骤</i>。
  基本情形用来终止这个递归，在一些基本参数条件下给出过程的返回值。
  递归步骤根据使用由另一个参数应用过程所得到的值，来给出返回值。
  为了保证递归的终止，那另一个参数必须某种程度上更贴近基本情形。

<p>
  <a name="./start:s136"></a>
  让我们来看一个实例，递归地找到一个正规列表的长度。
  我们需要一个基本情形和一个递归步骤。
  在列表上递归，合理的基本情形几乎一定是空表。
  空表的长度是0，所以基本情形应该对空表的情形给出返回值0。
  为了更接近空表，自然的递归步骤涉及参数的cdr。一个非空列比它的cdr的长度大1，所以递归步骤是，
  给出比它的cdr的length大1的数作为<a name="defn:simplelength"></a>返回值。

<p>

<p><tt>(define&nbsp;length<br>

&nbsp;&nbsp;(lambda&nbsp;(ls)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(null?&nbsp;ls)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(+&nbsp;(length&nbsp;(cdr&nbsp;ls))&nbsp;1))))</tt>
<p>
<p><tt>(length&nbsp;'())&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;0<br>

(length&nbsp;'(a))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;1<br>

(length&nbsp;'(a&nbsp;b))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;2</tt>
<p>
  <tt>if</tt> 表达式询问这个列表是否为空。如果是，返回值为0，这就是基本情形。
  如果不是，返回值是这个列表的cdr的长度加1。这就是递归步骤。

<p>
  很多Scheme实现都允许我们跟踪一个过程的执行，来查看它的操作步骤。
  
  <a name="./start:s137"></a><a name="./start:s138"></a>例如，在<a name="./start:s139"></a>Chez&nbsp;Scheme里，
  可以使用 <tt>(trace&nbsp;<i>name</i>)</tt> 命令来跟踪，其中<tt><i>name</i></tt>是我们定义的顶层过程的名字。
  如果跟踪上面定义的那个 <tt>length</tt>，并且传入<tt>'(a&nbsp;b&nbsp;c&nbsp;d)</tt> 作为参数，应该看到下面的输出：
  
<p>

<p><tt>|(length&nbsp;(a&nbsp;b&nbsp;c&nbsp;d))<br>

|&nbsp;(length&nbsp;(b&nbsp;c&nbsp;d))<br>

|&nbsp;|(length&nbsp;(c&nbsp;d))<br>

|&nbsp;|&nbsp;(length&nbsp;(d))<br>

|&nbsp;|&nbsp;|(length&nbsp;())<br>

|&nbsp;|&nbsp;|0<br>

|&nbsp;|&nbsp;1<br>

|&nbsp;|2<br>

|&nbsp;3<br>

|4</tt>
<p>
  缩进显示了递归的嵌套层级；竖线关联起了每次应用和对应的值。
  可以看到，每次应用 <tt>length</tt>，列表的长度都减少，直到变成空表 <tt>()</tt>。
   <tt>()</tt> 对应的值是0, 外面每一层都增加1，直到最终的值。

<p>
  我们来写一个 <a name="./start:s140"></a><tt>list-copy</tt> 过程，参数必须是一个列表，返回值是这个列表的一个副本。
  就是说，<tt>list-copy</tt> 返回一个新的列表，包含就列表中的每一个元素（而不是序对）。
  当原始值或者副本需要通过 <tt>set-car!</tt> 或 <tt>set-cdr!</tt> 被修改时，这个过程是很有用的。

<p>

<p><tt>(list-copy&nbsp;'())&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;()<br>

(list-copy&nbsp;'(a&nbsp;b&nbsp;c))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(a&nbsp;b&nbsp;c)</tt>
  
<p>
  先看看你能否 <tt>list-copy</tt> 在学习下面内容之前给出这个定义。

<p>

<p><tt>(define&nbsp;list-copy<br>

&nbsp;&nbsp;(lambda&nbsp;(ls)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(null?&nbsp;ls)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'()<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cons&nbsp;(car&nbsp;ls)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(list-copy&nbsp;(cdr&nbsp;ls))))))</tt>
  
<p>
  <tt>list-copy</tt> 的定义和 <tt>length</tt> 很类似。基本情形的测试是一样的，<tt>(null?&nbsp;ls)</tt>。
  只不过基本情形的值是 <tt>()</tt> 而不是0，因为我们要构建的是一个列表而不是一个数值。
  递归调用也一样，把原来的加1，替换成了“把列表的car，和（用cdr做的）递归调用得到的值，cons在一起”。
 
<p>
  基本情形并不是只能有一个。 <a name="./start:s141"></a><tt>memv</tt> 过程接受两个参数，一个对象和一个列表。
  它返回的是一个子列表，或者叫<i>tail</i>，它从该列表中第一个和该对象相等的元素开始，一直到列表结尾；如果没有找到和该对象相等的元素，则返回<tt>#f</tt>。
  <tt>memv</tt>的值可以被视为列表，也可以在一个条件表达式中被当做真假值来使用。

<p>

<p><tt>(define&nbsp;memv<br>

&nbsp;&nbsp;(lambda&nbsp;(x&nbsp;ls)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(cond<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(null?&nbsp;ls)&nbsp;#f]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(eqv?&nbsp;(car&nbsp;ls)&nbsp;x)&nbsp;ls]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[else&nbsp;(memv&nbsp;x&nbsp;(cdr&nbsp;ls))])))</tt>
<p>
<p><tt>(memv&nbsp;'a&nbsp;'(a&nbsp;b&nbsp;b&nbsp;d))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(a&nbsp;b&nbsp;b&nbsp;d)<br>

(memv&nbsp;'b&nbsp;'(a&nbsp;b&nbsp;b&nbsp;d))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(b&nbsp;b&nbsp;d)<br>

(memv&nbsp;'c&nbsp;'(a&nbsp;b&nbsp;b&nbsp;d))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(memv&nbsp;'d&nbsp;'(a&nbsp;b&nbsp;b&nbsp;d))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(d)<br>

(if&nbsp;(memv&nbsp;'b&nbsp;'(a&nbsp;b&nbsp;b&nbsp;d))<br>

&nbsp;&nbsp;&nbsp;&nbsp;"yes"<br>

&nbsp;&nbsp;&nbsp;&nbsp;"no")&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;"yes"</tt>
  
<p>
  这里有两个条件要检查，所以使用了 <a name="./start:s142"></a><tt>cond</tt> 。
  第一个分句检查了基本情形：空表 <tt>()</tt>，没有任何元素是<tt>()</tt>的成员，所以答案是<tt>#t</tt>。
  第二个分句询问是否这个列表的car等于该对象，如果是则返回这个列表。
  递归步骤继续沿着列表向下询问。

<p>
  递归的情形也可能不止一种，和<tt>memv</tt>类似，下面定义的 <a name="./start:s143"></a><tt>remv</tt> 接受2个参数，一个对象和一个列表，
  它返回一个新的列表，其中移除了所有和该对象相等的元素。

<p>

<p><tt>(define&nbsp;remv<br>

&nbsp;&nbsp;(lambda&nbsp;(x&nbsp;ls)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(cond<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(null?&nbsp;ls)&nbsp;'()]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(eqv?&nbsp;(car&nbsp;ls)&nbsp;x)&nbsp;(remv&nbsp;x&nbsp;(cdr&nbsp;ls))]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[else&nbsp;(cons&nbsp;(car&nbsp;ls)&nbsp;(remv&nbsp;x&nbsp;(cdr&nbsp;ls)))])))</tt>
<p>
<p><tt>(remv&nbsp;'a&nbsp;'(a&nbsp;b&nbsp;b&nbsp;d))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(b&nbsp;b&nbsp;d)<br>

(remv&nbsp;'b&nbsp;'(a&nbsp;b&nbsp;b&nbsp;d))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(a&nbsp;d)<br>

(remv&nbsp;'c&nbsp;'(a&nbsp;b&nbsp;b&nbsp;d))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(a&nbsp;b&nbsp;b&nbsp;d)<br>

(remv&nbsp;'d&nbsp;'(a&nbsp;b&nbsp;b&nbsp;d))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(a&nbsp;b&nbsp;b)</tt>
<p>
  这个定义和上面的<tt>memv</tt>非常相似，除了<tt>remv</tt>在找到第一个元素之后并不马上结束，而是忽略这个元素，继续下去。
  如果当前列表的car和对象并不想等，<tt>remv</tt>做了和<tt>list-copy</tt>相同的事情：它把这个列表的car，和递归出来的结果，cons在一起。

<p>
  到现在为止，递归都发生在一个列表的cdr上。但有的时候，在一个列表的car上递归是同样有用的。
  下面定义的 <a name="./start:s144"></a><tt>tree-copy</tt> 过程将序对结构视为一个树而不是一个列表，左子树是序对的car，而右子树是序对的cdr。
  它表现的类似于 <tt>list-copy</tt>，构建一个新的树，但是保留原来的元素（叶子）。

<p>

<p><tt>(define&nbsp;tree-copy<br>

&nbsp;&nbsp;(lambda&nbsp;(tr)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(not&nbsp;(pair?&nbsp;tr))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tr<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cons&nbsp;(tree-copy&nbsp;(car&nbsp;tr))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(tree-copy&nbsp;(cdr&nbsp;tr))))))</tt>
<p>
<p><tt>(tree-copy&nbsp;'((a&nbsp;.&nbsp;b)&nbsp;.&nbsp;c))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;((a&nbsp;.&nbsp;b)&nbsp;.&nbsp;c)</tt>
  
<p>
  <span class="todo">一个树形结构的基本元素</span>是任何非序对的东西，因为我们递归遍历序对而非列表。
  这里的递归步骤是 <i>双重递归</i>，同时对car和cdr进行了递归。

<p>
<p>
  在这里，对其它一些提供了诸如<i>while</i>、<i>for</i>循环一类迭代结构的语言比较熟悉的读者们可能想知道，
  在Scheme中，类似的结构是否有必要。
  答案是，没有必要。 <a name="./start:s145"></a>在Scheme中，迭代通过递归的方式被更清晰和简洁的表达出来。
  递归更通用，消除了其他语言中迭代结构必须的给中间变量赋值的步骤，使得代码更可靠并更<span class="todo">易懂</span>。
  有的递归本质上就是迭代，而且运行的时候也的确如此，<a href="./further.html#g55">3.2</a>节会进一步介绍。
  通常也没有必要去做严格的区分（译注：递归和迭代），还是集中精力于编写清晰、简洁、正确的程序吧。

<p>
  在我们结束递归话题之前，来看一个特殊的形式叫做 <a name="./start:s146"></a><i>映射</i>。
  考虑下面的这个过程 <tt>abs-all</tt>，它接受一个数值构成的列表作为输入，返回由它们的绝对值构成的列表。

<p>

<p><tt>(define&nbsp;abs-all<br>

&nbsp;&nbsp;(lambda&nbsp;(ls)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(null?&nbsp;ls)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'()<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cons&nbsp;(abs&nbsp;(car&nbsp;ls))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(abs-all&nbsp;(cdr&nbsp;ls))))))</tt>
<p>
<p><tt>(abs-all&nbsp;'(1&nbsp;-2&nbsp;3&nbsp;-4&nbsp;5&nbsp;-6))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(1&nbsp;2&nbsp;3&nbsp;4&nbsp;5&nbsp;6)</tt>
<p>
  这个过程通过对每个元素调用<tt>abs</tt>过程，创建了一个新的列表。
  我们可以说 <tt>abs-all</tt> 过程通过 <tt>abs</tt> 把旧的列表 <i>映射</i> 到了新的列表上。
  把一个过程映射到一个列表上是非常常见的操作，所以Scheme提供了一个过程叫做 <tt>map</tt>，它把第一个参数代表的过程映射到第二个参数那个列表上。
  我们可以使用 <a name="./start:s147"></a><tt>map</tt> 重新定义 <tt>abs-all</tt>。

<p>

<p><tt>(define&nbsp;abs-all<br>

&nbsp;&nbsp;(lambda&nbsp;(ls)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(map&nbsp;abs&nbsp;ls)))</tt>
  
<p>
  我们实际上并不需要 <tt>abs-all</tt>，因为直接使用<tt>map</tt>同样简短，而且可能还更清晰。

<p>

<p><tt>(map&nbsp;abs&nbsp;'(1&nbsp;-2&nbsp;3&nbsp;-4&nbsp;5&nbsp;-6))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(1&nbsp;2&nbsp;3&nbsp;4&nbsp;5&nbsp;6)</tt>
<p>
  当然，我们可以用 <tt>lambda</tt> 来创建<tt>map</tt>的那个过程参数，比如，把一个数值列表变成它们各自的平方数。

<p>

<p><tt>(map&nbsp;(lambda&nbsp;(x)&nbsp;(*&nbsp;x&nbsp;x))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'(1&nbsp;-3&nbsp;-5&nbsp;7))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(1&nbsp;9&nbsp;25&nbsp;49)</tt>
<p>
  我们可以把多个列表通过一个需要多参数的过程来映射，看下面的示例。

<p>

<p><tt>(map&nbsp;cons&nbsp;'(a&nbsp;b&nbsp;c)&nbsp;'(1&nbsp;2&nbsp;3))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;((a&nbsp;.&nbsp;1)&nbsp;(b&nbsp;.&nbsp;2)&nbsp;(c&nbsp;.&nbsp;3))</tt>
<p>
  这些列表必须拥有相同的长度，并且映射过程的参数数量必须恰好等于列表数量。
  输出列表中每一个元素，都是对输入列表中对应元素应用该过程而得到的值。

<p>
  看一下 <tt>abs-all</tt> 的第一个定义, 你应该自己就能想出下面这个过程<a name="./start:s148"></a><tt>map1</tt>的定义。
  这个过程是一个受限制版的<tt>map</tt>，它只能把一个单参数的过程应用在单个列表上。

<p>

<p><tt>(define&nbsp;map1<a name="defn:map1"></a><br>

&nbsp;&nbsp;(lambda&nbsp;(p&nbsp;ls)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(null?&nbsp;ls)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'()<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cons&nbsp;(p&nbsp;(car&nbsp;ls))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(map1&nbsp;p&nbsp;(cdr&nbsp;ls))))))</tt>
<p>
<p><tt>(map1&nbsp;abs&nbsp;'(1&nbsp;-2&nbsp;3&nbsp;-4&nbsp;5&nbsp;-6))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(1&nbsp;2&nbsp;3&nbsp;4&nbsp;5&nbsp;6)</tt>
<p>
  我们所做的就是把对<tt>abs</tt>的调用都替换成了调用一个新的参数<tt>p</tt>。
  更通用的 <tt>map</tt> 将会在<a href="./control.html#g100">5.4</a>节给出。


<p>

<h4>Exercise <a name="g33"></a>2.8.1</h4>
<a name="./start:s149"></a>在<tt>tree-copy</tt>的定义中，如果你交换了<tt>cons</tt>的两个参数的顺序，会发生什么？

<p>


<p>

<h4>Exercise <a name="g34"></a>2.8.2</h4>

<a name="./start:s150"></a>查阅<a href="./objects.html#g109">6.3</a>节对<a name="./start:s151"></a><tt>append</tt>过程的描述，
然后定义一个有两个参数的版本。当你交换你自己定义的 <tt>append</tt> 中的两个参数的顺序时，会发生什么？

<p>


<p>

<h4>Exercise <a name="g35"></a>2.8.3</h4>
<a name="./start:s152"></a>定义过程 <a name="./start:s153"></a><tt>make-list</tt> 它接受一个非负整数<tt><i>n</i></tt>和一个对象，
返回一个新列表，长度为<tt><i>n</i></tt>，每一个元素都是这个对象。

<p>

<p><tt>(make-list&nbsp;7&nbsp;'())&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(()&nbsp;()&nbsp;()&nbsp;()&nbsp;()&nbsp;()&nbsp;())</tt>
<p>[<i>提示</i>: 基本情形应该是判断 <tt>(=&nbsp;<i>n</i>&nbsp;0)</tt>，递归步骤应该调用
  <tt>(-&nbsp;<i>n</i>&nbsp;1)</tt>。
  <tt>()</tt>是对列表递归的基本情形，0是对非负整数递归的基本情形。
  类似的（译注：与cdr比较），减1是让非负整数靠近0的最自然方式。

<p>


<p>

<h4>Exercise <a name="g36"></a>2.8.4</h4>
<a name="./start:s154"></a>过程 <tt>list-ref</tt> 和 <tt>list-tail</tt> 返回列表<i>ls</i>的第<i>n</i>个元素，和从第<i>n</i>个元素开始的tail（剩余的所有元素组成的列表）。

<p>

<p><tt>(list-ref&nbsp;'(1&nbsp;2&nbsp;3&nbsp;4)&nbsp;0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;1<br>

(list-tail&nbsp;'(1&nbsp;2&nbsp;3&nbsp;4)&nbsp;0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(1&nbsp;2&nbsp;3&nbsp;4)<br>

(list-ref&nbsp;'(a&nbsp;short&nbsp;(nested)&nbsp;list)&nbsp;2)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(nested)<br>

(list-tail&nbsp;'(a&nbsp;short&nbsp;(nested)&nbsp;list)&nbsp;2)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;((nested)&nbsp;list)</tt>
<p>定义这两个过程。

<p>


<p>

<h4>Exercise <a name="g37"></a>2.8.5</h4>
<a name="./start:s155"></a>Exercise&nbsp;<a href="./start.html#g31">2.7.2</a> 使用 <tt>length</tt> 定义了 <a name="./start:s156"></a><tt>shorter</tt>，返回两个列表参数中较短的一个，或者在两个列表长度相同的情况下返回第一个列表。
写一个新的 <tt>shorter</tt> ，不使用 <tt>length</tt>。
[<i>提示</i>: 定义一个递归“助手”：<a name="./start:s157"></a><tt>shorter?</tt>，并且使用这个来替换长度比较。]

<p>


<p>

<h4>Exercise <a name="g38"></a>2.8.6</h4>
<a name="./start:s158"></a><a name="EXEVENODD"></a>目前为止的所有递归都是直接递归。就是说每个过程都是直接把它们自己应用于一个新的参数之上。
其实也可以写两个过程，互相调用对方，构成间接递归。
定义过程 <a name="./start:s159"></a><tt>odd?</tt> （判断奇数的谓词）和 <a name="./start:s160"></a><tt>even?</tt> （判断偶数的谓词），互相建立在对方之上。
[<i>提示</i>: 当参数等于0的时候，它们分别应返回什么？]

<p>

<p><tt>(even?&nbsp;17)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(odd?&nbsp;17)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t</tt>
<p>


<p>

<h4>Exercise <a name="g39"></a>2.8.7</h4>
<a name="./start:s161"></a>使用 <a name="./start:s162"></a><tt>map</tt> 来定义过程 <tt>transpose</tt>，
它接受一个序对的列表，返回一个列表的序对，如下所示。

<p>

<p><tt>(transpose&nbsp;'((a&nbsp;.&nbsp;1)&nbsp;(b&nbsp;.&nbsp;2)&nbsp;(c&nbsp;.&nbsp;3)))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;((a&nbsp;b&nbsp;c)&nbsp;1&nbsp;2&nbsp;3)</tt>
<p>[<i>提示</i>: <tt>((a&nbsp;b&nbsp;c)&nbsp;1&nbsp;2&nbsp;3)</tt> 和 
  <tt>((a&nbsp;b&nbsp;c)&nbsp;.&nbsp;(1&nbsp;2&nbsp;3))</tt>是一样的。]

<p>


<p>

<h3><a name="g40"></a><a name="./start:h9"></a>2.9. 赋值<a name="SECTGSASSIGNMENT"></a></h3>



<p>
  虽然很多程序并不需要它们，<a name="./start:s163"></a>顶层变量赋值（译注：非本节提到的赋值）或是<a name="./start:s164"></a>
  <tt>let</tt>和 <tt>lambda</tt>变量绑定还是很有用的。
  赋值不像 <tt>let</tt> 或 <tt>lambda</tt> 那样产生一个新的绑定，而是修改一个已经存在的绑定的值。
  赋值使用 <a name="./start:s165"></a><tt>set!</tt> 来执行。

<p>

<p><tt>(define&nbsp;abcde&nbsp;'(a&nbsp;b&nbsp;c&nbsp;d&nbsp;e))<br>

abcde&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(a&nbsp;b&nbsp;c&nbsp;d&nbsp;e)<br>

(set!&nbsp;abcde&nbsp;(cdr&nbsp;abcde))<br>

abcde&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(b&nbsp;c&nbsp;d&nbsp;e)<br>

(let&nbsp;([abcde&nbsp;'(a&nbsp;b&nbsp;c&nbsp;d&nbsp;e)])<br>

&nbsp;&nbsp;(set!&nbsp;abcde&nbsp;(reverse&nbsp;abcde))<br>

&nbsp;&nbsp;abcde)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(e&nbsp;d&nbsp;c&nbsp;b&nbsp;a)</tt>
  
<p>
  很多语言需要用赋值来初始化局部变量，与变量绑定和声明存在区别。
  在Scheme中，所有局部变量都在绑定的时候直接给了一个值。和单独为局部变量赋值相比，这样能够保证程序员不会忘记初始化它们。
  而这正是大多数语言的常见错误来源。

<p>
  事实上，在其他语言中必须的或者方便的赋值操作在Scheme中既不必要也不方便，
  因为有更清晰的方式来替代赋值，表达相同的算法。
  一些语言中常见的一种做法是使用一系列的赋值操作来对一系列表达式求值，向下面这个过程对一个二次方程进行求根。

<p>

<p><tt>(define&nbsp;quadratic-formula<br>

&nbsp;&nbsp;(lambda&nbsp;(a&nbsp;b&nbsp;c)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([root1&nbsp;0]&nbsp;[root2&nbsp;0]&nbsp;[minusb&nbsp;0]&nbsp;[radical&nbsp;0]&nbsp;[divisor&nbsp;0])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set!&nbsp;minusb&nbsp;(-&nbsp;0&nbsp;b))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set!&nbsp;radical&nbsp;(sqrt&nbsp;(-&nbsp;(*&nbsp;b&nbsp;b)&nbsp;(*&nbsp;4&nbsp;(*&nbsp;a&nbsp;c)))))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set!&nbsp;divisor&nbsp;(*&nbsp;2&nbsp;a))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set!&nbsp;root1&nbsp;(/&nbsp;(+&nbsp;minusb&nbsp;radical)&nbsp;divisor))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set!&nbsp;root2&nbsp;(/&nbsp;(-&nbsp;minusb&nbsp;radical)&nbsp;divisor))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cons&nbsp;root1&nbsp;root2))))</tt>
<p>
  著名的二次方程求根公式，

<p>
<p>
<img src="math/tspl/4.gif" alt="<graphic>"><p>


<p>对方程 0 = <i>ax</i><sup>2</sup> + <i>bx</i> + <i>c</i>进行求根。
<tt>let</tt>表达式在这里唯一的作用就是建立变量绑定，和其他语言中的变量声明一样。
前三个赋值表达式分别计算了公式中的三个局部片段， -<i>b</i>, <img src="math/tspl/5.gif" alt="<graphic>"> 和 2<i>a</i>。
最后两个赋值表达式根据前三个的结果计算出了两个根。
由这两个根组成的序对，就是 <a name="./start:s166"></a><tt>quadratic-formula</tt> 的值。
例如， 2<i>x</i><sup>2</sup> - 4<i>x</i> - 6 的两个根是 <i>x</i> = 3 和 <i>x</i> = -1。

<p>

<p><tt>(quadratic-formula&nbsp;2&nbsp;-4&nbsp;-6)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(3&nbsp;.&nbsp;-1)</tt>
<p>The definition above works, but it can be written more clearly without the
assignments, as shown below.

<p>

<p><tt>(define&nbsp;quadratic-formula<br>

&nbsp;&nbsp;(lambda&nbsp;(a&nbsp;b&nbsp;c)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([minusb&nbsp;(-&nbsp;0&nbsp;b)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[radical&nbsp;(sqrt&nbsp;(-&nbsp;(*&nbsp;b&nbsp;b)&nbsp;(*&nbsp;4&nbsp;(*&nbsp;a&nbsp;c))))]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[divisor&nbsp;(*&nbsp;2&nbsp;a)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([root1&nbsp;(/&nbsp;(+&nbsp;minusb&nbsp;radical)&nbsp;divisor)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[root2&nbsp;(/&nbsp;(-&nbsp;minusb&nbsp;radical)&nbsp;divisor)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cons&nbsp;root1&nbsp;root2)))))</tt>
<p>
  在这个版本中，<tt>set!</tt>表达式消失了，而剩下的基本上是完全相同的算法。
  通过使用两层 <tt>let</tt> 表达式，这个定义清楚的展示了 <tt>root1</tt> 和 <tt>root2</tt> 对于
  <tt>minusb</tt>, <tt>radical</tt> 和 <tt>divisor</tt> 的依赖关系。
  同样重要的是，<tt>let</tt>表达式清楚的展现出了在 <tt>minusb</tt>, <tt>radical</tt>和 <tt>divisor</tt> 之间，
  以及 <tt>root1</tt> 和 <tt>root2</tt> 之间，是没有依赖关系的。

<p>
<p>
  在Scheme中赋值的确是有一定作用的，不然这个语言也不会去支持它。
  考虑下面这个版本的<tt>cons</tt>，它计算了自身被调用了多少次，把次数保存在了变量 <tt>cons-count</tt> 中。
  它使用了 <tt>set!</tt> 来增加这个变量的值。除了赋值之外，并没有其他途径来实现这个行为。

<p>

<p><tt>(define&nbsp;kons-count&nbsp;0)<br>

(define&nbsp;kons<br>

&nbsp;&nbsp;(lambda&nbsp;(x&nbsp;y)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(set!&nbsp;kons-count&nbsp;(+&nbsp;kons-count&nbsp;1))<br>

&nbsp;&nbsp;&nbsp;&nbsp;(cons&nbsp;x&nbsp;y)))
<br>
<br>
(kons&nbsp;'a&nbsp;'(b&nbsp;c))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(a&nbsp;b&nbsp;c)<br>

kons-count&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;1<br>

(kons&nbsp;'a&nbsp;(kons&nbsp;'b&nbsp;(kons&nbsp;'c&nbsp;'())))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(a&nbsp;b&nbsp;c)<br>

kons-count&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;4</tt>
  

<p>
  赋值通常被用来实现那些必须维持一些 <a name="./start:s167"></a>内部状态 的过程。
  例如，假设我们想要定义一个过程，第一次调用返回0，第二次调用返回1，第三次调用返回2，如此继续。
  我们可以写出下面这样类似 <tt>cons-count</tt> 的定义。

<p>

<p><tt>(define&nbsp;next&nbsp;0)<br>

(define&nbsp;count<br>

&nbsp;&nbsp;(lambda&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([v&nbsp;next])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set!&nbsp;next&nbsp;(+&nbsp;next&nbsp;1))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v)))
<br>
<br>
(count)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;0<br>

(count)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;1</tt>
<p>
  这个方案不太受欢迎，因为那个 <tt>next</tt> 变量在顶层空间可见，而这是不必要的。
  如果它在顶层空间可见，那么系统内的任何代码都可以改变它的值，有可能无意间微妙地影响了<tt>count</tt>的行为。
  我们可以用 <tt>let</tt> 在<tt>lambda</tt> 的外层来绑定这个 <tt>next</tt> 变量，来解决这个问题。

<p>

<p><tt>(define&nbsp;count<br>

&nbsp;&nbsp;(let&nbsp;([next&nbsp;0])<br>

&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([v&nbsp;next])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set!&nbsp;next&nbsp;(+&nbsp;next&nbsp;1))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v))))</tt>
<p>
  同时，后一个方案还能更轻松的提供多个计数器，每一个都有它自己的局部计数值。
  下面定义的 <a name="./start:s168"></a><tt>make-counter</tt> 过程，每次调用返回一个新的计数器过程。

<p>

<p><tt>(define&nbsp;make-counter<br>

&nbsp;&nbsp;(lambda&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([next&nbsp;0])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([v&nbsp;next])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set!&nbsp;next&nbsp;(+&nbsp;next&nbsp;1))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v)))))</tt>
<p>
  由于 <tt>next</tt> 的绑定是在 <tt>make-counter</tt> 的内部，
  并且在 <tt>make-counter</tt> 所返回的过程的外部，因此每个返回的过程都持有一个它自己独有的计数器。


<p>

<p><tt>(define&nbsp;count1&nbsp;(make-counter))<br>

(define&nbsp;count2&nbsp;(make-counter))
<br>
<br>
(count1)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;0<br>

(count2)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;0<br>

(count1)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;1<br>

(count1)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;2<br>

(count2)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;1</tt>
<p>
  如果一个状态变量必须在几个顶层定义的过程之间共享，
  但我们又不想让这个状态变量在顶层可见，我们就可以使用<tt>let</tt>来绑定这个变量，
  使用<tt>set!</tt>来让过程在顶层空间可见。<a name="./start:s169"></a><a name="./start:s170"></a>

<p>

<p><tt>(define&nbsp;shhh&nbsp;#f)<br>

(define&nbsp;tell&nbsp;#f)<br>

(let&nbsp;([secret&nbsp;0])<br>

&nbsp;&nbsp;(set!&nbsp;shhh<br>

&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(message)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set!&nbsp;secret&nbsp;message)))<br>

&nbsp;&nbsp;(set!&nbsp;tell<br>

&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;secret)))
<br>
<br>
(shhh&nbsp;"sally&nbsp;likes&nbsp;harry")<br>

(tell)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;"sally&nbsp;likes&nbsp;harry"<br>

secret&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;<i>exception:&nbsp;variable&nbsp;secret&nbsp;is&nbsp;not&nbsp;bound</i></tt>
<p>
  变量赋值之前必须先定义，所以我们定义<tt>shhh</tt> 和 <tt>tell</tt> 初始化成 <tt>#f</tt>
  （初始化成什么都可以。）
  我们将在&nbsp;<a href="./further.html#g79">3.5</a>节再次看到这个结构，而在&nbsp;<a href="./further.html#g84">3.6</a>节将看到一个更好的，用库来组织此类代码的方式。

<p>
<a name="./start:s171"></a>局部状态在存储计算结果，和<i>延迟</i>计算（只计算一次，只在需要的时候计算）时是很有用的。
下面的过程 <a name="./start:s172"></a><tt>lazy</tt> 接收一个<a name="./start:s173"></a><i>thunk</i>，即一个无参过程，作为参数。
Thunks经常用来“冻结”一个因为某些原因需要推迟的计算，这恰好是我们这里需要做的。
当我们把一个thunk <tt><i>t</i></tt> 传递进来时，<tt>lazy</tt> 返回一个新的 thunk ，这个thunk被调用时会返回“调用<tt><i>t</i></tt>得到的结果”。

一旦计算过了，值就会被存储在一个局部变量中，保证计算过程不会再次执行。
这里使用了一个布尔变量标志来记录 <tt><i>t</i></tt> 是否已经被调用过，值是否已经被保存。

<p>

<p><tt>(define&nbsp;lazy<br>

&nbsp;&nbsp;(lambda&nbsp;(t)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([val&nbsp;#f]&nbsp;[flag&nbsp;#f])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(not&nbsp;flag)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(begin&nbsp;(set!&nbsp;val&nbsp;(t))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set!&nbsp;flag&nbsp;#t)))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val))))</tt>
<p>这里有一个语法形式<a name="./start:s174"></a><tt>begin</tt>，第一次出现。它按顺序计算每一个子表达式的值，并且返回最后一个值，
  和 <tt>let</tt>、<tt>lambda</tt>表达式的主体一样。我们可以看到，
  <a name="./start:s175"></a><tt>if</tt>表达式的<tt><i>备选子表达式（译注：第三个参数）</i></tt>是可以省略的。
  只有像这个示例中这样，当<tt>if</tt>表达式本身的值直接被丢弃的时候，才可以这样省略。

<p>
  对于求值比较耗时的情况来说，惰性求值是非常有用的。
  通过延迟求值的时机，我们可能会完全避免求值的过程，
  通过保存求值结果，我们可以避免多次重复求值。

<p>
  <tt>惰性计算</tt>的操作最好的说明方式就是在传递进来的thunk里面打印一条消息。

<p>

<p><tt>(define&nbsp;p<br>

&nbsp;&nbsp;(lazy&nbsp;(lambda&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(display&nbsp;"Ouch!")<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(newline)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"got&nbsp;me")))</tt>
<p>
  第一次调用<tt>p</tt>的时候，打印了消息<tt>Ouch!</tt>，并且返回了字符串 <tt>"got&nbsp;me"</tt>。
  之后，依然返回 <tt>"got&nbsp;me"</tt> 但是不再打印消息了。
  <tt>display</tt> 和 <tt>newline</tt> 过程是我们最先接触到的显式的输入输出操作。
  <tt>display</tt> 打印字符串（不带引号），而 <tt>newline</tt> 打印一个换行符。

<p>
  为了进一步说明 <tt>set!</tt> 的用法，我们来看一个 <a name="./start:s176"></a> 栈对象的实现，
  这个实现内部的工作在外部是不可见的。
  一个栈对象接受这四个 <a name="./start:s177"></a><i>消息</i> 中的一个：
  <tt>empty?</tt>，当栈为空的时候返回 <tt>#t</tt>；
  <tt>push!</tt>，在栈顶增加一个对象；
  <tt>top</tt>，返回栈顶的对象；
  <tt>pop!</tt>，移除栈顶的对象。
<a name="./start:s178"></a><tt>make-stack</tt> 过程和<tt>make-counter</tt>的行为类似，每次调用的时候都会创建一个新的栈。
<p>

<p><tt>(define&nbsp;make-stack<br>

&nbsp;&nbsp;(lambda&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([ls&nbsp;'()])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(msg&nbsp;.&nbsp;args)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cond<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(eqv?&nbsp;msg&nbsp;'empty?)&nbsp;(null?&nbsp;ls)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(eqv?&nbsp;msg&nbsp;'push!)&nbsp;(set!&nbsp;ls&nbsp;(cons&nbsp;(car&nbsp;args)&nbsp;ls))]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(eqv?&nbsp;msg&nbsp;'top)&nbsp;(car&nbsp;ls)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(eqv?&nbsp;msg&nbsp;'pop!)&nbsp;(set!&nbsp;ls&nbsp;(cdr&nbsp;ls))]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[else&nbsp;"oops"])))))</tt>
<p>
  每一个栈实际上都是内部的变量 <tt>ls</tt> 上绑定的一个列表； <tt>set!</tt> 用来在 <tt>push!</tt> 和 <tt>pop!</tt> 的时候修改这个绑定。
  注意内部 <tt>lambda</tt> 的参数使用了非正规列表的形式，把除第一个之外的所有参数的列表绑定到 <tt>args</tt> 上。
  这个用法在这里很有用，因为在 <tt>empty?</tt> 、 <tt>top</tt> 和 <tt>pop!</tt> 这三种情况下，只有一个参数（消息名），
  但是在 <tt>push!</tt> 时，有两个参数（消息名和要放入栈中的对象）。

<p>

<p><tt>(define&nbsp;stack1&nbsp;(make-stack))<br>

(define&nbsp;stack2&nbsp;(make-stack))<br>

(list&nbsp;(stack1&nbsp;'empty?)&nbsp;(stack2&nbsp;'empty?))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(#t&nbsp;#t)
<br>
<br>
(stack1&nbsp;'push!&nbsp;'a)<br>

(list&nbsp;(stack1&nbsp;'empty?)&nbsp;(stack2&nbsp;'empty?))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(#f&nbsp;#t)
<br>
<br>
(stack1&nbsp;'push!&nbsp;'b)<br>

(stack2&nbsp;'push!&nbsp;'c)<br>

(stack1&nbsp;'top)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;b<br>

(stack2&nbsp;'top)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;c
<br>
<br>
(stack1&nbsp;'pop!)<br>

(stack1&nbsp;'top)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;a<br>

(list&nbsp;(stack1&nbsp;'empty?)&nbsp;(stack2&nbsp;'empty?))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(#f&nbsp;#f)
<br>
<br>
(stack1&nbsp;'pop!)<br>

(list&nbsp;(stack1&nbsp;'empty?)&nbsp;(stack2&nbsp;'empty?))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(#t&nbsp;#f)</tt>
<p>
  如同 <tt>make-counter</tt> 创建的计数器一样，每个栈对象内部维护的状态都只能在对象内部直接访问。
  对这个状态的任何引用和修改，都是由这个对象来间接完成的。
  这带来一个重要的好处，我们可以修改栈的内部结构，比如说使用一个向量（参见 <a href="./objects.html#g115">6.9</a>节）来代替列表存储元素，
  而这将不影响栈的任何外部行为。
  由于这个对象的行为是抽象的（非操作性的），我们称之为<i>抽象对象</i>。
  可以参考<a href="./examples.html#g193">12.8</a>节来获取更多关于创建 <a name="./start:s179"></a>抽象对象的信息。

<p>
  作为修改变量值的一个扩展，我们可以使用<tt>set-car!</tt> 和 <tt>set-cdr!</tt> 来修改一个序对的car和cdr。

<p>

<p><tt>(define&nbsp;p&nbsp;(list&nbsp;1&nbsp;2&nbsp;3))<br>

(set-car!&nbsp;(cdr&nbsp;p)&nbsp;'two)<br>

p&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(1&nbsp;two&nbsp;3)<br>

(set-cdr!&nbsp;p&nbsp;'())<br>

p&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(1)</tt>
<p><a name="queue-datatype"></a><a name="./start:s180"></a>我们可以使用这些操作来定义一个队列数据类型。队列和栈很相似，
  只是新元素被添加在一端而移除时在另一端。
  下面的队列实现，使用了 <a name="./start:s181"></a><i>tconc</i> 结构。
  一个tconc包括一个非空列表和一个头部（header）。header是一个序对，它的car指向非空列表的第一个序对，而cdr指向非空列表的最后一个序对。

<p>
<p>
<img src="math/tspl/6.gif" alt="<graphic>"><p>


<p>
  最后一个元素只是个占位符，并不是队列的一部分。

<p>
  下面定义队列的四个操作：
<a name="./start:s182"></a><tt>make-queue</tt>，构造一个队列。
<a name="./start:s183"></a><tt>putq!</tt>，向尾部添加一个元素；
<a name="./start:s184"></a><tt>getq</tt>，取出头部的第一个元素；
<a name="./start:s185"></a><tt>delq!</tt>，移除头部的第一个元素。

<p>

<p><tt>(define&nbsp;make-queue<br>

&nbsp;&nbsp;(lambda&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([end&nbsp;(cons&nbsp;'ignored&nbsp;'())])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cons&nbsp;end&nbsp;end))))
<br>
<br>
(define&nbsp;putq!<br>

&nbsp;&nbsp;(lambda&nbsp;(q&nbsp;v)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([end&nbsp;(cons&nbsp;'ignored&nbsp;'())])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set-car!&nbsp;(cdr&nbsp;q)&nbsp;v)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set-cdr!&nbsp;(cdr&nbsp;q)&nbsp;end)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set-cdr!&nbsp;q&nbsp;end))))
<br>
<br>
(define&nbsp;getq<br>

&nbsp;&nbsp;(lambda&nbsp;(q)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(car&nbsp;(car&nbsp;q))))
<br>
<br>
(define&nbsp;delq!<br>

&nbsp;&nbsp;(lambda&nbsp;(q)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(set-car!&nbsp;q&nbsp;(cdr&nbsp;(car&nbsp;q)))))</tt>
<p>
  这些操作都比较简单，除了<tt>putq!</tt>，它把当前的end序对改成包含新的值，然后添加一个新的end序对。

<p>

<p><tt>(define&nbsp;myq&nbsp;(make-queue))
<br>
<br>
(putq!&nbsp;myq&nbsp;'a)<br>

(putq!&nbsp;myq&nbsp;'b)<br>

(getq&nbsp;myq)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;a<br>

(delq!&nbsp;myq)<br>

(getq&nbsp;myq)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;b<br>

(delq!&nbsp;myq)<br>

(putq!&nbsp;myq&nbsp;'c)<br>

(putq!&nbsp;myq&nbsp;'d)<br>

(getq&nbsp;myq)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;c<br>

(delq!&nbsp;myq)<br>

(getq&nbsp;myq)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;d</tt>
<p>
<h4>Exercise <a name="g41"></a>2.9.1</h4>
<a name="./start:s186"></a>修改 <a name="./start:s187"></a><tt>make-counter</tt> 过程，接受两个参数：
一个用来代替0的counter初始值，和一个每次计数的增量值。

<p>


<p>

<h4>Exercise <a name="g42"></a>2.9.2</h4>
<a name="./start:s188"></a>查看<a href="./control.html#g99">5.3</a>节中关于 <a name="./start:s189"></a><tt>case</tt> 的描述。
把 <a name="./start:s190"></a><tt>make-stack</tt> 中的 <tt>cond</tt> 表达式用等价的 <tt>case</tt> 表达式替换掉。
<span class="todo">添加 <tt>mt?</tt> 作为 <tt>empty?</tt> 消息的第二个名字。</span>

<p>


<p>

<h4>Exercise <a name="g43"></a>2.9.3</h4>
<a name="./start:s191"></a><a name="EXSTACKREFANDSET"></a>修改 <tt>栈（stack）</tt> 对象，支持两个消息： <tt>ref</tt> 和
<tt>set!</tt>。
<tt>(<i>stack</i>&nbsp;'ref&nbsp;<i>i</i>)</tt> 返回从栈顶开始算的第 <tt><i>i</i></tt>个元素；
<tt>(<i>stack</i>&nbsp;'ref&nbsp;0)</tt> 等价于 <tt>(<i>stack</i>&nbsp;'top)</tt>。
<tt>(<i>stack</i>&nbsp;'set!&nbsp;<i>i</i>&nbsp;<i>v</i>)</tt> 把从栈顶开始算的第 <tt><i>i</i></tt>个元素修改成 <tt><i>v</i></tt> 。

<p>

<p><tt>(define&nbsp;stack&nbsp;(make-stack))
<br>
<br>
(stack&nbsp;'push!&nbsp;'a)<br>

(stack&nbsp;'push!&nbsp;'b)<br>

(stack&nbsp;'push!&nbsp;'c)
<br>
<br>
(stack&nbsp;'ref&nbsp;0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;c<br>

(stack&nbsp;'ref&nbsp;2)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;a<br>

(stack&nbsp;'set!&nbsp;1&nbsp;'d)<br>

(stack&nbsp;'ref&nbsp;1)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;d<br>

(stack&nbsp;'top)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;c<br>

(stack&nbsp;'pop!)<br>

(stack&nbsp;'top)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;d</tt>
<p>[<i>提示</i>：用<tt>list-ref</tt> 去实现 <tt>ref</tt>，用 <tt>list-tail</tt> 配合 <tt>set-car!</tt> 去实现 <tt>set!</tt>。]

<p>


<p>

<h4>Exercise <a name="g44"></a>2.9.4</h4>
<a name="./start:s192"></a><a name="./start:s193"></a>Scheme 不仅支持列表，也支持 <i>向量（vectors）</i>。
同列表一样，向量也是其他对象的集合。
不同的是，向量拥有固定的大小，并且存储在一块连续内存上，通常有一个头部结构，记录了向量的长度，如下面这个10个元素的向量所示。

<p>
<p>
<img src="math/tspl/7.gif" alt="<graphic>"><p>


<p>
  这使得向量在需要快速访问集合中任意元素的场景下更适用一些，
  而在数据集合的规模需要增长或缩小的场景中不那么适用。

<p>
  查看第<a href="./objects.html#g115">6.9</a>节关于向量（vector）的基本操作，然后重新实现<tt>栈（stack）</tt> 对象，
  使用向量来代替列表存储栈的内容。
  实现要包括在Exercise&nbsp;<a href="./start.html#g43">2.9.3</a>中提到的 <tt>ref</tt> 和 <tt>set!</tt> 消息。
  让这个新的 <tt>make-stack</tt> 过程接受一个长度参数 <i>n</i>，使得向量的长度为 <i>n</i>，但是不要改变外部（抽象）接口。

<p>


<p>

<h4>Exercise <a name="g45"></a>2.9.5</h4>
<a name="./start:s194"></a>定义一个谓词 <tt>emptyq?</tt>，判断一个队列是否为空。
修改 <tt>getq</tt> 和 <tt>delq!</tt> ，当作用于一个空的队列上时，使用 <tt>assertion-violation</tt> 抛出一个异常。

<p>



<p>

<h4>Exercise <a name="g46"></a>2.9.6</h4>
<a name="./start:s195"></a>在队列的实现中，内部列表的最后一个序对是个占位符，就是说它不持有任何有用的数据。
重写列表的操作，避免这个序对的浪费。
确保之前给出的一系列对队列的操作在新的实现上依然可行。
你比较倾向于哪种实现方式？

<p>


<p>

<h4>Exercise <a name="g47"></a>2.9.7</h4>
<a name="./start:s196"></a>使用 <a name="./start:s197"></a><tt>set-cdr!</tt> 可能创建出一个 <a name="./start:s198"></a><i>环状列表（cyclic lists）</i>。
例如，下面的表达式结果是一个列表，它的car是符号 <tt>a</tt>，cdr则是这个列表本身。

<p>

<p><tt>(let&nbsp;([ls&nbsp;(cons&nbsp;'a&nbsp;'())])<br>

&nbsp;&nbsp;(set-cdr!&nbsp;ls&nbsp;ls)<br>

&nbsp;&nbsp;ls)</tt>
<p>
  当你把上面表达式输入你的Scheme交互式会话中时，发生了什么？
  如果使用 <a href="./start.html#defn:simplelength">42</a> 页实现的那个 <tt>length</tt> 过程来求这个环状列表的长度，会发生什么？
  内置的原始过程 <tt>length</tt> 又会如何表现？

<p>



<p>

<h4>Exercise <a name="g48"></a>2.9.8</h4>
<a name="./start:s199"></a><a name="EXLIST?"></a>定义谓词 <a name="./start:s200"></a><tt>list?</tt>，当参数为
 <a name="./start:s201"></a>正规列表时，返回<tt>#t</tt>，否则返回<tt>#f</tt>（参考<a href="./objects.html#g109">6.3</a>节）。
 和其它以非空表 <tt>()</tt> 结尾的列表一样，环状列表也应该返回 <tt>#f</tt> 。


<p>

<p><tt>(list?&nbsp;'())&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(list?&nbsp;'(1&nbsp;2&nbsp;3))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(list?&nbsp;'(a&nbsp;.&nbsp;b))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(list?&nbsp;(let&nbsp;([ls&nbsp;(cons&nbsp;'a&nbsp;'())])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set-cdr!&nbsp;ls&nbsp;ls)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ls))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f</tt>
<p>
  先写一个简化版本的 <tt>list?</tt>，不处理环状列表，然后扩展它，使得能够正确处理环状列表。
  反复修改你的代码，直到你对它的简洁、清晰程度感到满意。
  [<i>提示</i>：使用<a name="./start:s202"></a>“龟兔赛跑” 算法来检测环。
  定义一个辅助递归过程，接受两个参数，一只兔子和一只乌龟。把它们都放在这个列表的头部。每次让兔子前进两个cdr，乌龟前进一个cdr。
  如果这个兔子追上了乌龟，那么这个列表中必定有一个环。]


<p>


<p>




<hr class=copyright align=left>
<p>
R. Kent Dybvig / <it>The Scheme Programming Language, Fourth Edition</it><br>
Copyright &copy; 2009 <a class=plain href="http://mitpress.mit.edu/catalog/item/default.asp?ttype=2&tid=11984">The MIT Press</a>.  Electronically reproduced by permission.<br>
Illustrations &copy; 2009 <a class=plain href="http://hebert.kitp.ucsb.edu/">Jean-Pierre H&eacute;bert</a><br>
ISBN 978-0-262-51298-5 / LOC QA76.73.S34D93<br>
<a class=plain href="http://mitpress.mit.edu/catalog/item/default.asp?ttype=2&tid=11984">to order this book</a> / <a class=plain href="canned/about.html">about this book</a>
</p>
<p><a class=plain href="http://www.scheme.com">http://www.scheme.com</a></p>
</body>
</html>
