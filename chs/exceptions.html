<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
  "http://www.w3.org/TR/html4/loose.dtd"><!-- DO NOT EDIT THIS FILE-->
<!-- Edit the .tex version instead-->

<html>
<head>
<meta charset="utf-8">
<title>Exceptions and Conditions</title>
<link href="tspl.css" rel="stylesheet" type="text/css">
</head>
<body>
<a name="g147"></a>
<a name="./exceptions:h0"></a>

<div style="font-size: 12px; width: 500px; height: 500px; border: solid thin">
<img style="padding: 20px 10px 20px 20px" src="canned/ch11.png"><img src="canned/jph.png">
</div>
<h1>Chapter 11. Exceptions and Conditions<a name="CHPTEXCEPTIONS"></a></h1>





<p>
<a name="./exceptions:s0"></a><a name="./exceptions:s1"></a><i>Exceptions</i> and
<i>conditions</i> provide the means for system and user code
to signal, detect, and recover from errors that occur when
a program is run.

<p>
Exceptions are raised by the standard syntactic forms and procedures under
a variety of circumstances, e.g., when the wrong number of arguments is
passed to a procedure, when the syntax of an expression passed to <tt>eval</tt> is
incorrect, or when a file cannot be opened by one of the file open
procedures.
In these situations, the exception is raised with a standard condition
type.

<p>
Exceptions may also be raised by user code via the <tt>raise</tt> or
<tt>raise-continuable</tt> procedures.
In this case, the exception may be raised with one of the standard
condition types, a user-defined subtype of one of the standard condition
types (possibly defined using <tt>define-condition-type</tt>), or an
arbitrary Scheme value that is not a condition type.

<p>
<a name="./exceptions:s2"></a>At any point during a program's execution, a single exception handler,
called the <i>current exception handler</i>, is charged with handling all
exceptions that are raised.
By default, the current exception handler is one provided by the
implementation.
The default exception handler typically prints a message that describes
the condition or other value with which the exception was raised and,
for any serious condition, terminates the running program.
In interactive systems, this typically means a reset to the
read-eval-print loop.

<p>
User code may establish a new current exception handler via the
<tt>guard</tt> syntax or the <tt>with-exception-handler</tt> procedure.
In either case, the user code may handle all exceptions or, based on the
condition or other value with which the exception was raised, just some of
the exceptions while reraising the others for the old current exception
handler to handle.
When <tt>guard</tt> forms and <tt>with-exception-handler</tt> calls are
nested dynamically, a chain of exception handlers is established, and
each may defer to the next in the chain.


<p>

<h3><a name="g148"></a><a name="./exceptions:h1"></a>Section 11.1. Raising and Handling Exceptions</h3>



<p>
<a name="./exceptions:s3"></a><span class=formdef><b>procedure</b>: <tt>(raise&nbsp;<i>obj</i>)</tt></span>
<br>
<span class=formdef><b>procedure</b>: <tt>(raise-continuable&nbsp;<i>obj</i>)</tt></span>
<br>
<b>returns: </b>see below
<br>
<b>libraries: </b><tt>(rnrs&nbsp;exceptions)</tt>, <tt>(rnrs)</tt>

<p>Both of these procedures raise an exception, effectively invoking the
current exception handler, passing <tt><i>obj</i></tt> as the only argument.
For <tt>raise</tt>, the exception is <i>non-continuable</i>, while
for <tt>raise-continuable</tt>, the exception is <i>continuable</i>.
An exception handler may return (with zero or more values) to the
continuation of a continuable exception.
If an exception handler attempts to return to the continuation of a
non-continuable exception, however, a new exception with condition type
<tt>&amp;non-continuable</tt> is raised.
Thus, <tt>raise</tt> never returns, while <tt>raise-continuable</tt>
may return zero or more values, depending upon the exception handler.

<p>
If the current exception handler, <tt><i>p</i></tt>, was established via a
<tt>guard</tt> form or call to <tt>with-exception-handler</tt>, the
current exception handler is reset to the handler that was current when
<tt><i>p</i></tt> was established before <tt>raise</tt> or
<tt>raise-continuable</tt> invokes <tt><i>p</i></tt>.
This allows <tt><i>p</i></tt> to defer to the preexisting exception handler simply
by reraising the exception, and it helps prevent infinite regression when
an exception handler inadvertently causes a different exception to be raised.
If <tt><i>p</i></tt> returns and the exception is continuable, <tt><i>p</i></tt> is
reinstated as the current exception handler.

<p>

<p><tt>(raise<br>

&nbsp;&nbsp;(condition<br>

&nbsp;&nbsp;&nbsp;&nbsp;(make-error)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(make-message-condition&nbsp;"no&nbsp;go")))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;<i>error:&nbsp;no&nbsp;go</i><br>

(raise-continuable<br>

&nbsp;&nbsp;(condition<br>

&nbsp;&nbsp;&nbsp;&nbsp;(make-violation)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(make-message-condition&nbsp;"oops")))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;<i>violation:&nbsp;oops</i><br>

(list<br>

&nbsp;&nbsp;(call/cc<br>

&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(k)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(vector<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(with-exception-handler<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(x)&nbsp;(k&nbsp;(+&nbsp;x&nbsp;5)))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;()&nbsp;(+&nbsp;(raise&nbsp;17)&nbsp;8)))))))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(22)<br>

(list<br>

&nbsp;&nbsp;(vector<br>

&nbsp;&nbsp;&nbsp;&nbsp;(with-exception-handler<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(x)&nbsp;(+&nbsp;x&nbsp;5))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;()&nbsp;(+&nbsp;(raise-continuable&nbsp;17)&nbsp;8)))))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(#(30))<br>

(list<br>

&nbsp;&nbsp;(vector<br>

&nbsp;&nbsp;&nbsp;&nbsp;(with-exception-handler<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(x)&nbsp;(+&nbsp;x&nbsp;5))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;()&nbsp;(+&nbsp;(raise&nbsp;17)&nbsp;8)))))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;<i>violation:&nbsp;non-continuable</i></tt>
<p><a name="./exceptions:s4"></a><span class=formdef><b>procedure</b>: <tt>(error&nbsp;<i>who</i>&nbsp;<i>msg</i>&nbsp;<i>irritant</i>&nbsp;...)</tt></span>
<br>
<span class=formdef><b>procedure</b>: <tt>(assertion-violation&nbsp;<i>who</i>&nbsp;<i>msg</i>&nbsp;<i>irritant</i>&nbsp;...)</tt></span>
<br>
<b>libraries: </b><tt>(rnrs&nbsp;base)</tt>, <tt>(rnrs)</tt>

<p><tt>error</tt> raises a non-continuable exception with condition type
<tt>&amp;error</tt> and should be used to describe situations for which the
<tt>&amp;error</tt> condition type is appropriate, typically a situation
involving the program's interaction with something outside of the program.
<tt>assertion-violation</tt> raises a non-continuable exception with
condition type <tt>&amp;assertion</tt> and should be used to describe
situations for which the <tt>&amp;assertion</tt> condition type is
appropriate, typically an invalid argument to a procedure or invalid value
of a subexpression of a syntactic form.

<p>
The continuation object with which the exception is raised also includes
a <tt>&amp;who</tt> condition whose who field is <tt><i>who</i></tt> if <tt><i>who</i></tt> is
not <tt>#f</tt>, a <tt>&amp;message</tt> condition whose message field is
<tt><i>msg</i></tt>, and an <tt>&amp;irritants</tt> condition whose irritants field
is <tt>(<i>irritant</i>&nbsp;...)</tt>.

<p>
<tt><i>who</i></tt> must be a string, a symbol, or <tt>#f</tt> identifying the procedure
or syntactic form reporting the error upon whose behalf the error is being
reported.
It is usually best to identify a procedure the programmer has called rather
than some other procedure the programmer may not be aware is involved in
carrying out the operation.
<tt><i>msg</i></tt> must be a string and should describe the exceptional situation.
The irritants may be any Scheme objects and should include values that may
have caused or been materially involved in the exceptional situation.

<p>
<a name="./exceptions:s5"></a><span class=formdef><b>syntax</b>: <tt>(assert&nbsp;<i>expression</i>)</tt></span>
<br>
<b>returns: </b>see below
<br>
<b>libraries: </b><tt>(rnrs&nbsp;base)</tt>, <tt>(rnrs)</tt>

<p><tt>assert</tt> evaluates <tt><i>expression</i></tt> and returns the value of
<tt><i>expression</i></tt> if the value is not <tt>#f</tt>.
If the value of <tt><i>expression</i></tt> is <tt>#f</tt>, <tt>assert</tt> raises a
non-continuable exception with condition types <tt>&amp;assertion</tt> and
<tt>&amp;message</tt>, with an implementation-dependent value in its message
field.
Implementations are encouraged to provide information about the location
of the <tt>assert</tt> call within the condition whenever possible.


<p>
<a name="./exceptions:s6"></a><span class=formdef><b>procedure</b>: <tt>(syntax-violation&nbsp;<i>who</i>&nbsp;<i>msg</i>&nbsp;<i>form</i>)</tt></span>
<br>
<span class=formdef><b>procedure</b>: <tt>(syntax-violation&nbsp;<i>who</i>&nbsp;<i>msg</i>&nbsp;<i>form</i>&nbsp;<i>subform</i>)</tt></span>
<br>
<b>returns: </b>does not return
<br>
<b>libraries: </b><tt>(rnrs&nbsp;syntax-case)</tt>, <tt>(rnrs)</tt>

<p>This procedure raises a non-continuable exception with a condition of type
<tt>&amp;syntax</tt>.
It should be used to report a syntax error detected by the transformer of
a syntactic extension.
The value of the condition's form field is <tt><i>form</i></tt>, and the value of
its subform field is <tt><i>subform</i></tt>, or <tt>#f</tt> if <tt><i>subform</i></tt> is
not provided.

<p>
The continuation object with which the exception is raised also includes
a <tt>&amp;who</tt> condition whose who field is <tt><i>who</i></tt>, if <tt><i>who</i></tt> is
not <tt>#f</tt> or is inferred from <tt><i>form</i></tt>, and a <tt>&amp;message</tt>
condition whose message field is <tt><i>msg</i></tt>.

<p>
<tt><i>who</i></tt> must be a string, a symbol, or <tt>#f</tt>.
If <tt><i>who</i></tt> is <tt>#f</tt>, it is inferred to be the symbolic name of <tt><i>form</i></tt>
if <tt><i>form</i></tt> is an identifier or the symbolic name of the first subform
of <tt><i>form</i></tt> if <tt><i>form</i></tt> is a list-structured form whose first subform
is an identifier.
<tt><i>message</i></tt> must be a string.
<tt><i>form</i></tt> should be the syntax object or datum representation of the
syntactic form within which the syntax violation occurred, and
<tt><i>subform</i></tt>, if not <tt>#f</tt>, should be a syntax object or datum
representation of a subform more specifically involved in the violation.
For example, if a duplicate formal parameter is found in a <tt>lambda</tt> expression,
<tt><i>form</i></tt> might be the <tt>lambda</tt> expression and <tt><i>subform</i></tt> might be
the duplicated parameter.

<p>
Some implementations attach source information to syntax objects, e.g.,
line, character, and filename for forms originating in a file, in which case
this information might also be present as some implementation-dependent
condition type within the condition object.

<p>
<a name="./exceptions:s7"></a><span class=formdef><b>procedure</b>: <tt>(with-exception-handler&nbsp;<i>procedure</i>&nbsp;<i>thunk</i>)</tt></span>
<br>
<b>returns: </b>see below
<br>
<b>libraries: </b><tt>(rnrs&nbsp;exceptions)</tt>, <tt>(rnrs)</tt>

<p>This procedure establishes <tt><i>procedure</i></tt>, which should accept one argument,
as the current exception handler in place of the old current exception handler,
<tt><i>old-proc</i></tt>, and invokes <tt><i>thunk</i></tt> without arguments.
If the call to <tt><i>thunk</i></tt> returns, <tt><i>old-proc</i></tt> is reestablished as
the current exception handler and the values returned by <tt><i>thunk</i></tt> are
returned.
If control leaves or subsequently reenters the call to <tt><i>thunk</i></tt> via the
invocation of a continuation obtained via <tt>call/cc</tt>, the procedure
that was the current exception handler when the continuation was
captured is reinstated.

<p>

<p><tt>(define&nbsp;(try&nbsp;thunk)<br>

&nbsp;&nbsp;(call/cc<br>

&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(k)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(with-exception-handler<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(x)&nbsp;(if&nbsp;(error?&nbsp;x)&nbsp;(k&nbsp;#f)&nbsp;(raise&nbsp;x)))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;thunk))))<br>

(try&nbsp;(lambda&nbsp;()&nbsp;17))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;17<br>

(try&nbsp;(lambda&nbsp;()&nbsp;(raise&nbsp;(make-error))))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(try&nbsp;(lambda&nbsp;()&nbsp;(raise&nbsp;(make-violation))))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;<i>violation</i><br>

(with-exception-handler<br>

&nbsp;&nbsp;(lambda&nbsp;(x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(raise<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(apply&nbsp;condition<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(make-message-condition&nbsp;"oops")<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(simple-conditions&nbsp;x))))<br>

&nbsp;&nbsp;(lambda&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;(try&nbsp;(lambda&nbsp;()&nbsp;(raise&nbsp;(make-violation))))))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;<i>violation:&nbsp;oops</i></tt>
<p><a name="./exceptions:s8"></a><span class=formdef><b>syntax</b>: <tt>(guard&nbsp;(<i>var</i>&nbsp;<i>clause<sub>1</sub></i>&nbsp;<i>clause<sub>2</sub></i>&nbsp;...)&nbsp;<i>b1</i>&nbsp;<i>b2</i>&nbsp;...)</tt></span>
<br>
<b>returns: </b>see below
<br>
<b>libraries: </b><tt>(rnrs&nbsp;exceptions)</tt>, <tt>(rnrs)</tt>

<p>A <tt>guard</tt> expression establishes a new current exception handler,
<tt><i>procedure</i></tt> (described below), in place of the old current exception handler, <tt><i>old-proc</i></tt>,
and evaluates the body <tt><i>b1</i>&nbsp;<i>b2</i>&nbsp;...</tt>.
If the body returns, <tt>guard</tt> reestablishes <tt><i>old-proc</i></tt> as the current
exception handler.
If control leaves or subsequently reenters the body via the
invocation of a continuation obtained via <tt>call/cc</tt>, the procedure
that was the current exception handler when the continuation was
captured is reinstated.

<p>
The procedure <tt><i>procedure</i></tt> established by <tt>guard</tt> binds <tt><i>var</i></tt>
to the value it receives and, within the scope of that binding, processes
the clauses <tt><i>clause<sub>1</sub></i>&nbsp;<i>clause<sub>2</sub></i>&nbsp;...</tt> in turn, as
if contained within an implicit <tt>cond</tt> expression.
This implicit <tt>cond</tt> expression is evaluated in the continuation
of the <tt>guard</tt> expression, with <tt><i>old-proc</i></tt> as the current
exception handler.

<p>
If no <tt>else</tt> clause is provided, <tt>guard</tt> supplies one
that reraises the exception with the same value, as if with
<tt>raise-continuable</tt>, in the continuation of the call to <tt><i>procedure</i></tt>,
with <tt><i>old-proc</i></tt> as the current exception handler.

<p>

<p><tt>(guard&nbsp;(x&nbsp;[else&nbsp;x])&nbsp;(raise&nbsp;"oops"))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;"oops"<br>

(guard&nbsp;(x&nbsp;[#f&nbsp;#f])&nbsp;(raise&nbsp;(make-error)))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;&nbsp;<i>error</i><br>

(define-syntax&nbsp;try<br>

&nbsp;&nbsp;(syntax-rules&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;e1&nbsp;e2&nbsp;...)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(guard&nbsp;(x&nbsp;[(error?&nbsp;x)&nbsp;#f])&nbsp;e1&nbsp;e2&nbsp;...)]))<br>

(define&nbsp;open-one<br>

&nbsp;&nbsp;(lambda&nbsp;fn*<br>

&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;loop&nbsp;([ls&nbsp;fn*])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(null?&nbsp;ls)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(error&nbsp;'open-one&nbsp;"all&nbsp;open&nbsp;attempts&nbsp;failed"&nbsp;fn*)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(or&nbsp;(try&nbsp;(open-input-file&nbsp;(car&nbsp;ls)))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(loop&nbsp;(cdr&nbsp;ls)))))))<br>

;&nbsp;say&nbsp;bar.ss&nbsp;exists&nbsp;but&nbsp;not&nbsp;foo.ss:<br>

(open-one&nbsp;"foo.ss"&nbsp;"bar.ss")&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#&lt;input&nbsp;port&nbsp;bar.ss&gt;</tt>
<p>
<h3><a name="g149"></a><a name="./exceptions:h2"></a>Section 11.2. Defining Condition Types</h3>



<p>
<a name="./exceptions:s9"></a><a name="./exceptions:s10"></a>While a program may pass <tt>raise</tt> or <tt>raise-continuable</tt>
any Scheme value, the best way to describe an exceptional situation is
usually to create and pass a <i>condition object</i>.
Where the Revised<sup>6</sup> Report requires the implementation to raise
exceptions, the value passed to the current exception handler is always
a condition object of one or more of the standard <i>condition types</i>
described in Section&nbsp;<a href="./exceptions.html#g150">11.3</a>.
User code may create a condition object that is an instance of one or more
standard condition types or it may create an extended
condition type and create a condition object of that type.

<p>
<a name="./exceptions:s11"></a><a name="./exceptions:s12"></a>Condition types are similar to record types but are more flexible in
that a condition object may be an instance of two or more condition
types, even if neither is a subtype of the other.
When a condition is an instance of multiple types, it is referred to
as a <i>compound condition</i>.
Compound conditions are useful for communicating multiple pieces
of information about an exception to the exception handler.
A condition that is not a compound condition is referred to as a
<i>simple condition</i>.
In most cases, the distinction between the two is unimportant, and
a simple condition is treated as if it were a compound condition
with itself as its only simple condition.

<p>
<a name="./exceptions:s13"></a><span class=formdef><b>syntax</b>: <tt>&amp;condition</tt></span>
<br>
<b>libraries: </b><tt>(rnrs&nbsp;conditions)</tt>, <tt>(rnrs)</tt>

<p><tt>&amp;condition</tt> is a record-type name (Chapter&nbsp;<a href="./records.html#g138">9</a>) and
the root of the condition-type hierarchy.
All simple condition types are extensions of this type, and all
conditions, whether simple or compound, are considered instances
of this type.

<p>
<a name="./exceptions:s14"></a><span class=formdef><b>procedure</b>: <tt>(condition?&nbsp;<i>obj</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if <tt><i>obj</i></tt> is a condition object, otherwise <tt>#f</tt>
<br>
<b>libraries: </b><tt>(rnrs&nbsp;conditions)</tt>, <tt>(rnrs)</tt>

<p>A condition object is an instance of a subtype of <tt>&amp;condition</tt>
or a compound condition, possibly created by user code with
<tt>condition</tt>.

<p>

<p><tt>(condition?&nbsp;'stable)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(condition?&nbsp;(make-error))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(condition?&nbsp;(make-message-condition&nbsp;"oops"))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(condition?<br>

&nbsp;&nbsp;(condition<br>

&nbsp;&nbsp;&nbsp;&nbsp;(make-error)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(make-message-condition&nbsp;"no&nbsp;such&nbsp;element")))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t</tt>
<p><a name="./exceptions:s15"></a><span class=formdef><b>procedure</b>: <tt>(condition&nbsp;<i>condition</i>&nbsp;...)</tt></span>
<br>
<b>returns: </b>a condition, possibly compound
<br>
<b>libraries: </b><tt>(rnrs&nbsp;conditions)</tt>, <tt>(rnrs)</tt>

<p><tt>condition</tt> is used to create condition objects that may consist
of multiple simple conditions.
Each argument <tt><i>condition</i></tt> may be simple or complex; if simple, it is
treated as a compound condition with itself as its only simple condition.
The simple conditions of the result condition are the simple conditions of
the <tt><i>condition</i></tt> arguments, flattened into a single list and appearing
in order, with the simple conditions of the first <tt><i>condition</i></tt> followed
by the simple conditions of the second, and so on.

<p>
If the list has exactly one element, the result condition may be simple or
compound; otherwise it is compound.
The distinction between simple and compound conditions is not usually
important but can be detected, if <tt>define-record-type</tt> rather
than <tt>define-condition-type</tt> is used to extend an existing
condition type, via the predicate defined by <tt>define-record-type</tt>.

<p>

<p><tt>(condition)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#&lt;condition&gt;<br>

(condition<br>

&nbsp;&nbsp;(make-error)<br>

&nbsp;&nbsp;(make-message-condition&nbsp;"oops"))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#&lt;condition&gt;
<br>
<br>
(define-record-type&nbsp;(&amp;xcond&nbsp;make-xcond&nbsp;xcond?)&nbsp;(parent&nbsp;&amp;condition))<br>

(xcond?&nbsp;(make-xcond))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(xcond?&nbsp;(condition&nbsp;(make-xcond)))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t&nbsp;<i>or</i>&nbsp;#f<br>

(xcond?&nbsp;(condition))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(xcond?&nbsp;(condition&nbsp;(make-error)&nbsp;(make-xcond)))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f</tt>
<p><a name="./exceptions:s16"></a><span class=formdef><b>procedure</b>: <tt>(simple-conditions&nbsp;<i>condition</i>)</tt></span>
<br>
<b>returns: </b>a list of the simple conditions of <tt><i>condition</i></tt>
<br>
<b>libraries: </b><tt>(rnrs&nbsp;conditions)</tt>, <tt>(rnrs)</tt>

<p>
<p><tt>
(simple-conditions&nbsp;(condition))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;'()<br>

(simple-conditions&nbsp;(make-error))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(#&lt;condition&nbsp;&amp;error&gt;)<br>

(simple-conditions&nbsp;(condition&nbsp;(make-error)))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(#&lt;condition&nbsp;&amp;error&gt;)<br>

(simple-conditions<br>

&nbsp;&nbsp;(condition<br>

&nbsp;&nbsp;&nbsp;&nbsp;(make-error)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(make-message-condition<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"oops")))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(#&lt;condition&nbsp;&amp;error&gt;&nbsp;#&lt;condition&nbsp;&amp;message&gt;)
<br>
<br>
(let&nbsp;([c1&nbsp;(make-error)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[c2&nbsp;(make-who-condition&nbsp;"f")]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[c3&nbsp;(make-message-condition&nbsp;"invalid&nbsp;argument")]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[c4&nbsp;(make-message-condition<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"error&nbsp;occurred&nbsp;while&nbsp;reading&nbsp;from&nbsp;file")]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[c5&nbsp;(make-irritants-condition&nbsp;'("a.ss"))])<br>

&nbsp;&nbsp;(equal?<br>

&nbsp;&nbsp;&nbsp;&nbsp;(simple-conditions<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(condition<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(condition&nbsp;(condition&nbsp;c1&nbsp;c2)&nbsp;c3)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(condition&nbsp;c4&nbsp;(condition&nbsp;c5))))<br>

&nbsp;&nbsp;&nbsp;&nbsp;(list&nbsp;c1&nbsp;c2&nbsp;c3&nbsp;c4&nbsp;c5)))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t</tt>
<p><a name="./exceptions:s17"></a><span class=formdef><b>syntax</b>: <tt>(define-condition-type&nbsp;<i>name</i>&nbsp;<i>parent</i>&nbsp;<i>constructor</i>&nbsp;<i>pred</i>&nbsp;<i>field</i>&nbsp;...)</tt></span>
<br>
<b>libraries: </b><tt>(rnrs&nbsp;conditions)</tt>, <tt>(rnrs)</tt>

<p>A <tt>define-condition-type</tt> form is a definition and may appear anywhere other
definitions may appear.
It is used to define new simple condition types.

<p>
The subforms <tt><i>name</i></tt>, <tt><i>parent</i></tt>, <tt><i>constructor</i></tt>, and <tt><i>pred</i></tt>
must be identifiers.
Each <tt><i>field</i></tt> must be of the form
<tt>(<i>field-name</i>&nbsp;<i>accessor-name</i>)</tt>,
where <tt><i>field-name</i></tt> and <tt><i>accessor-name</i></tt> are identifiers.

<p>
<tt>define-condition-type</tt> defines <tt><i>name</i></tt> as a new record type whose
parent record type is <tt><i>parent</i></tt>, whose constructor name is
<tt><i>constructor</i></tt>, whose predicate name is <tt><i>pred</i></tt>, whose fields
are <tt><i>field-name</i>&nbsp;...</tt>, and whose field accessors are named
by <tt><i>accessor-name</i>&nbsp;...</tt>.

<p>
With the exception of the predicate and field accessors,
<tt>define-condition-type</tt> is essentially an ordinary record
definition equivalent to

<p>

<p><tt>(define-record-type&nbsp;(<i>name</i>&nbsp;<i>constructor</i>&nbsp;<i>pred</i>)<br>

&nbsp;&nbsp;(parent&nbsp;<i>parent</i>)<br>

&nbsp;&nbsp;(fields&nbsp;((immutable&nbsp;<i>field-name</i>&nbsp;<i>accessor-name</i>)&nbsp;...)))</tt>
<p>The predicate differs from one that would be generated by a
<tt>define-record-type</tt> form in that it returns <tt>#t</tt> not only
for an instance of the new type but also for compound conditions whose simple
conditions include an instance of the new type.
Similarly, field accessors accept instances of the new type as well as
compound conditions whose simple conditions include at least one
instance of the new record type.
If an accessor receives a compound condition whose simple conditions
list includes one or more instances of the new type, the accessor
operates on the first instance in the list.

<p>

<p><tt>(define-condition-type&nbsp;&amp;mistake&nbsp;&amp;condition&nbsp;make-mistake&nbsp;mistake?<br>

&nbsp;&nbsp;(type&nbsp;mistake-type))
<br>
<br>
(mistake?&nbsp;'booboo)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f
<br>
<br>
(define&nbsp;c1&nbsp;(make-mistake&nbsp;'spelling))<br>

(mistake?&nbsp;c1)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(mistake-type&nbsp;c1)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;spelling
<br>
<br>
(define&nbsp;c2&nbsp;(condition&nbsp;c1&nbsp;(make-irritants-condition&nbsp;'(eggregius))))<br>

(mistake?&nbsp;c2)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(mistake-type&nbsp;c2)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;spelling<br>

(irritants-condition?&nbsp;c2)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(condition-irritants&nbsp;c2)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(eggregius)</tt>
<p><a name="./exceptions:s18"></a><span class=formdef><b>procedure</b>: <tt>(condition-predicate&nbsp;<i>rtd</i>)</tt></span>
<br>
<b>returns: </b>a condition predicate
<br>
<span class=formdef><b>procedure</b>: <tt>(condition-accessor&nbsp;<i>rtd</i>&nbsp;<i>procedure</i>)</tt></span>
<br>
<b>returns: </b>a condition accessor
<br>
<b>libraries: </b><tt>(rnrs&nbsp;conditions)</tt>, <tt>(rnrs)</tt>

<p>These procedures may be used to create the same kind of special predicates
and accessors that are created by <tt>define-record-type</tt> from a
record-type descriptor, <tt><i>rtd</i></tt>, of a simple condition type or other
type derived from a simple condition type.

<p>
For both procedures, <tt><i>rtd</i></tt> must be a record-type descriptor of a
subtype of <tt>&amp;condition</tt>, and for <tt>condition-accessor</tt>,
<tt><i>procedure</i></tt> should accept one argument.

<p>
The predicate returned by <tt>condition-predicate</tt> accepts one
argument, which may be any Scheme value.
The predicate returns <tt>#t</tt> if the value is a condition of the type
described by <tt><i>rtd</i></tt>, i.e., an instance of the type described by
<tt><i>rtd</i></tt> (or one of its subtypes) or a compound condition whose simple
conditions include an instance of the type described by <tt><i>rtd</i></tt>.
Otherwise, the predicate returns <tt>#f</tt>.

<p>
The accessor returned by <tt>condition-accessor</tt> accepts one argument,
<tt><i>c</i></tt>, which must be a condition of the type described by <tt><i>rtd</i></tt>.
The accessor applies <tt><i>procedure</i></tt> to a single argument, the first element
of <tt><i>c</i></tt>'s simple condition list that is an instance of the type
described by <tt><i>rtd</i></tt> (this is <tt><i>c</i></tt> itself if <tt><i>c</i></tt> is a simple
condition), and returns the result of this application.
In most situations, <tt><i>procedure</i></tt> is a record accessor for a field of the
type described by <tt><i>rtd</i></tt>.

<p>

<p><tt>(define-record-type&nbsp;(&amp;mistake&nbsp;make-mistake&nbsp;$mistake?)<br>

&nbsp;&nbsp;(parent&nbsp;&amp;condition)<br>

&nbsp;&nbsp;(fields&nbsp;(immutable&nbsp;type&nbsp;$mistake-type)))
<br>
<br>
;&nbsp;define&nbsp;predicate&nbsp;and&nbsp;accessor&nbsp;as&nbsp;if&nbsp;we'd&nbsp;used&nbsp;define-condition-type<br>

(define&nbsp;rtd&nbsp;(record-type-descriptor&nbsp;&amp;mistake))<br>

(define&nbsp;mistake?&nbsp;(condition-predicate&nbsp;rtd))<br>

(define&nbsp;mistake-type&nbsp;(condition-accessor&nbsp;rtd&nbsp;$mistake-type))
<br>
<br>
(define&nbsp;c1&nbsp;(make-mistake&nbsp;'spelling))<br>

(define&nbsp;c2&nbsp;(condition&nbsp;c1&nbsp;(make-irritants-condition&nbsp;'(eggregius))))<br>

(list&nbsp;(mistake?&nbsp;c1)&nbsp;(mistake?&nbsp;c2))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(#t&nbsp;#t)<br>

(list&nbsp;($mistake?&nbsp;c1)&nbsp;($mistake?&nbsp;c2))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(#t&nbsp;#f)<br>

(mistake-type&nbsp;c1)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;spelling<br>

($mistake-type&nbsp;c1)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;spelling<br>

(mistake-type&nbsp;c2)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;spelling<br>

($mistake-type&nbsp;c2)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;<i>violation</i></tt>
<p>
<h3><a name="g150"></a><a name="./exceptions:h3"></a>Section 11.3. Standard Condition Types<a name="SECTEXCCONDTYPES"></a></h3>



<p>
<a name="./exceptions:s19"></a><span class=formdef><b>syntax</b>: <tt>&amp;serious</tt></span>
<br>
<span class=formdef><b>procedure</b>: <tt>(make-serious-condition)</tt></span>
<br>
<b>returns: </b>a condition of type <tt>&amp;serious</tt>
<br>
<span class=formdef><b>procedure</b>: <tt>(serious-condition?&nbsp;<i>obj</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if <tt><i>obj</i></tt> is a condition of type <tt>&amp;serious</tt>, <tt>#f</tt> otherwise
<br>
<b>libraries: </b><tt>(rnrs&nbsp;conditions)</tt>, <tt>(rnrs)</tt>

<p>

<p>Conditions of this type indicate situations
of a serious nature that, if uncaught, generally result in
termination of the program's execution.
Conditions of this type typically occur as one of the more
specific subtypes <tt>&amp;error</tt> or <tt>&amp;violation</tt>.
This condition type might be defined as follows.

<p><tt>(define-condition-type&nbsp;&amp;serious&nbsp;&amp;condition<br>

&nbsp;&nbsp;make-serious-condition&nbsp;serious-condition?)</tt>
<p><a name="./exceptions:s20"></a><span class=formdef><b>syntax</b>: <tt>&amp;violation</tt></span>
<br>
<span class=formdef><b>procedure</b>: <tt>(make-violation)</tt></span>
<br>
<b>returns: </b>a condition of type <tt>&amp;violation</tt>
<br>
<span class=formdef><b>procedure</b>: <tt>(violation?&nbsp;<i>obj</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if <tt><i>obj</i></tt> is a condition of type <tt>&amp;violation</tt>, <tt>#f</tt> otherwise
<br>
<b>libraries: </b><tt>(rnrs&nbsp;conditions)</tt>, <tt>(rnrs)</tt>

<p>

<p>Conditions of this type indicate that the program has violated
some requirement, usually due to a bug in the program.
This condition type might be defined as follows.

<p><tt>(define-condition-type&nbsp;&amp;violation&nbsp;&amp;serious<br>

&nbsp;&nbsp;make-violation&nbsp;violation?)</tt>
<p><a name="./exceptions:s21"></a><span class=formdef><b>syntax</b>: <tt>&amp;assertion</tt></span>
<br>
<span class=formdef><b>procedure</b>: <tt>(make-assertion-violation)</tt></span>
<br>
<b>returns: </b>a condition of type <tt>&amp;assertion</tt>
<br>
<span class=formdef><b>procedure</b>: <tt>(assertion-violation?&nbsp;<i>obj</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if <tt><i>obj</i></tt> is a condition of type <tt>&amp;assertion</tt>, <tt>#f</tt> otherwise
<br>
<b>libraries: </b><tt>(rnrs&nbsp;conditions)</tt>, <tt>(rnrs)</tt>

<p>

<p>This condition type indicates a specific violation in which 
the program has passed the wrong number or types of arguments to
a procedure.
This condition type might be defined as follows.

<p><tt>(define-condition-type&nbsp;&amp;assertion&nbsp;&amp;violation<br>

&nbsp;&nbsp;make-assertion-violation&nbsp;assertion-violation?)</tt>
<p><a name="./exceptions:s22"></a><span class=formdef><b>syntax</b>: <tt>&amp;error</tt></span>
<br>
<span class=formdef><b>procedure</b>: <tt>(make-error)</tt></span>
<br>
<b>returns: </b>a condition of type <tt>&amp;error</tt>
<br>
<span class=formdef><b>procedure</b>: <tt>(error?&nbsp;<i>obj</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if <tt><i>obj</i></tt> is a condition of type <tt>&amp;error</tt>, <tt>#f</tt> otherwise
<br>
<b>libraries: </b><tt>(rnrs&nbsp;conditions)</tt>, <tt>(rnrs)</tt>

<p>

<p>Conditions of this type indicate that an error has occurred with
the program's interaction with its operating environment, such as
the failure of an attempt to open a file.
It is not used to describe situations in which an error in the
program has been detected.
This condition type might be defined as follows.

<p><tt>(define-condition-type&nbsp;&amp;error&nbsp;&amp;serious<br>

&nbsp;&nbsp;make-error&nbsp;error?)</tt>
<p><a name="./exceptions:s23"></a><span class=formdef><b>syntax</b>: <tt>&amp;warning</tt></span>
<br>
<span class=formdef><b>procedure</b>: <tt>(make-warning)</tt></span>
<br>
<b>returns: </b>a condition of type <tt>&amp;warning</tt>
<br>
<span class=formdef><b>procedure</b>: <tt>(warning?&nbsp;<i>obj</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if <tt><i>obj</i></tt> is a condition of type <tt>&amp;warning</tt>, <tt>#f</tt> otherwise
<br>
<b>libraries: </b><tt>(rnrs&nbsp;conditions)</tt>, <tt>(rnrs)</tt>

<p>

<p>Warning conditions indicate situations that do not prevent the program
from continuing its execution but, in some cases, might result in a more
serious problem at some later point.
For example, a compiler might use a condition of this type to indicate
that it has processed a call to a standard procedure with the wrong
number of arguments; this will not become a serious problem unless the
call is actually evaluated at some later point.
This condition type might be defined as follows.

<p><tt>(define-condition-type&nbsp;&amp;warning&nbsp;&amp;condition<br>

&nbsp;&nbsp;make-warning&nbsp;warning?)</tt>
<p><a name="./exceptions:s24"></a><span class=formdef><b>syntax</b>: <tt>&amp;message</tt></span>
<br>
<span class=formdef><b>procedure</b>: <tt>(make-message-condition&nbsp;<i>message</i>)</tt></span>
<br>
<b>returns: </b>a condition of type <tt>&amp;message</tt>
<br>
<span class=formdef><b>procedure</b>: <tt>(message-condition?&nbsp;<i>obj</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if <tt><i>obj</i></tt> is a condition of type <tt>&amp;message</tt>, <tt>#f</tt> otherwise
<br>
<span class=formdef><b>procedure</b>: <tt>(condition-message&nbsp;<i>condition</i>)</tt></span>
<br>
<b>returns: </b>the contents of <tt><i>condition</i></tt>'s <tt>message</tt> field
<br>
<b>libraries: </b><tt>(rnrs&nbsp;conditions)</tt>, <tt>(rnrs)</tt>

<p>

<p>Conditions of this type are usually included with a <tt>&amp;warning</tt>
condition or one of the <tt>&amp;serious</tt> condition subtypes to provide a more
specific description of the exceptional situation.
The <tt><i>message</i></tt> argument to the constructor may be any
Scheme value but is typically a string.
This condition type might be defined as follows.

<p><tt>(define-condition-type&nbsp;&amp;message&nbsp;&amp;condition<br>

&nbsp;&nbsp;make-message-condition&nbsp;message-condition?<br>

&nbsp;&nbsp;(message&nbsp;condition-message))</tt>
<p><a name="./exceptions:s25"></a><span class=formdef><b>syntax</b>: <tt>&amp;irritants</tt></span>
<br>
<span class=formdef><b>procedure</b>: <tt>(make-irritants-condition&nbsp;<i>irritants</i>)</tt></span>
<br>
<b>returns: </b>a condition of type <tt>&amp;irritants</tt>
<br>
<span class=formdef><b>procedure</b>: <tt>(irritants-condition?&nbsp;<i>obj</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if <tt><i>obj</i></tt> is a condition of type <tt>&amp;irritants</tt>, <tt>#f</tt> otherwise
<br>
<span class=formdef><b>procedure</b>: <tt>(condition-irritants&nbsp;<i>condition</i>)</tt></span>
<br>
<b>returns: </b>the contents of <tt><i>condition</i></tt>'s <tt>irritants</tt> field
<br>
<b>libraries: </b><tt>(rnrs&nbsp;conditions)</tt>, <tt>(rnrs)</tt>

<p>

<p>Conditions of this type are usually included with a <tt>&amp;message</tt>
condition to provide information about Scheme values that may have caused
or been materially involved in the exceptional situation.
For example, if a procedure receives the wrong type of argument, it
may raise an exception with a compound condition consisting of an
assertion condition, a who condition naming the procedure,
a message condition stating that the wrong type
of argument was received, and an irritants condition listing the
argument.
The <tt><i>irritants</i></tt> argument to the constructor should
be a list.
This condition type might be defined as follows.

<p><tt>(define-condition-type&nbsp;&amp;irritants&nbsp;&amp;condition<br>

&nbsp;&nbsp;make-irritants-condition&nbsp;irritants-condition?<br>

&nbsp;&nbsp;(irritants&nbsp;condition-irritants))</tt>
<p><a name="./exceptions:s26"></a><span class=formdef><b>syntax</b>: <tt>&amp;who</tt></span>
<br>
<span class=formdef><b>procedure</b>: <tt>(make-who-condition&nbsp;<i>who</i>)</tt></span>
<br>
<b>returns: </b>a condition of type <tt>&amp;who</tt>
<br>
<span class=formdef><b>procedure</b>: <tt>(who-condition?&nbsp;<i>obj</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if <tt><i>obj</i></tt> is a condition of type <tt>&amp;who</tt>, <tt>#f</tt> otherwise
<br>
<span class=formdef><b>procedure</b>: <tt>(condition-who&nbsp;<i>condition</i>)</tt></span>
<br>
<b>returns: </b>the contents of <tt><i>condition</i></tt>'s <tt>who</tt> field
<br>
<b>libraries: </b><tt>(rnrs&nbsp;conditions)</tt>, <tt>(rnrs)</tt>

<p>

<p>Conditions of this type are often included with a <tt>&amp;message</tt>
condition to identify the syntactic form or procedure that detected
the error.
The <tt><i>who</i></tt> argument to the constructor should
be a symbol or string.
This condition type might be defined as follows.

<p><tt>(define-condition-type&nbsp;&amp;who&nbsp;&amp;condition<br>

&nbsp;&nbsp;make-who-condition&nbsp;who-condition?<br>

&nbsp;&nbsp;(who&nbsp;condition-who))</tt>
<p><a name="./exceptions:s27"></a><span class=formdef><b>syntax</b>: <tt>&amp;non-continuable</tt></span>
<br>
<span class=formdef><b>procedure</b>: <tt>(make-non-continuable-violation)</tt></span>
<br>
<b>returns: </b>a condition of type <tt>&amp;non-continuable</tt>
<br>
<span class=formdef><b>procedure</b>: <tt>(non-continuable-violation?&nbsp;<i>obj</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if <tt><i>obj</i></tt> is a condition of type <tt>&amp;non-continuable</tt>, <tt>#f</tt> otherwise
<br>
<b>libraries: </b><tt>(rnrs&nbsp;conditions)</tt>, <tt>(rnrs)</tt>

<p>

<p>Conditions of this type indicate that a non-continuable violation has occurred.
<tt>raise</tt> raises an exception with this type if the current exception
handler returns.
This condition type might be defined as follows.

<p><tt>(define-condition-type&nbsp;&amp;non-continuable&nbsp;&amp;violation<br>

&nbsp;&nbsp;make-non-continuable-violation<br>

&nbsp;&nbsp;non-continuable-violation?)</tt>
<p><a name="./exceptions:s28"></a><span class=formdef><b>syntax</b>: <tt>&amp;implementation-restriction</tt></span>
<br>
<span class=formdef><b>procedure</b>: <tt>(make-implementation-restriction-violation)</tt></span>
<br>
<b>returns: </b>a condition of type <tt>&amp;implementation-restriction</tt>
<br>
<span class=formdef><b>procedure</b>: <tt>(implementation-restriction-violation?&nbsp;<i>obj</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if <tt><i>obj</i></tt> is a condition of type <tt>&amp;implementation-restriction</tt>, <tt>#f</tt> otherwise
<br>
<b>libraries: </b><tt>(rnrs&nbsp;conditions)</tt>, <tt>(rnrs)</tt>

<p>

<p>An implementation-restriction condition indicates that the program has attempted
to exceed some limitation in the implementation, such as when the value of a
fixnum addition operation would result in a number that exceeds the implementation's
fixnum range.
It does not normally indicate a deficiency in the implementation but rather a
mismatch between what the program is attempting to do and what the implementation
can support.
In many cases, implementation restrictions are dictated by the underlying hardware.
This condition type might be defined as follows.

<p><tt>(define-condition-type&nbsp;&amp;implementation-restriction&nbsp;&amp;violation<br>

&nbsp;&nbsp;make-implementation-restriction-violation<br>

&nbsp;&nbsp;implementation-restriction-violation?)</tt>
<p><a name="./exceptions:s29"></a><span class=formdef><b>syntax</b>: <tt>&amp;lexical</tt></span>
<br>
<span class=formdef><b>procedure</b>: <tt>(make-lexical-violation)</tt></span>
<br>
<b>returns: </b>a condition of type <tt>&amp;lexical</tt>
<br>
<span class=formdef><b>procedure</b>: <tt>(lexical-violation?&nbsp;<i>obj</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if <tt><i>obj</i></tt> is a condition of type <tt>&amp;lexical</tt>, <tt>#f</tt> otherwise
<br>
<b>libraries: </b><tt>(rnrs&nbsp;conditions)</tt>, <tt>(rnrs)</tt>

<p>

<p>Conditions of this type indicate that a lexical error has occurred in the parsing
of a Scheme program or datum, such as mismatched parentheses or an invalid character
appearing within a numeric constant.
This condition type might be defined as follows.

<p><tt>(define-condition-type&nbsp;&amp;lexical&nbsp;&amp;violation<br>

&nbsp;&nbsp;make-lexical-violation&nbsp;lexical-violation?)</tt>
<p><a name="./exceptions:s30"></a><span class=formdef><b>syntax</b>: <tt>&amp;syntax</tt></span>
<br>
<span class=formdef><b>procedure</b>: <tt>(make-syntax-violation&nbsp;<i>form</i>&nbsp;<i>subform</i>)</tt></span>
<br>
<b>returns: </b>a condition of type <tt>&amp;syntax</tt>
<br>
<span class=formdef><b>procedure</b>: <tt>(syntax-violation?&nbsp;<i>obj</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if <tt><i>obj</i></tt> is a condition of type <tt>&amp;syntax</tt>, <tt>#f</tt> otherwise
<br>
<span class=formdef><b>procedure</b>: <tt>(syntax-violation-form&nbsp;<i>condition</i>)</tt></span>
<br>
<b>returns: </b>the contents of <tt><i>condition</i></tt>'s <tt>form</tt> field
<br>
<span class=formdef><b>procedure</b>: <tt>(syntax-violation-subform&nbsp;<i>condition</i>)</tt></span>
<br>
<b>returns: </b>the contents of <tt><i>condition</i></tt>'s <tt>subform</tt> field
<br>
<b>libraries: </b><tt>(rnrs&nbsp;conditions)</tt>, <tt>(rnrs)</tt>

<p>

<p>Conditions of this type indicate that a syntax error has occurred in the parsing
of a Scheme program.
In most implementations, syntax errors are detected by the macro expander.
Each of the <tt><i>form</i></tt> and <tt><i>subform</i></tt> arguments to
<tt>make-syntax-violation</tt> should be a syntax object
(Section&nbsp;<a href="./syntax.html#g136">8.3</a>) or datum, the former indicating the containing
form and the latter indicating the specific subform.
For example, if a duplicate formal parameter is found in a <tt>lambda</tt> expression,
<tt><i>form</i></tt> might be the <tt>lambda</tt> expression and <tt><i>subform</i></tt> might be
the duplicated parameter.
If there is no need to identify a subform, <tt><i>subform</i></tt> should be <tt>#f</tt>.
This condition type might be defined as follows.

<p><tt>(define-condition-type&nbsp;&amp;syntax&nbsp;&amp;violation<br>

&nbsp;&nbsp;make-syntax-violation&nbsp;syntax-violation?<br>

&nbsp;&nbsp;(form&nbsp;syntax-violation-form)<br>

&nbsp;&nbsp;(subform&nbsp;syntax-violation-subform))</tt>
<p><a name="./exceptions:s31"></a><span class=formdef><b>syntax</b>: <tt>&amp;undefined</tt></span>
<br>
<span class=formdef><b>procedure</b>: <tt>(make-undefined-violation)</tt></span>
<br>
<b>returns: </b>a condition of type <tt>&amp;undefined</tt>
<br>
<span class=formdef><b>procedure</b>: <tt>(undefined-violation?&nbsp;<i>obj</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if <tt><i>obj</i></tt> is a condition of type <tt>&amp;undefined</tt>, <tt>#f</tt> otherwise
<br>
<b>libraries: </b><tt>(rnrs&nbsp;conditions)</tt>, <tt>(rnrs)</tt>

<p>

<p>An undefined condition indicates an attempt to reference an unbound variable.
This condition type might be defined as follows.

<p><tt>(define-condition-type&nbsp;&amp;undefined&nbsp;&amp;violation<br>

&nbsp;&nbsp;make-undefined-violation&nbsp;undefined-violation?)</tt>
<p><p>The next several condition types describe conditions that occur when
input or output operations fail in some manner.

<p>
<a name="./exceptions:s32"></a><span class=formdef><b>syntax</b>: <tt>&amp;i/o</tt></span>
<br>
<span class=formdef><b>procedure</b>: <tt>(make-i/o-error)</tt></span>
<br>
<b>returns: </b>a condition of type <tt>&amp;i/o</tt>
<br>
<span class=formdef><b>procedure</b>: <tt>(i/o-error?&nbsp;<i>obj</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if <tt><i>obj</i></tt> is a condition of type <tt>&amp;i/o</tt>, <tt>#f</tt> otherwise
<br>
<b>libraries: </b><tt>(rnrs&nbsp;io&nbsp;ports)</tt>, <tt>(rnrs&nbsp;io&nbsp;simple)</tt>, <tt>(rnrs&nbsp;files)</tt>, <tt>(rnrs)</tt>

<p>

<p>A condition of type <tt>&amp;i/o</tt> indicates that an input/output error
of some sort has occurred.
Conditions of this type typically occur as one of the more
specific subtypes described below.
This condition type might be defined as follows.

<p><tt>(define-condition-type&nbsp;&amp;i/o&nbsp;&amp;error<br>

&nbsp;&nbsp;make-i/o-error&nbsp;i/o-error?)</tt>
<p><a name="./exceptions:s33"></a><span class=formdef><b>syntax</b>: <tt>&amp;i/o-read</tt></span>
<br>
<span class=formdef><b>procedure</b>: <tt>(make-i/o-read-error)</tt></span>
<br>
<b>returns: </b>a condition of type <tt>&amp;i/o-read</tt>
<br>
<span class=formdef><b>procedure</b>: <tt>(i/o-read-error?&nbsp;<i>obj</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if <tt><i>obj</i></tt> is a condition of type <tt>&amp;i/o-read</tt>, <tt>#f</tt> otherwise
<br>
<b>libraries: </b><tt>(rnrs&nbsp;io&nbsp;ports)</tt>, <tt>(rnrs&nbsp;io&nbsp;simple)</tt>, <tt>(rnrs&nbsp;files)</tt>, <tt>(rnrs)</tt>

<p>

<p>This condition type indicates that an error has occurred while reading
from a port.
This condition type might be defined as follows.

<p><tt>(define-condition-type&nbsp;&amp;i/o-read&nbsp;&amp;i/o<br>

&nbsp;&nbsp;make-i/o-read-error&nbsp;i/o-read-error?)</tt>
<p><a name="./exceptions:s34"></a><span class=formdef><b>syntax</b>: <tt>&amp;i/o-write</tt></span>
<br>
<span class=formdef><b>procedure</b>: <tt>(make-i/o-write-error)</tt></span>
<br>
<b>returns: </b>a condition of type <tt>&amp;i/o-write</tt>
<br>
<span class=formdef><b>procedure</b>: <tt>(i/o-write-error?&nbsp;<i>obj</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if <tt><i>obj</i></tt> is a condition of type <tt>&amp;i/o-write</tt>, <tt>#f</tt> otherwise
<br>
<b>libraries: </b><tt>(rnrs&nbsp;io&nbsp;ports)</tt>, <tt>(rnrs&nbsp;io&nbsp;simple)</tt>, <tt>(rnrs&nbsp;files)</tt>, <tt>(rnrs)</tt>

<p>

<p>This condition type indicates that an error has occurred while writing
to a port.
This condition type might be defined as follows.

<p><tt>(define-condition-type&nbsp;&amp;i/o-write&nbsp;&amp;i/o<br>

&nbsp;&nbsp;make-i/o-write-error&nbsp;i/o-write-error?)</tt>
<p><a name="./exceptions:s35"></a><span class=formdef><b>syntax</b>: <tt>&amp;i/o-invalid-position</tt></span>
<br>
<span class=formdef><b>procedure</b>: <tt>(make-i/o-invalid-position-error&nbsp;<i>position</i>)</tt></span>
<br>
<b>returns: </b>a condition of type <tt>&amp;i/o-invalid-position</tt>
<br>
<span class=formdef><b>procedure</b>: <tt>(i/o-invalid-position-error?&nbsp;<i>obj</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if <tt><i>obj</i></tt> is a condition of type <tt>&amp;i/o-invalid-position</tt>, <tt>#f</tt> otherwise
<br>
<span class=formdef><b>procedure</b>: <tt>(i/o-error-position&nbsp;<i>condition</i>)</tt></span>
<br>
<b>returns: </b>the contents of <tt><i>condition</i></tt>'s <tt>position</tt> field
<br>
<b>libraries: </b><tt>(rnrs&nbsp;io&nbsp;ports)</tt>, <tt>(rnrs&nbsp;io&nbsp;simple)</tt>, <tt>(rnrs&nbsp;files)</tt>, <tt>(rnrs)</tt>

<p>

<p>This condition type indicates an attempt to set a port's position to a
position that is out of range for the underlying file or other object.
The <tt><i>position</i></tt> argument to the constructor
should be the invalid position.
This condition type might be defined as follows.

<p><tt>(define-condition-type&nbsp;&amp;i/o-invalid-position&nbsp;&amp;i/o<br>

&nbsp;&nbsp;make-i/o-invalid-position-error<br>

&nbsp;&nbsp;i/o-invalid-position-error?<br>

&nbsp;&nbsp;(position&nbsp;i/o-error-position))</tt>
<p><a name="./exceptions:s36"></a><span class=formdef><b>syntax</b>: <tt>&amp;i/o-filename</tt></span>
<br>
<span class=formdef><b>procedure</b>: <tt>(make-i/o-filename-error&nbsp;<i>filename</i>)</tt></span>
<br>
<b>returns: </b>a condition of type <tt>&amp;i/o-filename</tt>
<br>
<span class=formdef><b>procedure</b>: <tt>(i/o-filename-error?&nbsp;<i>obj</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if <tt><i>obj</i></tt> is a condition of type <tt>&amp;i/o-filename</tt>, <tt>#f</tt> otherwise
<br>
<span class=formdef><b>procedure</b>: <tt>(i/o-error-filename&nbsp;<i>condition</i>)</tt></span>
<br>
<b>returns: </b>the contents of <tt><i>condition</i></tt>'s <tt>filename</tt> field
<br>
<b>libraries: </b><tt>(rnrs&nbsp;io&nbsp;ports)</tt>, <tt>(rnrs&nbsp;io&nbsp;simple)</tt>, <tt>(rnrs&nbsp;files)</tt>, <tt>(rnrs)</tt>

<p>

<p>This condition type indicates an input/output error that occurred
while operating on a file.
The <tt><i>filename</i></tt> argument to the constructor should
be the name of the file.
This condition type might be defined as follows.

<p><tt>(define-condition-type&nbsp;&amp;i/o-filename&nbsp;&amp;i/o<br>

&nbsp;&nbsp;make-i/o-filename-error&nbsp;i/o-filename-error?<br>

&nbsp;&nbsp;(filename&nbsp;i/o-error-filename))</tt>
<p><a name="./exceptions:s37"></a><span class=formdef><b>syntax</b>: <tt>&amp;i/o-file-protection</tt></span>
<br>
<span class=formdef><b>procedure</b>: <tt>(make-i/o-file-protection-error&nbsp;<i>filename</i>)</tt></span>
<br>
<b>returns: </b>a condition of type <tt>&amp;i/o-file-protection</tt>
<br>
<span class=formdef><b>procedure</b>: <tt>(i/o-file-protection-error?&nbsp;<i>obj</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if <tt><i>obj</i></tt> is a condition of type <tt>&amp;i/o-file-protection</tt>, <tt>#f</tt> otherwise
<br>
<b>libraries: </b><tt>(rnrs&nbsp;io&nbsp;ports)</tt>, <tt>(rnrs&nbsp;io&nbsp;simple)</tt>, <tt>(rnrs&nbsp;files)</tt>, <tt>(rnrs)</tt>

<p>

<p>A condition of this type indicates that an attempt has been made to perform
some input/output operation on a file for which the program does not have the
proper permission.
This condition type might be defined as follows.

<p><tt>(define-condition-type&nbsp;&amp;i/o-file-protection&nbsp;&amp;i/o-filename<br>

&nbsp;&nbsp;make-i/o-file-protection-error<br>

&nbsp;&nbsp;i/o-file-protection-error?)</tt>
<p><a name="./exceptions:s38"></a><span class=formdef><b>syntax</b>: <tt>&amp;i/o-file-is-read-only</tt></span>
<br>
<span class=formdef><b>procedure</b>: <tt>(make-i/o-file-is-read-only-error&nbsp;<i>filename</i>)</tt></span>
<br>
<b>returns: </b>a condition of type <tt>&amp;i/o-file-is-read-only</tt>
<br>
<span class=formdef><b>procedure</b>: <tt>(i/o-file-is-read-only-error?&nbsp;<i>obj</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if <tt><i>obj</i></tt> is a condition of type <tt>&amp;i/o-file-is-read-only</tt>, <tt>#f</tt> otherwise
<br>
<b>libraries: </b><tt>(rnrs&nbsp;io&nbsp;ports)</tt>, <tt>(rnrs&nbsp;io&nbsp;simple)</tt>, <tt>(rnrs&nbsp;files)</tt>, <tt>(rnrs)</tt>

<p>

<p>A condition of this type indicates an attempt to treat as writeable a read-only file.
This condition type might be defined as follows.

<p><tt>(define-condition-type&nbsp;&amp;i/o-file-is-read-only&nbsp;&amp;i/o-file-protection<br>

&nbsp;&nbsp;make-i/o-file-is-read-only-error<br>

&nbsp;&nbsp;i/o-file-is-read-only-error?)</tt>
<p><a name="./exceptions:s39"></a><span class=formdef><b>syntax</b>: <tt>&amp;i/o-file-already-exists</tt></span>
<br>
<span class=formdef><b>procedure</b>: <tt>(make-i/o-file-already-exists-error&nbsp;<i>filename</i>)</tt></span>
<br>
<b>returns: </b>a condition of type <tt>&amp;i/o-file-already-exists</tt>
<br>
<span class=formdef><b>procedure</b>: <tt>(i/o-file-already-exists-error?&nbsp;<i>obj</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if <tt><i>obj</i></tt> is a condition of type <tt>&amp;i/o-file-already-exists</tt>, <tt>#f</tt> otherwise
<br>
<b>libraries: </b><tt>(rnrs&nbsp;io&nbsp;ports)</tt>, <tt>(rnrs&nbsp;io&nbsp;simple)</tt>, <tt>(rnrs&nbsp;files)</tt>, <tt>(rnrs)</tt>

<p>

<p>A condition of this type indicates a situation in which an operation on a file
failed because the file already exists, e.g., an attempt is made to open an
existing file for output without the <tt>no-fail</tt> file option.
This condition type might be defined as follows.

<p><tt>(define-condition-type&nbsp;&amp;i/o-file-already-exists&nbsp;&amp;i/o-filename<br>

&nbsp;&nbsp;make-i/o-file-already-exists-error<br>

&nbsp;&nbsp;i/o-file-already-exists-error?)</tt>
<p><a name="./exceptions:s40"></a><span class=formdef><b>syntax</b>: <tt>&amp;i/o-file-does-not-exist</tt></span>
<br>
<span class=formdef><b>procedure</b>: <tt>(make-i/o-file-does-not-exist-error&nbsp;<i>filename</i>)</tt></span>
<br>
<b>returns: </b>a condition of type <tt>&amp;i/o-file-does-not-exist</tt>
<br>
<span class=formdef><b>procedure</b>: <tt>(i/o-file-does-not-exist-error?&nbsp;<i>obj</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if <tt><i>obj</i></tt> is a condition of type <tt>&amp;i/o-file-does-not-exist</tt>, <tt>#f</tt> otherwise
<br>
<b>libraries: </b><tt>(rnrs&nbsp;io&nbsp;ports)</tt>, <tt>(rnrs&nbsp;io&nbsp;simple)</tt>, <tt>(rnrs&nbsp;files)</tt>, <tt>(rnrs)</tt>

<p>

<p>A condition of this type indicates a situation in which an operation on a file
failed because the file does not exist, e.g., an attempt is made to open a
nonexistent file for input only.
This condition type might be defined as follows.

<p><tt>(define-condition-type&nbsp;&amp;i/o-file-does-not-exist&nbsp;&amp;i/o-filename<br>

&nbsp;&nbsp;make-i/o-file-does-not-exist-error<br>

&nbsp;&nbsp;i/o-file-does-not-exist-error?)</tt>
<p><a name="./exceptions:s41"></a><span class=formdef><b>syntax</b>: <tt>&amp;i/o-port</tt></span>
<br>
<span class=formdef><b>procedure</b>: <tt>(make-i/o-port-error&nbsp;<i>pobj</i>)</tt></span>
<br>
<b>returns: </b>a condition of type <tt>&amp;i/o-port</tt>
<br>
<span class=formdef><b>procedure</b>: <tt>(i/o-port-error?&nbsp;<i>obj</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if <tt><i>obj</i></tt> is a condition of type <tt>&amp;i/o-port</tt>, <tt>#f</tt> otherwise
<br>
<span class=formdef><b>procedure</b>: <tt>(i/o-error-port&nbsp;<i>condition</i>)</tt></span>
<br>
<b>returns: </b>the contents of <tt><i>condition</i></tt>'s <tt>pobj</tt> field
<br>
<b>libraries: </b><tt>(rnrs&nbsp;io&nbsp;ports)</tt>, <tt>(rnrs&nbsp;io&nbsp;simple)</tt>, <tt>(rnrs&nbsp;files)</tt>, <tt>(rnrs)</tt>

<p>

<p>A condition of this type is usually included with a condition of one of the other <tt>&amp;i/o</tt>
subtypes to indicate the port involved in the exceptional situation, if a port
is involved.
The <tt><i>pobj</i></tt> argument to the constructor should be the port.
This condition type might be defined as follows.

<p><tt>(define-condition-type&nbsp;&amp;i/o-port&nbsp;&amp;i/o<br>

&nbsp;&nbsp;make-i/o-port-error&nbsp;i/o-port-error?<br>

&nbsp;&nbsp;(pobj&nbsp;i/o-error-port))</tt>
<p><a name="./exceptions:s42"></a><span class=formdef><b>syntax</b>: <tt>&amp;i/o-decoding</tt></span>
<br>
<span class=formdef><b>procedure</b>: <tt>(make-i/o-decoding-error&nbsp;<i>pobj</i>)</tt></span>
<br>
<b>returns: </b>a condition of type <tt>&amp;i/o-decoding</tt>
<br>
<span class=formdef><b>procedure</b>: <tt>(i/o-decoding-error?&nbsp;<i>obj</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if <tt><i>obj</i></tt> is a condition of type <tt>&amp;i/o-decoding</tt>, <tt>#f</tt> otherwise
<br>
<b>libraries: </b><tt>(rnrs&nbsp;io&nbsp;ports)</tt>, <tt>(rnrs)</tt>

<p>

<p>A condition of this type indicates that a decoding error has occurred
during the transcoding of bytes to characters.
The <tt><i>pobj</i></tt> argument to the constructor should be the
port involved, if any.
The port should be positioned past the invalid encoding.
This condition type might be defined as follows.

<p><tt>(define-condition-type&nbsp;&amp;i/o-decoding&nbsp;&amp;i/o-port<br>

&nbsp;&nbsp;make-i/o-decoding-error&nbsp;i/o-decoding-error?)</tt>
<p><a name="./exceptions:s43"></a><span class=formdef><b>syntax</b>: <tt>&amp;i/o-encoding</tt></span>
<br>
<span class=formdef><b>procedure</b>: <tt>(make-i/o-encoding-error&nbsp;<i>pobj</i>&nbsp;<i>cobj</i>)</tt></span>
<br>
<b>returns: </b>a condition of type <tt>&amp;i/o-encoding</tt>
<br>
<span class=formdef><b>procedure</b>: <tt>(i/o-encoding-error?&nbsp;<i>obj</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if <tt><i>obj</i></tt> is a condition of type <tt>&amp;i/o-encoding</tt>, <tt>#f</tt> otherwise
<br>
<span class=formdef><b>procedure</b>: <tt>(i/o-encoding-error-char&nbsp;<i>condition</i>)</tt></span>
<br>
<b>returns: </b>the contents of <tt><i>condition</i></tt>'s <tt>cobj</tt> field
<br>
<b>libraries: </b><tt>(rnrs&nbsp;io&nbsp;ports)</tt>, <tt>(rnrs)</tt>

<p>

<p>A condition of this type indicates that an encoding error has occurred
during the transcoding of characters to bytes.
The <tt><i>pobj</i></tt> argument to the constructor should be the
port involved, if any, and the <tt><i>cobj</i></tt> argument should be the character for
which the encoding failed.
This condition type might be defined as follows.

<p><tt>(define-condition-type&nbsp;&amp;i/o-encoding&nbsp;&amp;i/o-port<br>

&nbsp;&nbsp;make-i/o-encoding-error&nbsp;i/o-encoding-error?<br>

&nbsp;&nbsp;(cobj&nbsp;i/o-encoding-error-char))</tt>
<p><p>The final two condition types describe conditions that occur when
implementations are required to produce a NaN or infinity but have
no representations for these values.

<p>
<a name="./exceptions:s44"></a><span class=formdef><b>syntax</b>: <tt>&amp;no-infinities</tt></span>
<br>
<span class=formdef><b>procedure</b>: <tt>(make-no-infinities-violation)</tt></span>
<br>
<b>returns: </b>a condition of type <tt>&amp;no-infinities</tt>
<br>
<span class=formdef><b>procedure</b>: <tt>(no-infinities-violation?&nbsp;<i>obj</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if <tt><i>obj</i></tt> is a condition of type <tt>&amp;no-infinities</tt>, <tt>#f</tt> otherwise
<br>
<b>libraries: </b><tt>(rnrs&nbsp;arithmetic&nbsp;flonums)</tt>, <tt>(rnrs)</tt>

<p>

<p>This condition indicates that the implementation has no representation for
infinity.
This condition type might be defined as follows.

<p><tt>(define-condition-type&nbsp;&amp;no-infinities&nbsp;&amp;implementation-restriction<br>

&nbsp;&nbsp;make-no-infinities-violation<br>

&nbsp;&nbsp;no-infinities-violation?)</tt>
<p><a name="./exceptions:s45"></a><span class=formdef><b>syntax</b>: <tt>&amp;no-nans</tt></span>
<br>
<span class=formdef><b>procedure</b>: <tt>(make-no-nans-violation)</tt></span>
<br>
<b>returns: </b>a condition of type <tt>&amp;no-nans</tt>
<br>
<span class=formdef><b>procedure</b>: <tt>(no-nans-violation?&nbsp;<i>obj</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if <tt><i>obj</i></tt> is a condition of type <tt>&amp;no-nans</tt>, <tt>#f</tt> otherwise
<br>
<b>libraries: </b><tt>(rnrs&nbsp;arithmetic&nbsp;flonums)</tt>, <tt>(rnrs)</tt>

<p>

<p>This condition indicates that the implementation has no representation for
NaN.
This condition type might be defined as follows.

<p><tt>(define-condition-type&nbsp;&amp;no-nans&nbsp;&amp;implementation-restriction<br>

&nbsp;&nbsp;make-no-nans-violation&nbsp;no-nans-violation?)</tt>
<p>



<hr class=copyright align=left>
<p>
R. Kent Dybvig / <it>The Scheme Programming Language, Fourth Edition</it><br>
Copyright &copy; 2009 <a class=plain href="http://mitpress.mit.edu/catalog/item/default.asp?ttype=2&tid=11984">The MIT Press</a>.  Electronically reproduced by permission.<br>
Illustrations &copy; 2009 <a class=plain href="http://hebert.kitp.ucsb.edu/">Jean-Pierre H&eacute;bert</a><br>
ISBN 978-0-262-51298-5 / LOC QA76.73.S34D93<br>
<a class=plain href="http://mitpress.mit.edu/catalog/item/default.asp?ttype=2&tid=11984">to order this book</a> / <a class=plain href="canned/about.html">about this book</a>
</p>
<p><a class=plain href="http://www.scheme.com">http://www.scheme.com</a></p>
</body>
</html>
